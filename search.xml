<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="CRD的简单介绍"><a href="#CRD的简单介绍" class="headerlink" title="CRD的简单介绍"></a>CRD的简单介绍</h1><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><code>Custom Resource Define</code> 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。</p><p>CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个对应的控制器去监听 CRD 的各种事件来添加自定义的业务逻辑。</p><h1 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h1><p>如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。</p><p>比如我们可以定义一个如下所示的 CRD 资源清单文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: apiextensions.<span class="property">k8s</span>.<span class="property">io</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  # name 必须匹配下面的spec字段：&lt;plural&gt;.&lt;group&gt;  </span><br><span class="line">  <span class="attr">name</span>: foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # <span class="keyword">for</span> more information on the below annotation, please see</span><br><span class="line">  # <span class="attr">https</span>:<span class="comment">//github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/2337-k8s.io-group-protection/README.md</span></span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    <span class="string">&quot;api-approved.kubernetes.io&quot;</span>: <span class="string">&quot;unapproved, experimental-only; please get an approval from Kubernetes API reviewers if you&#x27;re trying to develop a CRD in the *.k8s.io or *.kubernetes.io groups&quot;</span></span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  # group 名用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义： /apis/&lt;group&gt;/&lt;version&gt;</span><br><span class="line">  <span class="attr">group</span>: crd.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # 列出自定义资源的所有 <span class="variable constant_">API</span> 版本</span><br><span class="line">  <span class="attr">versions</span>:</span><br><span class="line">    - <span class="attr">name</span>: v1  # 版本名称，比如v1，v1beta1</span><br><span class="line">      <span class="attr">served</span>: <span class="literal">true</span>  # 是否开启通过 <span class="variable constant_">REST</span> <span class="title class_">APIs</span>访问 <span class="string">`/apis/&lt;group&gt;/&lt;version&gt;/...`</span></span><br><span class="line">      <span class="attr">storage</span>: <span class="literal">true</span> # 必须将一个且只有一个版本标记为存储版本</span><br><span class="line">      <span class="attr">schema</span>: # 定义自定义对象的声明规范</span><br><span class="line">        # schema used <span class="keyword">for</span> validation</span><br><span class="line">        <span class="attr">openAPIV3Schema</span>:</span><br><span class="line">          <span class="attr">type</span>: object</span><br><span class="line">          <span class="attr">properties</span>:</span><br><span class="line">            <span class="attr">spec</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">deploymentName</span>:</span><br><span class="line">                  <span class="attr">type</span>: string</span><br><span class="line">                <span class="attr">replicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">                  <span class="attr">minimum</span>: <span class="number">1</span></span><br><span class="line">                  <span class="attr">maximum</span>: <span class="number">10</span></span><br><span class="line">            <span class="attr">status</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">availableReplicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">  <span class="attr">names</span>:</span><br><span class="line">    # kind 是 sigular 的一个驼峰形式的定义，在资源清单中会使用</span><br><span class="line">    <span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line">    # plural 名字用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义：/apis/&lt;group&gt;<span class="regexp">/&lt;version&gt;/</span>&lt;plural&gt;    </span><br><span class="line">    <span class="attr">plural</span>: foos</span><br><span class="line">    # singular 名称用于 <span class="variable constant_">CLI</span> 操作或显示的一个别名    </span><br><span class="line">    <span class="attr">singular</span>: foo</span><br><span class="line">    # shortNames 相当于缩写形式    </span><br><span class="line">    <span class="attr">shortNames</span>:</span><br><span class="line">    - fo</span><br><span class="line">  <span class="attr">scope</span>: <span class="title class_">Namespaced</span></span><br></pre></td></tr></table></figure><p>这个地方的定义和我们定义普通的资源对象比较类似，我们可以随意定义一个自定义的资源对象，但是在创建资源的时候，肯定不是任由我们随意去编写 YAML 文件的，当我们把上面的 CRD 文件提交给 Kubernetes 之后，Kubernetes 会对我们提交的声明文件进行校验，从定义可以看出 CRD 是基于 <a href="https://link.juejin.cn/?target=https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md%23schemaObject">OpenAPI v3 schem</a> 进行规范的。</p><p>当然这种校验只是对于字段的类型进行校验，比较初级，如果想要更加复杂的校验，这个时候就需要通过 Kubernetes 的 admission webhook 来实现了。关于校验的更多用法，可以前往<a href="https://link.juejin.cn/?target=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/%23validation">官方文档</a>查看。</p><p>现在我们可以直接使用kubectl来创建这个CRD资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl apply -f crd.<span class="property">example</span>.<span class="property">com_foos</span>.<span class="property">yaml</span> </span><br><span class="line">customresourcedefinition.<span class="property">apiextensions</span>.<span class="property">k8s</span>.<span class="property">io</span>/foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span> created</span><br></pre></td></tr></table></figure><p>这个时候我们可以查看到集群中已经有我们定义的这个CRD资源对象了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get crd | grep example</span><br><span class="line">foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span>                                  <span class="number">2022</span>-<span class="number">05</span>-11<span class="attr">T05</span>:<span class="number">28</span>:51Z</span><br></pre></td></tr></table></figure><p>这个时候一个新的 namespace 级别的 RESTful API 就会被创建：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/apis/crd/example.<span class="property">com</span>/v1/namespaces<span class="comment">/*/foos/...</span></span><br></pre></td></tr></table></figure><p>接着我们就可以使用这个 API 端点来创建和管理自定义的对象，这些对象的类型就是上面创建的 CRD 对象规范中的 <code>foo</code>。</p><p>现在在 Kubernetes 集群中我们就多了一种新的资源叫做<code>foos.crd.example.com</code>    ，我们就可以使用它来定义一个 <code>Foo</code> 资源对象了，这个自定义资源对象里面可以包含的字段我们在定义的时候通过 <code>schema</code> 进行了规范，比如现在我们来创建一个如下所示的资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>创建完成后我们就可以用kubectl来管理我们这里创建的Foo对象了，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo</span><br><span class="line"><span class="variable constant_">NAME</span>          <span class="variable constant_">AGE</span></span><br><span class="line">example-foo   20m</span><br></pre></td></tr></table></figure><p>在使用 kubectl 的时候，资源名称是不区分大小写的，我们可以使用 CRD 中定义的单数或者复数形式以及任何简写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo example-foo -o yaml</span><br><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    kubectl.<span class="property">kubernetes</span>.<span class="property">io</span>/last-applied-<span class="attr">configuration</span>: |</span><br><span class="line">      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;crd.example.com/v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Foo&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;default&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;deploymentName&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;replicas&quot;</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">  <span class="attr">creationTimestamp</span>: <span class="string">&quot;2022-05-11T05:40:38Z&quot;</span></span><br><span class="line">  <span class="attr">generation</span>: <span class="number">1</span></span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line">  <span class="attr">namespace</span>: <span class="keyword">default</span></span><br><span class="line">  <span class="attr">resourceVersion</span>: <span class="string">&quot;37605212&quot;</span></span><br><span class="line">  <span class="attr">uid</span>: 56d5b1d3-f6f9-<span class="number">4106</span>-90c4-a0e3c7d130c0</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就如上面我们说的，现在我们自定义的资源创建完成了，但是也只是单纯的把资源清单数据存入到了 etcd 中而已，并没有什么其他用处，因为我们没有定义一个对应的控制器来处理相关的业务逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技术随想</title>
      <link href="/posts/dfb8a81f.html"/>
      <url>/posts/dfb8a81f.html</url>
      
        <content type="html"><![CDATA[<p>我是技术随想</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云原生</title>
      <link href="/posts/fb160170.html"/>
      <url>/posts/fb160170.html</url>
      
        <content type="html"><![CDATA[<h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h3 id="容器产品研发"><a href="#容器产品研发" class="headerlink" title="容器产品研发"></a>容器产品研发</h3><p>了解docker、k8s、Istio、k8s-api等云原生技术这有限</p><p>有Kubernetes二次开发经验者优先</p><h3 id="云平台-Kubernetes-专家"><a href="#云平台-Kubernetes-专家" class="headerlink" title="云平台(Kubernetes)专家"></a>云平台(Kubernetes)专家</h3><p>有go语言开发经验</p><p>熟悉Docker&#x2F;Kubernetes容器生态核心开源项目和周边服务生态项目，如监控、日志、网络等方案，精通或者有实施经验者加分；</p><ul><li>DevOps背景，有Kubernetes经验、开源项目贡献维护经历加分；</li></ul><h3 id="云计算研发工程师"><a href="#云计算研发工程师" class="headerlink" title="云计算研发工程师"></a>云计算研发工程师</h3><p>有较强的云原生应用的思维方式，熟悉 K8S 生态产品，有云原生项目实施经验者优先；</p><p>掌握MySQL、MongoDB、Redis、RabbitMQ、Kafka等常用组件；</p><p>掌握Docker或者其它容器化技术和工具使用；</p><p>掌握Prometheus、Grafana、ELK等工具的使用；</p><p>熟悉WEB后端开发技术：协议、架构、存储、缓存、安全等；</p><p>掌握 Git、Jenkins 等 CI&#x2F;CD 工具；</p><h3 id="云原生应用运维工程师"><a href="#云原生应用运维工程师" class="headerlink" title="云原生应用运维工程师"></a>云原生应用运维工程师</h3><p>熟悉 Linux 操作系统，熟悉Xen、KVM虚拟化技术；</p><p>具备良好的代码功底及编码风格，至少熟悉Shell、Python或者GO的其中一种开发语言；</p><p>精通 Docker 与 Kubernetes 的各种组件及原理，熟悉 kubernetes 云原生周边生态，如：istio, prometheus 等；</p><p>了解集群、分布式服务架构，具备高可用，高并发的系统运维经验；</p><h3 id="golang云原生工程师"><a href="#golang云原生工程师" class="headerlink" title="golang云原生工程师"></a>golang云原生工程师</h3><p>对云原生体系有一定的理解，熟悉Kubernetes, Istio,Spiffe等开源软件；</p><p>对4A(Authn,Authz,Account,Audit)体系有一定的理解和实践优先;</p><p>熟练掌握C&#x2F;C++&#x2F;Golang&#x2F;Rust编程语言中的一种；</p><p>善于学习，有技术热情，有较好的逻辑思维和分析能力，拥有良好的沟通意识和团队协作精神；</p><p>良好的中英文读写能力。</p><h3 id="云原生研发专家"><a href="#云原生研发专家" class="headerlink" title="云原生研发专家"></a>云原生研发专家</h3><p>熟悉Linux系统、TCP&#x2F;IP网络协议等计算机基础 知识；</p><p>熟悉Golang语言开发，同时熟悉Java, Python, Shell等其他一种或多种语言，有独立解决各种系统问题的能力，对Golang语言有深刻的理解者优先考虑；</p><p>有Kubernetes&#x2F;Docker项目经验的同学优先， 熟悉源码和原理者加分；</p><p>有Docker&#x2F;Kubernetes&#x2F;lstio二次开发，扩展幵发者、社区经验者优先；</p><p>对AI训练框架Tensorflow&#x2F;Pytorch, 集群调度Kubeflow，调度引擎Argo等有深入研究和实践经验者优先；</p><p>有良好的沟通能力与自我驱动能力，愿意投身云原生领域的浪潮中；</p><p>有生产级别大规模k8s集群运维经验，敏锐的集群故障定位排查能力。</p><h3 id="容器运维工程师"><a href="#容器运维工程师" class="headerlink" title="容器运维工程师"></a>容器运维工程师</h3><p>全日制统招本科（含）以上学历，计算机相关专业；</p><p>熟练linux操作系统，掌握Linux常用命令以及shell、python编程；</p><p>具有一定的网络知识，如dhcp、dns、ntp、tcp等；</p><p>熟悉Docker、Kubernetes技术，包括架构、工作方式、安装部署等，3年以上Kubernetes部署、优化、运维经验；</p><p>精通Kubernetes容器Calico,Flannel等网络组件工作原理,熟悉CNI原理；</p><p>精通Kubernetes容器编排基础组件，包含但不限于helm,prometheus,jenkins等；</p><p>熟练使用golang等技术语言，有实际项目开发经验优先；</p><p>熟悉Prometheus+grafana，有一定的实际项目经验；</p><p>熟悉Gitlab、Jenkins、Ansible、Zabbix、Grafana、Prometheus等工具。</p><h2 id="云原生-容器运维"><a href="#云原生-容器运维" class="headerlink" title="云原生&#x2F;容器运维"></a>云原生&#x2F;容器运维</h2><p>1.统招全日制本科及以上学历，计算机、信息系统等IT相关专业；</p><p>2.熟悉云计算产品 (包括计算、网络、存储、安全数据库等)，熟悉阿里云的产品特点及运维方法；</p><p>3.熟练掌握Prometheus监控系统的部署、监控指标的制定；</p><p>4.了解云原生应用基础设施，例如Server less、Kubernetes (K8S)熟悉微服务应用架构；</p><p>5.熟练使用DevOps和SRE工具，如Terraform, Ansible, Git, Jenkins等；</p><p>6.有运维开发经验, 熟练使用shell、Python或go编程；</p><p>7.在关键任务、高可用性、高性能和大规模系统基础设施方面有经验；</p><p>8.较强的分析、解决问题、人际关系和表达能力；</p><p>9.熟悉Nginx，Redis， Tomcat，消息队列等基础组件及配置、优化等；</p><p>10.有扎实的金融服务行业基础者优先。</p><h2 id="Paas工程师"><a href="#Paas工程师" class="headerlink" title="Paas工程师"></a>Paas工程师</h2><p>1、软件开发能力</p><p>1）、有java开发经验，至少有2年以年开发经验、熟悉使用spring cloud或Dubbo等微服务开发经验</p><ol start="2"><li>原理部分（Linux、脚本、docker、k8s）</li></ol><p>1）、熟悉Linux操作系统</p><p>2）、具备编程开发能力和脚本维护能力（shell、python）</p><p>3）、熟悉Kubenetes构架原理:</p><p>4）、熟悉docker镜像原理和dockerfile制作命令与流程</p><p>5）、熟悉yaml文件编写，了解微服务与DevOps原理架构，具备容器化改造与服务目录上线能力</p><p>6）、具备Docker和K8S的巡检及异常恢复能力</p><p>7）、掌握开源k8s基本操作与管理</p><ol start="3"><li>开发支持能力（devops-cpe开发支持）</li></ol><p>1）掌握开发流水线开发支持</p><p>2）熟练使用开发工具（gitlab、jenkins、SonarQube等）</p><p>4、接受出差。</p><p><a href="https://www.notion.so/Docker-8c66ab360e884ae5a025615f9baab693?pvs=21">Docker基本概念</a></p><p><a href="https://www.notion.so/Docker-32f579b95a5d4fe6aa853e78520ac226?pvs=21">Docker命令实战</a></p><p><a href="https://www.notion.so/Kubernetes-8b8ab08960cc4b828a496c05dc819303?pvs=21">Kubernetes基本概念</a></p><p><a href="https://www.notion.so/Kubernetes-91ca5cc1021f40d2b70e6e5693a29efc?pvs=21">Kubernetes核心实战</a></p><p><a href="https://www.notion.so/KubeSphere-b48825a2c827402292034aa8ab7fb296?pvs=21">KubeSphere</a></p><p><a href="https://www.notion.so/Devops-c660844a21914e1b8b1fedadd51fcaec?pvs=21">Devops</a></p><p><a href="https://www.notion.so/895cb25098ab4ecda1dbdf8b2af76c56?pvs=21">基本概念</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps</title>
      <link href="/posts/a7787d29.html"/>
      <url>/posts/a7787d29.html</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><h1 id="一、DevOps介绍"><a href="#一、DevOps介绍" class="headerlink" title="一、DevOps介绍"></a>一、DevOps介绍</h1><h2 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a>1.1、定义</h2><p>DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障(QA)部门之间的沟通、协作与整合。个人理解DevOps是一种软件管理思维模式。</p><p>思维模式：DevOps就是消除Dev与Ops之间的壁垒(QA)，促进三者之间的沟通、协作与整合，让效率最大化。</p><p>技术落地：从拉取代码、编译构建、验证测试到生产部署，整个环节通过工具构建全流程流水线，自动化触发相关活动，提升研发整体的交付效率和质量。从工具层面优化了执行效率和质量。</p><p>软件开发最开始是由两个团队组成：</p><ul><li>开发计划由<strong>开发团队</strong>从头开始设计和整体系统的构建。需要系统不停的迭代更新。</li><li><strong>运维团队</strong>将开发团队的Code进行测试后部署上线。希望系统稳定安全运行。</li></ul><p>这看似两个目标不同的团队需要协同完成一个软件的开发。</p><p>在开发团队指定好计划并完成coding后，需要提供到运维团队。</p><p>运维团队向开发团队反馈需要修复的BUG以及一些需要返工的任务。</p><p>这时开发团队需要经常等待运维团队的反馈。这无疑延长了事件并推迟了整个软件开发的周期。</p><p>会有一种方式，在开发团队等待的时候，让开发团队转移到下一个项目中。等待运维团队为之前的代码提供反馈。</p><p>可是这样就意味着一个完整的项目需要一个更长的周期才可以开发出最终代码。</p><hr><p>基于现在的互联网现状，更推崇敏捷式开发，这样就导致项目的迭代速度更快，但是由于开发团队与运维团队的沟通问题，会导致新版本上线的时间成本很高。这又违背的敏捷式开发的最初的目的。</p><p>那么如果让开发团队和运维团队整合到成一个团队，协同应对一套软件呢？这就被称为DevOps。</p><p><strong>DevOps</strong>，字面意思是Development &amp;Operations的缩写，也就是开发&amp;运维。</p><p>虽然字面意思只涉及到了开发团队和运维团队，其实QA测试团队也是参与其中的。</p><p>网上可以查看到DevOps的符号类似于一个无穷大的符号</p><p>$$<br>\Large\textsf{DevOps}<br>$$</p><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled.png" alt="Untitled"></p><p>这表明<strong>DevOps</strong>是一个不断提高效率并且持续不断工作的过程</p><p>DevOps的方式可以让公司能够更快地应对更新和市场发展变化，开发可以快速交付，部署也更加稳定。</p><p>核心就在于简化Dev和Ops团队之间的流程，使整体软件开发过程更快速。</p><p>整体的软件开发流程包括：</p><ul><li>PLAN：开发团队根据客户的目标制定开发计划</li><li>CODE：根据PLAN开始编码过程，需要将不同版本的代码存储在一个库中。</li><li>BUILD：编码完成后，需要将代码构建并且运行。</li><li>TEST：成功构建项目后，需要测试代码是否存在BUG或错误。</li><li>DEPLOY：代码经过手动测试和自动化测试后，认定代码已经准备好部署并且交给运维团队。</li><li>OPERATE：运维团队将代码部署到生产环境中。</li><li>MONITOR：项目部署上线后，需要持续的监控产品。</li><li>INTEGRATE：然后将监控阶段收到的反馈发送回PLAN阶段，整体反复的流程就是DevOps的核心，即持续集成、持续部署。</li></ul><p>为了保证整体流程可以高效的完成，各个阶段都有比较常见的工具，如下图：</p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%201.png" alt="Untitled"></p><p>最终可以给DevOps下一个定义：<strong>DevOps 强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</strong></p><p>自动化的工具协作和沟通来完成软件的生命周期管理</p><h3 id="二、Code阶段工具"><a href="#二、Code阶段工具" class="headerlink" title="二、Code阶段工具"></a>二、Code阶段工具</h3><p>在code阶段，我们需要将不同版本的代码存储到一个仓库中，常见的版本控制工具就是SVN或者Git，这里我们采用Git作为版本控制工具，GitLab作为远程仓库。</p><h3 id="2-1-Git安装"><a href="#2-1-Git安装" class="headerlink" title="2.1 Git安装"></a>2.1 Git安装</h3><p><a href="https://git-scm.com/%EF%BC%88%E5%82%BB%E7%93%9C%E5%BC%8F%E5%AE%89%E8%A3%85%EF%BC%89">https://git-scm.com/（傻瓜式安装）</a></p><h3 id="2-2-GitLab安装"><a href="#2-2-GitLab安装" class="headerlink" title="2.2 GitLab安装"></a>2.2 GitLab安装</h3><p>单独准备服务器，采用Docker安装</p><ul><li><p>查看GitLab镜像</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure></li><li><p>拉取GitLab镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure></li><li><p>准备docker-compose.yml文件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line">services:</span><br><span class="line">  gitlab:</span><br><span class="line">    image: &#x27;gitlab/gitlab-ce:latest&#x27;</span><br><span class="line">    container_name: gitlab</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url &#x27;http://192.168.11.11:8929&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 2224</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;8929:8929&#x27;</span><br><span class="line">      - &#x27;2224:2224&#x27;</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x27;./config:/etc/gitlab&#x27;</span><br><span class="line">      - &#x27;./logs:/var/log/gitlab&#x27;</span><br><span class="line">      - &#x27;./data:/var/opt/gitlab&#x27;</span><br></pre></td></tr></table></figure></li><li><p>启动容器（需要稍等一小会……）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>访问GitLab首页首页</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%202.png" alt="Untitled"></p><ul><li><p>查看root用户初始密码初始密码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab cat /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%203.png" alt="Untitled"></p><ul><li>登录root用户登录成功后跳转页面</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%204.png" alt="Untitled"></p><ul><li>第一次登录后需要修改密码修改密码</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%205.png" alt="Untitled"></p><p>搞定后，即可像Gitee、GitHub一样使用。</p><h3 id="三、Build阶段工具"><a href="#三、Build阶段工具" class="headerlink" title="三、Build阶段工具"></a>三、Build阶段工具</h3><p>构建Java项目的工具一般有两种选择，一个是Maven，一个是Gradle。</p><p>这里我们选择Maven作为项目的编译工具。</p><p>具体安装Maven流程不做阐述，但是需要确保配置好Maven仓库私服以及JDK编译版本。</p><h3 id="四、Operate阶段工具"><a href="#四、Operate阶段工具" class="headerlink" title="四、Operate阶段工具"></a>四、Operate阶段工具</h3><p>部署过程，会采用Docker进行部署，暂时只安装Docker即可，后续还需安装Kubenetes</p><h3 id="4-1-Docker安装"><a href="#4-1-Docker安装" class="headerlink" title="4.1 Docker安装"></a>4.1 Docker安装</h3><ul><li><p>准备测试环境&amp;生产环境</p></li><li><p>下载Docker依赖组件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>设置下载Docker的镜像源为阿里云</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker服务</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>安装成功后，启动Docker并设置开机自启</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 启动Docker服务systemctl start docker# 设置开机自动启动systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><h2 id="测试安装成功效果"><a href="#测试安装成功效果" class="headerlink" title="测试安装成功效果    "></a>测试安装成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>  </h2><p>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%206.png" alt="Untitled"></p></li></ul><h3 id="4-2-Docker-Compose安装"><a href="#4-2-Docker-Compose安装" class="headerlink" title="4.2 Docker-Compose安装"></a>4.2 Docker-Compose安装</h3><ul><li><p>下载Docker&#x2F;Compose：<a href="https://github.com/docker/compose">https://github.com/docker/compose</a></p></li><li><p>将下载好的docker-compose-Linux-x86_64文件移动到Linux操作系统：……</p></li><li><p>设置docker-compose-Linux-x86_64文件权限，并移动到$PATH目录中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置文件权限</span><br><span class="line">chmod a+x docker-compose-Linux-x86_64</span><br><span class="line"># 移动到/usr/bin目录下，并重命名为docker-compose</span><br><span class="line">mv docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><h2 id="测试安装成功效果-1"><a href="#测试安装成功效果-1" class="headerlink" title="测试安装成功效果    "></a>测试安装成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>  </h2><p>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%207.png" alt="Untitled"></p></li></ul><h1 id="五、Integrate工具"><a href="#五、Integrate工具" class="headerlink" title="五、Integrate工具"></a>五、Integrate工具</h1><p>持续集成、持续部署的工具很多，其中Jenkins是一个开源的持续集成平台。</p><p>Jenkins涉及到将编写完毕的代码发布到测试环境和生产环境的任务，并且还涉及到了构建项目等任务。</p><p>Jenkins需要大量的插件保证工作，安装成本较高，下面会基于Docker搭建Jenkins。</p><h2 id="5-1-Jenkins介绍"><a href="#5-1-Jenkins介绍" class="headerlink" title="5.1 Jenkins介绍"></a>5.1 Jenkins介绍</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具</p><p>Jenkins应用广泛，大多数互联网公司都采用Jenkins配合GitLab、Docker、K8s作为实现DevOps的核心工具。</p><p>Jenkins最强大的就在于插件，Jenkins官方提供了大量的插件库，来自动化CI&#x2F;CD过程中的各种琐碎功能。</p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%208.png" alt="Untitled"></p><p>Jenkins最主要的工作就是将GitLab上可以构建的工程代码拉取并且进行构建，再根据流程可以选择发布到测试环境或是生产环境。</p><p>一般是GitLab上的代码经过大量的测试后，确定发行版本，再发布到生产环境。</p><p>CI&#x2F;CD可以理解为：</p><ul><li>CI过程即是通过Jenkins将代码拉取、构建、制作镜像交给测试人员测试。<ul><li>持续集成：让软件代码可以持续的集成到主干上，并自动构建和测试。</li></ul></li><li>CD过程即是通过Jenkins将打好标签的发行版本代码拉取、构建、制作镜像交给运维人员部署。<ul><li>持续交付：让经过持续集成的代码可以进行手动部署。</li><li>持续部署：让可以持续交付的代码随时随地的自动化部署。</li></ul></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%209.png" alt="Untitled"></p><h2 id="5-2-Jenkins安装"><a href="#5-2-Jenkins安装" class="headerlink" title="5.2 Jenkins安装"></a>5.2 Jenkins安装</h2><ul><li><p>拉取Jenkins镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br></pre></td></tr></table></figure></li><li><p>编写docker-compose.yml</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 50000:50000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/:/var/jenkins_home/</span><br></pre></td></tr></table></figure></li><li><p>首次启动会因为数据卷data目录没有权限导致启动失败，设置data目录写权限错误日志</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2010.png" alt="Untitled"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+w data/</span><br></pre></td></tr></table></figure><ul><li><p>重新启动Jenkins容器后，由于Jenkins需要下载大量内容，但是由于默认下载地址下载速度较慢，需要重新设置下载地址为国内镜像站</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 修改数据卷中的hudson.model.UpdateCenter.xml文件</span><br><span class="line">&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"># 将下载地址替换为http://mirror.esuni.jp/jenkins/updates/update-center.json</span><br><span class="line">&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;http://mirror.esuni.jp/jenkins/updates/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"># 清华大学的插件源也可以https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure></li><li><p>再次重启Jenkins容器，访问Jenkins（需要稍微等会）Jenkins首页</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2011.png" alt="Untitled"></p><ul><li><h2 id="查看密码登录Jenkins，并登录下载插件登录并下载插件"><a href="#查看密码登录Jenkins，并登录下载插件登录并下载插件" class="headerlink" title="查看密码登录Jenkins，并登录下载插件登录并下载插件    "></a>查看密码登录Jenkins，并登录下载插件登录并下载插件<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>  </h2>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2012.png" alt="Untitled"></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2013.png" alt="Untitled"></p><ul><li>选择需要安装的插件选择需要安装的插件</li><li>下载完毕设置信息进入首页（可能会出现下载失败的插件）</li></ul><h2 id="5-3、Jenkins入门配置"><a href="#5-3、Jenkins入门配置" class="headerlink" title="5.3、Jenkins入门配置"></a>5.3、Jenkins入门配置</h2><p>由于Jenkins需要从Git拉取代码、需要本地构建、甚至需要直接发布自定义镜像到Docker仓库，所以Jenkins需要配置大量内容。</p><h3 id="5-3-1-构建任务"><a href="#5-3-1-构建任务" class="headerlink" title="5.3.1 构建任务"></a>5.3.1 构建任务</h3><p>准备好GitLab仓库中的项目，并且通过Jenkins配置项目的实现当前项目的DevOps基本流程。</p><ul><li>构建Maven工程发布到GitLab（Gitee、Github均可）GitLab查看项目</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2014.png" alt="Untitled"></p><ul><li>Jenkins点击左侧导航新建任务新建任务</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2015.png" alt="Untitled"></p><ul><li>选择自由风格构建任务构建任务</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2016.png" alt="Untitled"></p><h3 id="5-3-1-配置源码拉取地址"><a href="#5-3-1-配置源码拉取地址" class="headerlink" title="5.3.1 配置源码拉取地址"></a>5.3.1 配置源码拉取地址</h3><p>Jenkins需要将Git上存放的源码存储到Jenkins服务所在磁盘的本地</p><ul><li>配置任务源码拉取的地址源码管理</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2017.png" alt="Untitled"></p><ul><li>Jenkins立即构建点击任务test中的立即构建</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2018.png" alt="Untitled"></p><ul><li>查看构建工程的日志，点击上述③的任务条即可查看任务拉取Git源码日志</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2019.png" alt="Untitled"></p><hr><p>可以看到源码已经拉取带Jenkins本地，可以根据第三行日志信息，查看Jenkins本地拉取到的源码。</p><ul><li>查看Jenkins容器中&#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;test的源码</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2020.png" alt="Untitled"></p><h3 id="5-3-2-配置Maven构建代码"><a href="#5-3-2-配置Maven构建代码" class="headerlink" title="5.3.2 配置Maven构建代码"></a>5.3.2 配置Maven构建代码</h3><p>代码拉取到Jenkins本地后，需要在Jenkins中对代码进行构建，这里需要Maven的环境，而Maven需要Java的环境，接下来需要在Jenkins中安装JDK和Maven，并且配置到Jenkins服务。</p><ul><li>准备JDK、Maven压缩包通过数据卷映射到Jenkins容器内部数据卷存放位置</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2021.png" alt="Untitled"></p><ul><li><p>解压压缩包，并配置Maven的settings.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云镜像地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK1.8编译插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Jenkins配置JDK&amp;Maven并保存</p></li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2022.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2023.png" alt="Untitled"></p><ul><li>配置Jenkins任务构建代码</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2024.png" alt="Untitled"></p><ul><li>立即构建测试，查看target下的jar包构建源码</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2025.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2026.png" alt="Untitled"></p><h3 id="5-3-3-配置Publish发布-远程操作"><a href="#5-3-3-配置Publish发布-远程操作" class="headerlink" title="5.3.3 配置Publish发布&amp;远程操作"></a>5.3.3 配置Publish发布&amp;远程操作</h3><p>jar包构建好之后，就可以根据情况发布到测试或生产环境，这里需要用到之前下载好的插件Publish Over SSH。</p><ul><li>配置Publish Over SSH连接测试、生产环境Publish Over SSH配置</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2027.png" alt="Untitled"></p><ul><li>配置任务的构建后操作，发布jar包到目标服务配置构建后操作</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2028.png" alt="Untitled"></p><p>- </p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2029.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2030.png" alt="Untitled"></p><ul><li>立即构建任务，并去目标服务查看</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2031.png" alt="Untitled"></p><h3 id="六、CI、CD入门操作"><a href="#六、CI、CD入门操作" class="headerlink" title="六、CI、CD入门操作"></a>六、CI、CD入门操作</h3><p>基于Jenkins拉取GitLab的SpringBoot代码进行构建发布到测试环境实现持续集成</p><p>基于Jenkins拉取GitLab指定发行版本的SpringBoot代码进行构建发布到生产环境实现CD实现持续部署</p><h3 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h3><p>为了让程序代码可以自动推送到测试环境基于Docker服务运行，需要添加Docker配置和脚本文件让程序可以在集成到主干的同时运行起来。</p><ul><li>添加Dockerfile文件构建自定义镜像</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2032.png" alt="Untitled"></p><ul><li>添加docker-compose.yml文件加载自定义镜像启动容器</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2033.png" alt="Untitled"></p><ul><li>追加Jenkins构建后操作脚本命令构建后发布并执行脚本命令</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2034.png" alt="Untitled"></p><ul><li>发布到GitLab后由Jenkins立即构建并托送到目标服务器</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2035.png" alt="Untitled"></p><ul><li>测试部署到目标服务器程序</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2036.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2037.png" alt="Untitled"></p><h3 id="6-2-持续交付、部署"><a href="#6-2-持续交付、部署" class="headerlink" title="6.2 持续交付、部署"></a>6.2 持续交付、部署</h3><p>程序代码在经过多次集成操作到达最终可以交付，持续交付整体流程和持续集成类似，不过需要选取指定的发行版本</p><ul><li>下载Git Parameter插件</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2038.png" alt="Untitled"></p><hr><ul><li>设置项目参数化构建-基于Git标签构建</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2039.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2040.png" alt="Untitled"></p><ul><li>给项目添加tag版本添加tag版本</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2041.png" alt="Untitled"></p><ul><li>基于Parameter构建任务，任务发布到目标服务器</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2042.png" alt="Untitled"></p><h3 id="七、集成Sonar-Qube"><a href="#七、集成Sonar-Qube" class="headerlink" title="七、集成Sonar Qube"></a>七、集成Sonar Qube</h3><h3 id="7-1-Sonar-Qube介绍"><a href="#7-1-Sonar-Qube介绍" class="headerlink" title="7.1 Sonar Qube介绍"></a>7.1 Sonar Qube介绍</h3><p>Sonar Qube是一个开源的代码分析平台，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，可以检测出重复代码、代码漏洞、代码规范和安全性漏洞的问题。</p><p>Sonar Qube可以与多种软件整合进行代码扫描，比如Maven，Gradle，Git，Jenkins等，并且会将代码检测结果推送回Sonar Qube并且在系统提供的UI界面上显示出来</p><p>Sonar Qube的UI界面</p><hr><p><img src="https://www.notion.sopictures/image-20211129190039986.png" alt="https://www.notion.soPictures/image-20211129190039986.png"></p><hr><h3 id="7-2-Sonar-Qube环境搭建"><a href="#7-2-Sonar-Qube环境搭建" class="headerlink" title="7.2 Sonar Qube环境搭建"></a>7.2 Sonar Qube环境搭建</h3><h3 id="7-2-1-Sonar-Qube安装"><a href="#7-2-1-Sonar-Qube安装" class="headerlink" title="7.2.1 Sonar Qube安装"></a>7.2.1 Sonar Qube安装</h3><p>Sonar Qube在7.9版本中已经放弃了对MySQL的支持，并且建议在商业环境中采用PostgreSQL，那么安装Sonar Qube时需要依赖PostgreSQL。</p><p>并且这里会安装Sonar Qube的长期支持版本8.9</p><ul><li><p>拉取镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgresdocker pull sonarqube:8.9.3-community</span><br></pre></td></tr></table></figure></li><li><p>编写docker-compoe.yml</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;services:  db:    image: postgres    container_name: db    ports:      - 5432:5432    networks:      - sonarnet    environment:      POSTGRES_USER: sonar      POSTGRES_PASSWORD: sonar  sonarqube:    image: sonarqube:8.9.3-community    container_name: sonarqube    depends_on:      - db    ports:      - &quot;9000:9000&quot;    networks:      - sonarnet    environment:      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar      SONAR_JDBC_USERNAME: sonar      SONAR_JDBC_PASSWORD: sonarnetworks:  sonarnet:    driver: bridge</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><h2 id="需要设置sysctl-conf文件信息设置vm-max-map-count"><a href="#需要设置sysctl-conf文件信息设置vm-max-map-count" class="headerlink" title="需要设置sysctl.conf文件信息设置vm.max_map_count  "></a>需要设置sysctl.conf文件信息设置vm.max_map_count  </h2><h2 id=""><a href="#" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211207145215817.png" alt="https://www.notion.soPictures/image-20211207145215817.png">  </h2><h2 id="-1"><a href="#-1" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211207145342350.png" alt="https://www.notion.soPictures/image-20211207145342350.png">  </h2><p>  并执行命令刷新</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><h2 id="重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志"><a href="#重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志" class="headerlink" title="重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志  "></a>重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志  </h2><h2 id="-2"><a href="#-2" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129191426344.png" alt="https://www.notion.soPictures/image-20211129191426344.png">  </h2></li><li><h2 id="访问Sonar-Qube首页登录"><a href="#访问Sonar-Qube首页登录" class="headerlink" title="访问Sonar Qube首页登录  "></a>访问Sonar Qube首页登录  </h2><h2 id="-3"><a href="#-3" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129191537050.png" alt="https://www.notion.soPictures/image-20211129191537050.png">  </h2></li><li><h2 id="还需要重新设置一次密码重新设置密码"><a href="#还需要重新设置一次密码重新设置密码" class="headerlink" title="还需要重新设置一次密码重新设置密码  "></a>还需要重新设置一次密码重新设置密码  </h2><h2 id="-4"><a href="#-4" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129193824428.png" alt="https://www.notion.soPictures/image-20211129193824428.png">  </h2></li><li><h2 id="Sonar-Qube首页Sonar-Qube首页"><a href="#Sonar-Qube首页Sonar-Qube首页" class="headerlink" title="Sonar Qube首页Sonar Qube首页  "></a>Sonar Qube首页Sonar Qube首页  </h2><h2 id="-5"><a href="#-5" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129194148239.png" alt="https://www.notion.soPictures/image-20211129194148239.png">  </h2></li></ul><h3 id="7-2-2-安装中文插件"><a href="#7-2-2-安装中文插件" class="headerlink" title="7.2.2 安装中文插件"></a>7.2.2 安装中文插件</h3><p>安装中文插件</p><hr><p><img src="https://www.notion.sopictures/image-20211129194621820.png" alt="https://www.notion.soPictures/image-20211129194621820.png"></p><hr><p>安装成功后需要重启，安装失败重新点击install重装即可。</p><p>安装成功后，会查看到重启按钮，点击即可</p><p>重启按钮</p><hr><p><img src="https://www.notion.sopictures/image-20211129194748765.png" alt="https://www.notion.soPictures/image-20211129194748765.png"></p><hr><p>重启后查看效果</p><p>首页效果</p><hr><p><img src="https://www.notion.sopictures/image-20211129194931944.png" alt="https://www.notion.soPictures/image-20211129194931944.png"></p><hr><h3 id="7-3-Sonar-Qube基本使用"><a href="#7-3-Sonar-Qube基本使用" class="headerlink" title="7.3 Sonar Qube基本使用"></a>7.3 Sonar Qube基本使用</h3><p>Sonar Qube的使用方式很多，Maven可以整合，也可以采用sonar-scanner的方式，再查看Sonar Qube的检测效果</p><h3 id="7-3-1-Maven实现代码检测"><a href="#7-3-1-Maven实现代码检测" class="headerlink" title="7.3.1 Maven实现代码检测"></a>7.3.1 Maven实现代码检测</h3><ul><li><p>修改Maven的settings.xml文件配置Sonar Qube信息</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.login</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">sonar.login</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.password</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">sonar.password</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span>http://192.168.11.11:9000<span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h2 id="在代码位置执行命令：mvn-sonar-sonar执行代码检测"><a href="#在代码位置执行命令：mvn-sonar-sonar执行代码检测" class="headerlink" title="在代码位置执行命令：mvn sonar:sonar执行代码检测  "></a>在代码位置执行命令：mvn sonar:sonar执行代码检测  </h2><h2 id="-6"><a href="#-6" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129195430146.png" alt="https://www.notion.soPictures/image-20211129195430146.png">  </h2></li><li><h2 id="查看Sonar-Qube界面检测结果Sonar-Qube检测结果"><a href="#查看Sonar-Qube界面检测结果Sonar-Qube检测结果" class="headerlink" title="查看Sonar Qube界面检测结果Sonar Qube检测结果  "></a>查看Sonar Qube界面检测结果Sonar Qube检测结果  </h2><h2 id="-7"><a href="#-7" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129195503762.png" alt="https://www.notion.soPictures/image-20211129195503762.png">  </h2></li></ul><h3 id="7-3-2-Sonar-scanner实现代码检测"><a href="#7-3-2-Sonar-scanner实现代码检测" class="headerlink" title="7.3.2 Sonar-scanner实现代码检测"></a>7.3.2 Sonar-scanner实现代码检测</h3><ul><li><p>下载Sonar-scanner：<a href="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/">https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/</a></p><p>  下载4.6.x版本即可，要求Linux版本</p></li><li><p>解压并配置sonar服务端信息</p><ul><li><p>由于是zip压缩包，需要安装unzip解压插件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install unzip</span><br></pre></td></tr></table></figure></li><li><p>解压压缩包</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br></pre></td></tr></table></figure></li><li><h2 id="配置sonarQube服务端地址，修改conf下的sonar-scanner-properties配置服务端信息"><a href="#配置sonarQube服务端地址，修改conf下的sonar-scanner-properties配置服务端信息" class="headerlink" title="配置sonarQube服务端地址，修改conf下的sonar-scanner.properties配置服务端信息  "></a>配置sonarQube服务端地址，修改conf下的sonar-scanner.properties配置服务端信息  </h2><h2 id="-8"><a href="#-8" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130140043382.png" alt="https://www.notion.soPictures/image-20211130140043382.png">  </h2></li></ul></li><li><h2 id="执行命令检测代码查看日志信息-Ps：主要查看我的sonar-scanner执行命令的位置"><a href="#执行命令检测代码查看日志信息-Ps：主要查看我的sonar-scanner执行命令的位置" class="headerlink" title="执行命令检测代码查看日志信息    Ps：主要查看我的sonar-scanner执行命令的位置  "></a>执行命令检测代码查看日志信息<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 在项目所在目录执行以下命令~/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=demo -Dsonar.projectKey=java -Dsonar.java.binaries=target/</span><br></pre></td></tr></table></figure><br><br>  Ps：主要查看我的sonar-scanner执行命令的位置  </h2><h2 id="-9"><a href="#-9" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130141303457.png" alt="https://www.notion.soPictures/image-20211130141303457.png">  </h2></li><li><h2 id="查看SonarQube界面检测结果检测结果"><a href="#查看SonarQube界面检测结果检测结果" class="headerlink" title="查看SonarQube界面检测结果检测结果  "></a>查看SonarQube界面检测结果检测结果  </h2><h2 id="-10"><a href="#-10" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130144608025.png" alt="https://www.notion.soPictures/image-20211130144608025.png">  </h2></li></ul><h3 id="7-4-Jenkins集成Sonar-Qube"><a href="#7-4-Jenkins集成Sonar-Qube" class="headerlink" title="7.4 Jenkins集成Sonar Qube"></a>7.4 Jenkins集成Sonar Qube</h3><p>Jenkins继承Sonar Qube实现代码扫描需要先下载整合插件</p><h3 id="7-4-1-Jenkins安装插件"><a href="#7-4-1-Jenkins安装插件" class="headerlink" title="7.4.1 Jenkins安装插件"></a>7.4.1 Jenkins安装插件</h3><p>下载Sonar Qube插件</p><hr><p><img src="https://www.notion.sopictures/image-20211129201625561.png" alt="https://www.notion.soPictures/image-20211129201625561.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211129201607240.png" alt="https://www.notion.soPictures/image-20211129201607240.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211129202147390.png" alt="https://www.notion.soPictures/image-20211129202147390.png"></p><hr><h3 id="7-4-2-Jenkins配置Sonar-Qube"><a href="#7-4-2-Jenkins配置Sonar-Qube" class="headerlink" title="7.4.2 Jenkins配置Sonar Qube"></a>7.4.2 Jenkins配置Sonar Qube</h3><ul><li><h2 id="开启Sonar-Qube权限验证开启Sonar-Qube权限校验"><a href="#开启Sonar-Qube权限验证开启Sonar-Qube权限校验" class="headerlink" title="开启Sonar Qube权限验证开启Sonar Qube权限校验  "></a>开启Sonar Qube权限验证开启Sonar Qube权限校验  </h2><h2 id="-11"><a href="#-11" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130144850186.png" alt="https://www.notion.soPictures/image-20211130144850186.png">  </h2></li><li><h2 id="获取Sonar-Qube的令牌获取令牌"><a href="#获取Sonar-Qube的令牌获取令牌" class="headerlink" title="获取Sonar Qube的令牌获取令牌  "></a>获取Sonar Qube的令牌获取令牌  </h2><h2 id="-12"><a href="#-12" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203102334.png" alt="https://www.notion.soPictures/image-20211129203102334.png">  </h2></li><li><h2 id="配置Jenkins的Sonar-Qube信息"><a href="#配置Jenkins的Sonar-Qube信息" class="headerlink" title="配置Jenkins的Sonar Qube信息    "></a>配置Jenkins的Sonar Qube信息<br><br>  <img src="https://www.notion.sopictures/image-20211129203235019.png" alt="https://www.notion.soPictures/image-20211129203235019.png">  </h2><h2 id="-13"><a href="#-13" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203342171.png" alt="https://www.notion.soPictures/image-20211129203342171.png">  </h2><h2 id="-14"><a href="#-14" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203457604.png" alt="https://www.notion.soPictures/image-20211129203457604.png">  </h2></li></ul><h3 id="7-4-3-配置Sonar-scanner"><a href="#7-4-3-配置Sonar-scanner" class="headerlink" title="7.4.3 配置Sonar-scanner"></a>7.4.3 配置Sonar-scanner</h3><ul><li><h2 id="将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner"><a href="#将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner" class="headerlink" title="将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner  "></a>将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner  </h2><h2 id="-15"><a href="#-15" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130153628925.png" alt="https://www.notion.soPictures/image-20211130153628925.png">  </h2></li><li><h2 id="配置任务的Sonar-scanner配置任务的Sonar-scanner"><a href="#配置任务的Sonar-scanner配置任务的Sonar-scanner" class="headerlink" title="配置任务的Sonar-scanner配置任务的Sonar-scanner  "></a>配置任务的Sonar-scanner配置任务的Sonar-scanner  </h2><h2 id="-16"><a href="#-16" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130155849143.png" alt="https://www.notion.soPictures/image-20211130155849143.png">  </h2></li></ul><h3 id="7-4-4-构建任务"><a href="#7-4-4-构建任务" class="headerlink" title="7.4.4 构建任务"></a>7.4.4 构建任务</h3><p>构建任务</p><hr><p><img src="https://www.notion.sopictures/image-20211130160017465.png" alt="https://www.notion.soPictures/image-20211130160017465.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211130160047648.png" alt="https://www.notion.soPictures/image-20211130160047648.png"></p><hr><h3 id="八、集成Harbor"><a href="#八、集成Harbor" class="headerlink" title="八、集成Harbor"></a>八、集成Harbor</h3><h3 id="8-1-Harbor介绍"><a href="#8-1-Harbor介绍" class="headerlink" title="8.1 Harbor介绍"></a>8.1 Harbor介绍</h3><p>前面在部署项目时，我们主要采用Jenkins推送jar包到指定服务器，再通过脚本命令让目标服务器对当前jar进行部署，这种方式在项目较多时，每个目标服务器都需要将jar包制作成自定义镜像再通过docker进行启动，重复操作比较多，会降低项目部署时间。</p><p>我们可以通过Harbor作为私有的Docker镜像仓库。让Jenkins统一将项目打包并制作成Docker镜像发布到Harbor仓库中，只需要通知目标服务，让目标服务统一去Harbor仓库上拉取镜像并在本地部署即可。</p><p>Docker官方提供了Registry镜像仓库，但是Registry的功能相对简陋。Harbor是VMware公司提供的一款镜像仓库，提供了权限控制、分布式发布、强大的安全扫描与审查机制等功能</p><h3 id="8-2-Harbor安装"><a href="#8-2-Harbor安装" class="headerlink" title="8.2 Harbor安装"></a>8.2 Harbor安装</h3><p>这里采用原生的方式安装Harbor。</p><ul><li><p>下载Harbor安装包：<a href="https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz">https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz</a></p></li><li><p>拖拽到Linux并解压：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.3.4.tgz -C /usr/local/</span><br></pre></td></tr></table></figure></li><li><p>修改Harbor配置文件：</p><ul><li><p>首先复制一份harbor.yml配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.yml</span><br></pre></td></tr></table></figure></li><li><h2 id="编辑harbor-yml配置文件配置Harbor文件"><a href="#编辑harbor-yml配置文件配置Harbor文件" class="headerlink" title="编辑harbor.yml配置文件配置Harbor文件  "></a>编辑harbor.yml配置文件配置Harbor文件  </h2><h2 id="-17"><a href="#-17" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130215555218.png" alt="https://www.notion.soPictures/image-20211130215555218.png">  </h2></li></ul></li><li><h2 id="启动Harbor查看日志"><a href="#启动Harbor查看日志" class="headerlink" title="启动Harbor查看日志    "></a>启动Harbor查看日志<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>  </h2><h2 id="-18"><a href="#-18" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130215941857.png" alt="https://www.notion.soPictures/image-20211130215941857.png">  </h2></li><li><h2 id="登录Harbor登录Harbor"><a href="#登录Harbor登录Harbor" class="headerlink" title="登录Harbor登录Harbor  "></a>登录Harbor登录Harbor  </h2><h2 id="-19"><a href="#-19" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130220028840.png" alt="https://www.notion.soPictures/image-20211130220028840.png">  </h2></li><li><h2 id="首页信息首页信息"><a href="#首页信息首页信息" class="headerlink" title="首页信息首页信息  "></a>首页信息首页信息  </h2><h2 id="-20"><a href="#-20" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130220111602.png" alt="https://www.notion.soPictures/image-20211130220111602.png">  </h2></li></ul><h3 id="8-3-Harbor使用方式"><a href="#8-3-Harbor使用方式" class="headerlink" title="8.3 Harbor使用方式"></a>8.3 Harbor使用方式</h3><p>Harbor作为镜像仓库，主要的交互方式就是将镜像上传到Harbor上，以及从Harbor上下载指定镜像</p><p>在传输镜像前，可以先使用Harbor提供的权限管理，将项目设置为私有项目，并对不同用户设置不同角色，从而更方便管理镜像。</p><h3 id="8-3-1-添加用户构建项目"><a href="#8-3-1-添加用户构建项目" class="headerlink" title="8.3.1 添加用户构建项目"></a>8.3.1 添加用户构建项目</h3><ul><li><h2 id="创建用户创建用户"><a href="#创建用户创建用户" class="headerlink" title="创建用户创建用户  "></a>创建用户创建用户  </h2><h2 id="-21"><a href="#-21" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213427157.png" alt="https://www.notion.soPictures/image-20211201213427157.png">  </h2></li><li><h2 id="构建项目（设置为私有）构建项目"><a href="#构建项目（设置为私有）构建项目" class="headerlink" title="构建项目（设置为私有）构建项目  "></a>构建项目（设置为私有）构建项目  </h2><h2 id="-22"><a href="#-22" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213751780.png" alt="https://www.notion.soPictures/image-20211201213751780.png">  </h2></li><li><h2 id="给项目追加用户追加用户管理"><a href="#给项目追加用户追加用户管理" class="headerlink" title="给项目追加用户追加用户管理  "></a>给项目追加用户追加用户管理  </h2><h2 id="-23"><a href="#-23" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213832458.png" alt="https://www.notion.soPictures/image-20211201213832458.png">  </h2></li><li><h2 id="切换测试用户切换测试用户"><a href="#切换测试用户切换测试用户" class="headerlink" title="切换测试用户切换测试用户  "></a>切换测试用户切换测试用户  </h2><h2 id="-24"><a href="#-24" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201214008303.png" alt="https://www.notion.soPictures/image-20211201214008303.png">  </h2></li></ul><h3 id="8-3-2-发布镜像到Harbor"><a href="#8-3-2-发布镜像到Harbor" class="headerlink" title="8.3.2 发布镜像到Harbor"></a>8.3.2 发布镜像到Harbor</h3><ul><li><h2 id="修改镜像名称修改镜像名称-名称要求：harbor地址-项目名-镜像名-版本"><a href="#修改镜像名称修改镜像名称-名称要求：harbor地址-项目名-镜像名-版本" class="headerlink" title="修改镜像名称修改镜像名称  名称要求：harbor地址&#x2F;项目名&#x2F;镜像名:版本  "></a>修改镜像名称修改镜像名称<br><br>  名称要求：harbor地址&#x2F;项目名&#x2F;镜像名:版本  </h2><h2 id="-25"><a href="#-25" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221040200.png" alt="https://www.notion.soPictures/image-20211201221040200.png">  </h2></li><li><h2 id="修改daemon-json，支持Docker仓库，并重启Docker修改daemon-json，支持Docker仓库"><a href="#修改daemon-json，支持Docker仓库，并重启Docker修改daemon-json，支持Docker仓库" class="headerlink" title="修改daemon.json，支持Docker仓库，并重启Docker修改daemon.json，支持Docker仓库  "></a>修改daemon.json，支持Docker仓库，并重启Docker修改daemon.json，支持Docker仓库  </h2><h2 id="-26"><a href="#-26" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201215931237.png" alt="https://www.notion.soPictures/image-20211201215931237.png">  </h2></li><li><p>设置登录仓库信息</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码 Harbor地址</span><br></pre></td></tr></table></figure></li><li><h2 id="推送镜像到Harbor推送镜像到Harbor"><a href="#推送镜像到Harbor推送镜像到Harbor" class="headerlink" title="推送镜像到Harbor推送镜像到Harbor  "></a>推送镜像到Harbor推送镜像到Harbor  </h2><h2 id="-27"><a href="#-27" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221225196.png" alt="https://www.notion.soPictures/image-20211201221225196.png">  </h2><h2 id="-28"><a href="#-28" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221300055.png" alt="https://www.notion.soPictures/image-20211201221300055.png">  </h2></li></ul><h3 id="8-3-3-从Harbor拉取镜像ls"><a href="#8-3-3-从Harbor拉取镜像ls" class="headerlink" title="8.3.3 从Harbor拉取镜像ls"></a>8.3.3 从Harbor拉取镜像ls</h3><p>跟传统方式一样，不过需要先配置&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>        <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://pee6w651.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>        <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.11.11:80&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>拉取镜像</p><hr><p><img src="https://www.notion.sopictures/image-20211201222450091.png" alt="https://www.notion.soPictures/image-20211201222450091.png"></p><hr><h3 id="8-3-4-Jenkins容器使用宿主机Docker"><a href="#8-3-4-Jenkins容器使用宿主机Docker" class="headerlink" title="8.3.4 Jenkins容器使用宿主机Docker"></a>8.3.4 Jenkins容器使用宿主机Docker</h3><p>构建镜像和发布镜像到harbor都需要使用到docker命令。而在Jenkins容器内部安装Docker官方推荐直接采用宿主机带的Docker即可。</p><p>设置Jenkins容器使用宿主机Docker</p><ul><li><p>设置宿主机docker.sock权限：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root:root /var/run/docker.socksudo chmod o+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure></li><li><p>添加数据卷</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;services:  jenkins:    image: jenkins/jenkins    container_name: jenkins    ports:      - 8080:8080      - 50000:50000    volumes:      - ./data/:/var/jenkins_home/      - /usr/bin/docker:/usr/bin/docker      - /var/run/docker.sock:/var/run/docker.sock      - /etc/docker/daemon.json:/etc/docker/daemon.json</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-5-添加构建操作"><a href="#8-3-5-添加构建操作" class="headerlink" title="8.3.5 添加构建操作"></a>8.3.5 添加构建操作</h3><p>制作自定义镜像</p><hr><p><img src="https://www.notion.sopictures/image-20211229155834500.png" alt="https://www.notion.soPictures/image-20211229155834500.png"></p><hr><h3 id="8-3-6-编写部署脚本"><a href="#8-3-6-编写部署脚本" class="headerlink" title="8.3.6 编写部署脚本"></a>8.3.6 编写部署脚本</h3><p>部署项目需要通过Publish Over SSH插件，让目标服务器执行命令。为了方便一次性实现拉取镜像和启动的命令，推荐采用脚本文件的方式。</p><p>添加脚本文件到目标服务器，再通过Publish Over SSH插件让目标服务器执行脚本即可。</p><ul><li><h2 id="编写脚本文件，添加到目标服务器如图-并设置权限为可执行"><a href="#编写脚本文件，添加到目标服务器如图-并设置权限为可执行" class="headerlink" title="编写脚本文件，添加到目标服务器如图    并设置权限为可执行    "></a>编写脚本文件，添加到目标服务器如图<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">harbor_url=$1harbor_project_name=$2project_name=$3tag=$4port=$5imageName=$harbor_url/$harbor_project_name/$project_name:$tagcontainerId=`docker ps -a | grep $&#123;project_name&#125; | awk &#x27;&#123;print $1&#125;&#x27;`if [ &quot;$containerId&quot; != &quot;&quot; ] ; then    docker stop $containerId    docker rm $containerId    echo &quot;Delete Container Success&quot;fiimageId=`docker images | grep $&#123;project_name&#125; | awk &#x27;&#123;print $3&#125;&#x27;`if [ &quot;$imageId&quot; != &quot;&quot; ] ; then    docker rmi -f $imageId    echo &quot;Delete Image Success&quot;fidocker login -u DevOps -p P@ssw0rd $harbor_urldocker pull $imageNamedocker run -d -p $port:$port --name $project_name $imageNameecho &quot;Start Container Success&quot;echo $project_name</span><br></pre></td></tr></table></figure><br><br>  并设置权限为可执行<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x deploy.sh</span><br></pre></td></tr></table></figure>  </h2><h2 id="-29"><a href="#-29" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211203192047357.png" alt="https://www.notion.soPictures/image-20211203192047357.png">  </h2></li></ul><h3 id="8-3-7-配置构建后操作"><a href="#8-3-7-配置构建后操作" class="headerlink" title="8.3.7 配置构建后操作"></a>8.3.7 配置构建后操作</h3><p>执行脚本文件</p><hr><p><img src="https://www.notion.sopictures/image-20211229155949038.png" alt="https://www.notion.soPictures/image-20211229155949038.png"></p><hr><h3 id="九、Jenkins流水线"><a href="#九、Jenkins流水线" class="headerlink" title="九、Jenkins流水线"></a>九、Jenkins流水线</h3><h3 id="9-1-Jenkins流水线任务介绍"><a href="#9-1-Jenkins流水线任务介绍" class="headerlink" title="9.1 Jenkins流水线任务介绍"></a>9.1 Jenkins流水线任务介绍</h3><p>之前采用Jenkins的自由风格构建的项目，每个步骤流程都要通过不同的方式设置，并且构建过程中整体流程是不可见的，无法确认每个流程花费的时间，并且问题不方便定位问题。</p><p>Jenkins的Pipeline可以让项目的发布整体流程可视化，明确执行的阶段，可以快速的定位问题。并且整个项目的生命周期可以通过一个Jenkinsfile文件管理，而且Jenkinsfile文件是可以放在项目中维护。</p><p>所以Pipeline相对自由风格或者其他的项目风格更容易操作。</p><h3 id="9-2-Jenkins流水线任务"><a href="#9-2-Jenkins流水线任务" class="headerlink" title="9.2 Jenkins流水线任务"></a>9.2 Jenkins流水线任务</h3><h3 id="9-2-1-构建Jenkins流水线任务"><a href="#9-2-1-构建Jenkins流水线任务" class="headerlink" title="9.2.1 构建Jenkins流水线任务"></a>9.2.1 构建Jenkins流水线任务</h3><ul><li><h2 id="构建任务构建Jenkins流水线任务"><a href="#构建任务构建Jenkins流水线任务" class="headerlink" title="构建任务构建Jenkins流水线任务  "></a>构建任务构建Jenkins流水线任务  </h2><h2 id="-30"><a href="#-30" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144429302.png" alt="https://www.notion.soPictures/image-20211202144429302.png">  </h2></li><li><h2 id="生成Groovy脚本Hello-World脚本生成"><a href="#生成Groovy脚本Hello-World脚本生成" class="headerlink" title="生成Groovy脚本Hello World脚本生成  "></a>生成Groovy脚本Hello World脚本生成  </h2><h2 id="-31"><a href="#-31" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144531749.png" alt="https://www.notion.soPictures/image-20211202144531749.png">  </h2></li><li><h2 id="构建后查看视图构建后查看视图"><a href="#构建后查看视图构建后查看视图" class="headerlink" title="构建后查看视图构建后查看视图  "></a>构建后查看视图构建后查看视图  </h2><h2 id="-32"><a href="#-32" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144616117.png" alt="https://www.notion.soPictures/image-20211202144616117.png">  </h2></li></ul><h3 id="9-2-2-Groovy脚本"><a href="#9-2-2-Groovy脚本" class="headerlink" title="9.2.2 Groovy脚本"></a>9.2.2 Groovy脚本</h3><ul><li><p>Groovy脚本基础语法</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 所有脚本命令包含在pipeline&#123;&#125;中pipeline &#123;  // 指定任务在哪个节点执行（Jenkins支持分布式）    agent any    // 配置全局环境，指定变量名=变量值信息    environment&#123;      host = &#x27;192.168.11.11&#x27;    &#125;    // 存放所有任务的合集    stages &#123;      // 单个任务        stage(&#x27;任务1&#x27;) &#123;          // 实现任务的具体流程            steps &#123;                echo &#x27;do something&#x27;            &#125;        &#125;      // 单个任务        stage(&#x27;任务2&#x27;) &#123;          // 实现任务的具体流程            steps &#123;                echo &#x27;do something&#x27;            &#125;        &#125;        // ……    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="编写例子测试配置Grovvy脚本"><a href="#编写例子测试配置Grovvy脚本" class="headerlink" title="编写例子测试配置Grovvy脚本    "></a>编写例子测试配置Grovvy脚本<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                echo &#x27;拉取Git代码&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                echo &#x27;检测代码质量&#x27;            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                echo &#x27;构建代码&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                echo &#x27;制作自定义镜像并发布Harbor&#x27;            &#125;        &#125;        stage(&#x27;基于Harbor部署工程&#x27;) &#123;            steps &#123;                echo &#x27;基于Harbor部署工程&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>  </h2><h2 id="-33"><a href="#-33" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202145155428.png" alt="https://www.notion.soPictures/image-20211202145155428.png">  </h2></li><li><h2 id="查看效果查看效果"><a href="#查看效果查看效果" class="headerlink" title="查看效果查看效果  "></a>查看效果查看效果  </h2><h2 id="-34"><a href="#-34" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202145240166.png" alt="https://www.notion.soPictures/image-20211202145240166.png">  </h2></li></ul><p>Ps：涉及到特定脚本，Jenkins给予了充足的提示，可以自动生成命令</p><p>生成命令位置</p><hr><p><img src="https://www.notion.sopictures/image-20211202145349043.png" alt="https://www.notion.soPictures/image-20211202145349043.png"></p><hr><h3 id="9-2-3-Jenkinsfile实现"><a href="#9-2-3-Jenkinsfile实现" class="headerlink" title="9.2.3 Jenkinsfile实现"></a>9.2.3 Jenkinsfile实现</h3><p>Jenkinsfile方式需要将脚本内容编写到项目中的Jenkinsfile文件中，每次构建会自动拉取项目并且获取项目中Jenkinsfile文件对项目进行构建</p><ul><li><h2 id="配置pipeline配置pipeline"><a href="#配置pipeline配置pipeline" class="headerlink" title="配置pipeline配置pipeline  "></a>配置pipeline配置pipeline  </h2><h2 id="-35"><a href="#-35" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151127254.png" alt="https://www.notion.soPictures/image-20211202151127254.png">  </h2></li><li><h2 id="准备Jenkinsfile准备Jenkinsfile文件"><a href="#准备Jenkinsfile准备Jenkinsfile文件" class="headerlink" title="准备Jenkinsfile准备Jenkinsfile文件  "></a>准备Jenkinsfile准备Jenkinsfile文件  </h2><h2 id="-36"><a href="#-36" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151155145.png" alt="https://www.notion.soPictures/image-20211202151155145.png">  </h2></li><li><h2 id="测试效果测试效果"><a href="#测试效果测试效果" class="headerlink" title="测试效果测试效果  "></a>测试效果测试效果  </h2><h2 id="-37"><a href="#-37" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151225161.png" alt="https://www.notion.soPictures/image-20211202151225161.png">  </h2></li></ul><h3 id="9-3-Jenkins流水线任务实现"><a href="#9-3-Jenkins流水线任务实现" class="headerlink" title="9.3 Jenkins流水线任务实现"></a>9.3 Jenkins流水线任务实现</h3><h3 id="9-3-1-参数化构建"><a href="#9-3-1-参数化构建" class="headerlink" title="9.3.1 参数化构建"></a>9.3.1 参数化构建</h3><p>添加参数化构建，方便选择不的项目版本</p><p>Git参数化构建</p><hr><p><img src="https://www.notion.sopictures/image-20211202191944277.png" alt="https://www.notion.soPictures/image-20211202191944277.png"></p><hr><h3 id="9-3-2-拉取Git代码"><a href="#9-3-2-拉取Git代码" class="headerlink" title="9.3.2 拉取Git代码"></a>9.3.2 拉取Git代码</h3><p>通过流水线语法生成Checkout代码的脚本</p><p>语法生成</p><hr><p><img src="https://www.notion.sopictures/image-20211202192047619.png" alt="https://www.notion.soPictures/image-20211202192047619.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211202192129895.png" alt="https://www.notion.soPictures/image-20211202192129895.png"></p><p>将*&#x2F;master更改为标签</p><p>${tag}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-3-构建代码"><a href="#9-3-3-构建代码" class="headerlink" title="9.3.3 构建代码"></a>9.3.3 构建代码</h3><p>通过脚本执行mvn的构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-4-代码质量检测"><a href="#9-3-4-代码质量检测" class="headerlink" title="9.3.4 代码质量检测"></a>9.3.4 代码质量检测</h3><p>通过脚本执行sonar-scanner命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-5-制作自定义镜像并发布"><a href="#9-3-5-制作自定义镜像并发布" class="headerlink" title="9.3.5 制作自定义镜像并发布"></a>9.3.5 制作自定义镜像并发布</h3><ul><li><p>生成自定义镜像脚本</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment&#123;        harborHost = &#x27;192.168.11.11:80&#x27;        harborRepo = &#x27;repository&#x27;        harborUser = &#x27;DevOps&#x27;        harborPasswd = &#x27;P@ssw0rd&#x27;    &#125;    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;cp ./target/*.jar ./docker/                cd ./docker                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./&#x27;&#x27;&#x27;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;&#x27;&#x27;&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成Publish Over SSH脚本</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment&#123;        harborHost = &#x27;192.168.11.11:80&#x27;        harborRepo = &#x27;repository&#x27;        harborUser = &#x27;DevOps&#x27;        harborPasswd = &#x27;P@ssw0rd&#x27;    &#125;    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;docker        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=7d66af4b39cfe4f52ac0a915d4c9d5c513207098&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;cp ./target/*.jar ./docker/                cd ./docker                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./&#x27;&#x27;&#x27;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;目标服务器拉取镜像并运行&#x27;) &#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;testEnvironment&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &quot;/usr/bin/deploy.sh $harborHost $harborRepo $JOB_NAME $tag $port &quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Ps：由于采用变量，记得使用双引号</p><h3 id="9-4-Jenkins流水线整合钉钉"><a href="#9-4-Jenkins流水线整合钉钉" class="headerlink" title="9.4 Jenkins流水线整合钉钉"></a>9.4 Jenkins流水线整合钉钉</h3><p>在程序部署成功后，可以通过钉钉的机器人及时向群众发送部署的最终结果通知</p><ul><li><h2 id="安装插件安装插件"><a href="#安装插件安装插件" class="headerlink" title="安装插件安装插件  "></a>安装插件安装插件  </h2><h2 id="-38"><a href="#-38" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209151549412.png" alt="https://www.notion.soPictures/image-20211209151549412.png">  </h2></li><li><h2 id="钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人"><a href="#钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人" class="headerlink" title="钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人  "></a>钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人  </h2><h2 id="-39"><a href="#-39" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152217433.png" alt="https://www.notion.soPictures/image-20211209152217433.png">  </h2><h2 id="-40"><a href="#-40" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152252050.png" alt="https://www.notion.soPictures/image-20211209152252050.png">  </h2><h2 id="-41"><a href="#-41" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152403312.png" alt="https://www.notion.soPictures/image-20211209152403312.png">  </h2><p>  最终或获取到Webhook信息</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://oapi.dingtalk.com/robot/send?access_token=kej4ehkj34gjhg34jh5bh5jb34hj53b4</span><br></pre></td></tr></table></figure></li><li><h2 id="系统配置添加钉钉通知配置钉钉通知"><a href="#系统配置添加钉钉通知配置钉钉通知" class="headerlink" title="系统配置添加钉钉通知配置钉钉通知  "></a>系统配置添加钉钉通知配置钉钉通知  </h2><h2 id="-42"><a href="#-42" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209162923440.png" alt="https://www.notion.soPictures/image-20211209162923440.png">  </h2></li><li><p>任务中追加流水线配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment &#123;        sonarLogin = &#x27;2bab7bf7d5af25e2c2ca2f178af2c3c55c64d5d8&#x27;        harborUser = &#x27;admin&#x27;        harborPassword = &#x27;Harbor12345&#x27;        harborHost = &#x27;192.168.11.12:8888&#x27;        harborRepo = &#x27;repository&#x27;    &#125;    stages &#123;        stage(&#x27;拉取Git代码&#x27;)&#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$tag&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/lsx.git&#x27;]]])            &#125;        &#125;        stage(&#x27;Maven构建代码&#x27;)&#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;SonarQube检测代码&#x27;)&#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=$&#123;sonarLogin&#125;&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像&#x27;)&#123;            steps &#123;                sh &#x27;&#x27;&#x27;cd docker                mv ../target/*.jar ./                docker build -t $&#123;JOB_NAME&#125;:$tag .                &#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;推送自定义镜像&#x27;)&#123;            steps &#123;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPassword&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$tag $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;通知目标服务器&#x27;)&#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;centos-docker&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &quot;/usr/bin/deploy.sh $harborHost $harborRepo $JOB_NAME $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;    &#125;    post &#123;        success &#123;            dingtalk (                robot: &#x27;Jenkins-DingDing&#x27;,                type:&#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 成功构建:$&#123;JOB_NAME&#125;项目!\n- 版本:$&#123;tag&#125;\n- 持续时间:$&#123;currentBuild.durationString&#125;\n- 任务:#$&#123;JOB_NAME&#125;&quot;]            )        &#125;        failure &#123;            dingtalk (                robot: &#x27;Jenkins-DingDing&#x27;,                type:&#x27;MARKDOWN&#x27;,                title: &quot;fail: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 失败构建:$&#123;JOB_NAME&#125;项目!\n- 版本:$&#123;tag&#125;\n- 持续时间:$&#123;currentBuild.durationString&#125;\n- 任务:#$&#123;JOB_NAME&#125;&quot;]            )        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="查看效果钉钉通知效果"><a href="#查看效果钉钉通知效果" class="headerlink" title="查看效果钉钉通知效果  "></a>查看效果钉钉通知效果  </h2><h2 id="-43"><a href="#-43" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209163021396.png" alt="https://www.notion.soPictures/image-20211209163021396.png">  </h2></li></ul><p>###十、Kubernetes编排工具</p><h3 id="10-1-Kubernetes介绍"><a href="#10-1-Kubernetes介绍" class="headerlink" title="10.1 Kubernetes介绍"></a>10.1 Kubernetes介绍</h3><p>Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。</p><p>Kubernetes主要能帮助我们完成：</p><ul><li><p>服务发现和负载均衡</p><p>  Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p>存储编排</p><p>  Kubernetes 允许你自动挂载你选择的存储系统，比如本地存储，类似Docker的数据卷。</p></li><li><p>自动部署和回滚</p><p>  你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。Kubernetes 会自动帮你根据情况部署创建新容器，并删除现有容器给新容器提供资源。</p></li><li><p>自动完成装箱计算</p><p>  Kubernetes 允许你设置每个容器的资源，比如CPU和内存。</p></li><li><p>自我修复</p><p>  Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的容器，并运行状况检查的容器。</p></li><li><p>秘钥与配置管理</p><p>  Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h3 id="10-2-Kubernetes架构"><a href="#10-2-Kubernetes架构" class="headerlink" title="10.2 Kubernetes架构"></a>10.2 Kubernetes架构</h3><p>Kubernetes 搭建需要至少两个节点，一个Master负责管理，一个Slave搭建在工作服务器上负责分配。</p><p>kubernetes架构</p><hr><p><img src="https://www.notion.sopictures/image-20211210114507638.png" alt="https://www.notion.soPictures/image-20211210114507638.png"></p><hr><p>从图中可以看到各个组件的基本功能：</p><ul><li>API Server：作为K8s通讯的核心组件，K8s内部交互以及接收发送指令的组件。</li><li>controller-manager：作为K8s的核心组件，主要做资源调度，根据集群情况分配资源</li><li>etcd：一个key-value的数据库，存储存储集群的状态信息</li><li>scheduler：负责调度每个工作节点</li><li>cloud-controller-manager：负责调度其他云服务产品</li><li>kubelet：管理Pods上面的容器。</li><li>kube-proxy：负责处理其他Slave或客户端的请求。</li><li>Pod：可以理解为就是运行的容器</li></ul><h3 id="10-3-Kubernetes安装"><a href="#10-3-Kubernetes安装" class="headerlink" title="10.3 Kubernetes安装"></a>10.3 Kubernetes安装</h3><p>这里会采用<a href="https://kuboard.cn/%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85K8s%EF%BC%8C%E5%AE%89%E8%A3%85%E5%8D%95Master%E8%8A%82%E7%82%B9">https://kuboard.cn/提供的方式安装K8s，安装单Master节点</a></p><ul><li>要求使用Centos7.8版本：<a href="https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso">https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso</a></li><li>至少2台 <strong>2核4G</strong> 的服务器</li></ul><p>安装流程</p><p>安装流程</p><hr><p><img src="https://www.notion.sopictures/image-20211210190653687.png" alt="https://www.notion.soPictures/image-20211210190653687.png"></p><hr><p>准备好服务器后开始安装</p><ul><li><p>重新设置hostname，不允许为localhost</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 修改 hostname，名字不允许使用下划线、小数点、大写字母，不能叫masterhostnamectl set-hostname your-new-host-name# 查看修改结果hostnamectl status# 设置 hostname 解析echo &quot;127.0.0.1   $(hostname)&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>要求2台服务之间可以相互通讯</p></li><li><p>安装软件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 阿里云 docker hub 镜像export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.comcurl -sSL https://kuboard.cn/install-script/v1.19.x/install_kubelet.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure></li></ul><p>首先初始化Master节点</p><blockquote><p>关于初始化时用到的环境变量</p><ul><li><strong>APISERVER_NAME</strong> 不能是 master 的 hostname</li><li><strong>APISERVER_NAME</strong> 必须全为小写字母、数字、小数点，不能包含减号</li><li><strong>POD_SUBNET</strong> 所使用的网段不能与 <em><strong>master节点&#x2F;worker节点</strong></em> 所在的网段重叠。该字段的取值为一个 <a href="https://kuboard.cn/glossary/cidr.html">CIDR</a> 值，如果您对 CIDR 这个概念还不熟悉，请仍然执行 export POD_SUBNET&#x3D;10.100.0.0&#x2F;16 命令，不做修改</li></ul></blockquote><ul><li><p>设置ip，域名，网段并执行初始化操作</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行# 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令export MASTER_IP=192.168.11.32# 替换 apiserver.demo 为 您想要的 dnsNameexport APISERVER_NAME=apiserver.demo# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中export POD_SUBNET=10.100.0.1/16echo &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hostscurl -sSL https://kuboard.cn/install-script/v1.19.x/init_master.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure></li><li><p>检查Master启动状态</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态watch kubectl get pod -n kube-system -o wide# 查看 master 节点初始化结果kubectl get nodes -o wide</span><br></pre></td></tr></table></figure></li></ul><p><code>Ps：如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;EOFmkdir /usr/share/oci-umount/oci-umount.d -pmkdir /run/flannel/cat &lt;&lt;EOF&gt; /run/flannel/subnet.envFLANNEL_NETWORK=172.100.0.0/16FLANNEL_SUBNET=172.100.1.0/24FLANNEL_MTU=1450FLANNEL_IPMASQ=trueEOFkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>安装网络服务插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export POD_SUBNET=10.100.0.0/16kubectl apply -f https://kuboard.cn/install-script/v1.22.x/calico-operator.yamlwget https://kuboard.cn/install-script/v1.22.x/calico-custom-resources.yamlsed -i &quot;s#192.168.0.0/16#$&#123;POD_SUBNET&#125;#&quot; calico-custom-resources.yamlkubectl apply -f calico-custom-resources.yaml</span><br></pre></td></tr></table></figure><p>初始化worker节点</p><ul><li><h2 id="获取Join命令参数，在Master节点执行获取命令"><a href="#获取Join命令参数，在Master节点执行获取命令" class="headerlink" title="获取Join命令参数，在Master节点执行获取命令    "></a>获取Join命令参数，在Master节点执行获取命令<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>  </h2><h2 id="-44"><a href="#-44" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213183025291.png" alt="https://www.notion.soPictures/image-20211213183025291.png">  </h2></li><li><p>在worker节点初始化</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 worker 节点执行# 替换 x.x.x.x 为 master 节点的内网 IPexport MASTER_IP=192.168.11.32# 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAMEexport APISERVER_NAME=apiserver.demoecho &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hosts# 替换为 master 节点上 kubeadm token create 命令的输出kubeadm join apiserver.demo:6443 --token vwfilu.3nhndohc5gn1jv9k     --discovery-token-ca-cert-hash sha256:22ff15cabfe87ab48a7db39b3bbf986fee92ec92eb8efc7fe9b0abe2175ff0c2</span><br></pre></td></tr></table></figure></li></ul><p>检查最终运行效果</p><ul><li><p>在 master 节点上执行</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行kubectl get nodes -o wide</span><br></pre></td></tr></table></figure></li></ul><p><code>Ps：如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;EOFmkdir /usr/share/oci-umount/oci-umount.d -pmkdir /run/flannel/cat &lt;&lt;EOF&gt; /run/flannel/subnet.envFLANNEL_NETWORK=172.100.0.0/16FLANNEL_SUBNET=172.100.1.0/24FLANNEL_MTU=1450FLANNEL_IPMASQ=trueEOFkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li><h2 id="输出结果如下所示：搭建成功效果"><a href="#输出结果如下所示：搭建成功效果" class="headerlink" title="输出结果如下所示：搭建成功效果    "></a>输出结果如下所示：搭建成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8smaster ~]# kubectl get nodes</span><br></pre></td></tr></table></figure>  </h2><h2 id="-45"><a href="#-45" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211210184851810.png" alt="https://www.notion.soPictures/image-20211210184851810.png">  </h2></li></ul><p>安装Kuboard管理K8s集群</p><ul><li><p>安装Kuboard</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml# 您也可以使用下面的指令，唯一的区别是，该指令使用华为云的镜像仓库替代 docker hub 分发 Kuboard 所需要的镜像# kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml</span><br></pre></td></tr></table></figure></li><li><h2 id="查看启动情况查看效果"><a href="#查看启动情况查看效果" class="headerlink" title="查看启动情况查看效果    "></a>查看启动情况查看效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch kubectl get pods -n kuboard</span><br></pre></td></tr></table></figure>  </h2><h2 id="-46"><a href="#-46" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184701784.png" alt="https://www.notion.soPictures/image-20211213184701784.png">  </h2></li><li><h2 id="在浏览器中打开链接-http-your-node-ip-address-30080首页"><a href="#在浏览器中打开链接-http-your-node-ip-address-30080首页" class="headerlink" title="在浏览器中打开链接 http://your-node-ip-address:30080首页  "></a>在浏览器中打开链接 <a href="http://your-node-ip-address:30080首页">http://your-node-ip-address:30080首页</a>  </h2><h2 id="-47"><a href="#-47" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184742709.png" alt="https://www.notion.soPictures/image-20211213184742709.png">  </h2></li><li><h2 id="输入初始用户名和密码，并登录首页效果-用户名：-admin-密码：-Kuboard123"><a href="#输入初始用户名和密码，并登录首页效果-用户名：-admin-密码：-Kuboard123" class="headerlink" title="输入初始用户名和密码，并登录首页效果  - 用户名： admin  - 密码： Kuboard123  "></a>输入初始用户名和密码，并登录首页效果<br>  - 用户名： <code>admin</code><br>  - 密码： <code>Kuboard123</code>  </h2><h2 id="-48"><a href="#-48" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184840120.png" alt="https://www.notion.soPictures/image-20211213184840120.png">  </h2></li></ul><h3 id="10-4-Kubernetes操作"><a href="#10-4-Kubernetes操作" class="headerlink" title="10.4 Kubernetes操作"></a>10.4 Kubernetes操作</h3><p>首先我们要了解Kubernetes在运行我们的资源时，关联到了哪些内容</p><ul><li>资源的构建方式：<ul><li>采用kubectl的命令方式</li><li>yaml文件方式</li></ul></li></ul><h3 id="10-4-1-Namespace"><a href="#10-4-1-Namespace" class="headerlink" title="10.4.1 Namespace"></a>10.4.1 Namespace</h3><ul><li><p>命名空间：主要是为了对Kubernetes中运行的资源进行过隔离， 但是网络是互通的，类似Docker的容器，可以将多个资源配置到一个NameSpace中。而NameSpace可以对不同环境进行资源隔离，默认情况下Kubernetes提供了default命名空间，在构建资源时，如果不指定资源，默认采用default资源。 命令方式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查看现有的全部命名空间kubectl get ns# 构建命名空间kubectl create ns 命名空间名称# 删除现有命名空间， 并且会删除空间下的全部资源kubectl delete ns 命名空间名称</span><br></pre></td></tr></table></figure><p>  yaml文件方式：（构建资源时，设置命名空间）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Namespacemetadata:  name:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-2-Pod"><a href="#10-4-2-Pod" class="headerlink" title="10.4.2 Pod"></a>10.4.2 Pod</h3><ul><li>Pod：Kubernetes运行的一组容器，Pod是Kubernetes的最小单位，但是对于Docker而然，Pod中会运行多个Docker容器<ul><li><p>命令方式：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有运行的podkubectl get pods -A# 查看指定Namespace下的Podkubectl get pod [-n 命名空间]  #（默认default）# 创建Podkubectl run pod名称 --image=镜像名称# 查看Pod详细信息kubectl describe pod pod名称# 删除podkubectl delete pod pod名称 [-n 命名空间]  #（默认default）# 查看pod输出的日志kubectl logs -f pod名称# 进去pod容器内部kubectl exec -it pod名称 -- bash# 查看kubernetes给Pod分配的ip信息，并且通过ip和容器的端口，可以直接访问kubectl get pod -owide</span></span><br></pre></td></tr></table></figure></li><li><p>yaml方式（推荐）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Podmetadata:  labels:    run:</span> <span class="string">运行的pod名称</span>  <span class="attr">name:</span> <span class="string">pod名称</span>  <span class="attr">namespace:</span> <span class="string">命名空间spec:</span>  <span class="attr">containers:  - image:</span> <span class="string">镜像名称</span>    <span class="attr">name:</span> <span class="string">容器名称#</span> <span class="string">启动Pod：kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">yaml文件名称#</span> <span class="string">删除Pod：kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">yaml文件名称</span></span><br></pre></td></tr></table></figure></li><li><h2 id="Pod中运行多个容器Kuboard效果-启动后可以查看到"><a href="#Pod中运行多个容器Kuboard效果-启动后可以查看到" class="headerlink" title="Pod中运行多个容器Kuboard效果    启动后可以查看到  "></a>Pod中运行多个容器Kuboard效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1kind: Podmetadata:  labels:    run: 运行的pod名称  name: pod名称  namespace: 命名空间spec:  containers:  - image: 镜像名称    name: 容器名称  - image: 镜像名称    name: 容器名称…………</span><br></pre></td></tr></table></figure><br><br>  启动后可以查看到  </h2><h2 id="-49"><a href="#-49" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104203155749.png" alt="https://www.notion.soPictures/image-20220104203155749.png">  </h2></li></ul></li></ul><h3 id="10-4-3-Deployment"><a href="#10-4-3-Deployment" class="headerlink" title="10.4.3 Deployment"></a>10.4.3 Deployment</h3><p>部署时，可以通过Deployment管理和编排Pod</p><p>Deployment部署实现</p><ul><li><p>命令方式</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 基于Deployment启动容器kubectl create deployment deployment名称 --image=镜像名称# 用deployment启动的容器会在被删除后自动再次创建，达到故障漂移的效果# 需要使用deploy的方式删除deploy# 查看现在的deploymentkubectl get deployment# 删除deploymentkubectl delete deployment deployment名称# 基于Deployment启动容器并设置Pod集群数kubectl create deployment deployment名称 --image=镜像名称 --replicas 集群个数</span><br></pre></td></tr></table></figure></li><li><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">配置文件方式</a></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx       image: nginx       ports:       - containerPort: 80</span><br></pre></td></tr></table></figure><p>  正常使用kubectl运行yaml即可</p></li></ul><p>弹性伸缩功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 基于scale实现弹性伸缩kubectl scale deploy/Deployment名称 --replicas 集群个数# 或者修改yaml文件kubectl edit deploy Deployment名称</span><br></pre></td></tr></table></figure><p>图形化页面修改</p><hr><p><img src="https://www.notion.sopictures/image-20220104210823057.png" alt="https://www.notion.soPictures/image-20220104210823057.png"></p><hr><p>灰度发布</p><p>Deploy可以在部署新版本数据时，成功启动一个pod，才会下线一个老版本的Pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/Deployment名称 容器名=镜像:版本</span><br></pre></td></tr></table></figure><h3 id="10-4-4-Service"><a href="#10-4-4-Service" class="headerlink" title="10.4.4 Service"></a>10.4.4 Service</h3><p>可以将多个Pod对外暴露一个Service，让客户端可以通过Service访问到这一组Pod，并且可以实现负载均衡</p><p>ClusterIP方式：</p><p>ClusterIP是集群内部Pod之间的访问方式</p><ul><li><h2 id="命令实现效果kubectl-get-service在服务容器内执行-之后通过kubectl-get-service查看Service提供的ip，即可访问"><a href="#命令实现效果kubectl-get-service在服务容器内执行-之后通过kubectl-get-service查看Service提供的ip，即可访问" class="headerlink" title="命令实现效果kubectl get service在服务容器内执行    之后通过kubectl get service查看Service提供的ip，即可访问  "></a>命令实现效果kubectl get service在服务容器内执行<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口</span><br></pre></td></tr></table></figure><br><br>  之后通过<code>kubectl get service</code>查看Service提供的ip，即可访问  </h2><h2 id="-50"><a href="#-50" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104214659229.png" alt="https://www.notion.soPictures/image-20220104214659229.png">  </h2><h2 id="也可以通过Deployment名称-namespace名称-svc作为域名访问"><a href="#也可以通过Deployment名称-namespace名称-svc作为域名访问" class="headerlink" title="  也可以通过Deployment名称.namespace名称.svc作为域名访问  "></a>  也可以通过<code>Deployment名称.namespace名称.svc</code>作为域名访问  </h2><h2 id="-51"><a href="#-51" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104215030265.png" alt="https://www.notion.soPictures/image-20220104215030265.png">  </h2></li></ul><p>NodePort方式</p><p>ClusterIP的方式只能在Pod内部实现访问，但是一般需要对外暴露网关，所以需要NodePort的方式Pod外暴露访问</p><ul><li><h2 id="命令实现方式查看Service效果"><a href="#命令实现方式查看Service效果" class="headerlink" title="命令实现方式查看Service效果    "></a>命令实现方式查看Service效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口 --type=NodePort</span><br></pre></td></tr></table></figure>  </h2><h2 id="-52"><a href="#-52" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104222750733.png" alt="https://www.notion.soPictures/image-20220104222750733.png">  </h2><h2 id="-53"><a href="#-53" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104222819455.png" alt="https://www.notion.soPictures/image-20220104222819455.png">  </h2></li></ul><p>Service也可以通过yaml文件实现</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Servicemetadata:  labels    app: nginx  name: nginx  spec:    selector:      app: nginx    ports:    - port: 8888     protocol: TCP     targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>通过apply启动就也可以创建Service</p><p>测试效果-Deployment部署，通过Service暴露</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginx-deploymentspec:  replicas: 2  selector:    matchLabels:      app: nginx-deployment  template:    metadata:      labels:        app: nginx-deployment    spec:      containers:      - name: nginx-deployment        image: nginx        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  labels:    app: nginx-service  name: nginx-servicespec:  selector:    app: nginx-deployment  ports:  - port: 8888    protocol: TCP    targetPort: 80  type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>可以查看到暴露的信息</p><p>Service信息</p><hr><p><img src="https://www.notion.sopictures/image-20220105205334996.png" alt="https://www.notion.soPictures/image-20220105205334996.png"></p><hr><h3 id="10-4-5-Ingress"><a href="#10-4-5-Ingress" class="headerlink" title="10.4.5 Ingress"></a>10.4.5 Ingress</h3><p>Kubernetes推荐将Ingress作为所有Service的入口，提供统一的入口，避免多个服务之间需要记录大量的IP或者域名，毕竟IP可能改变，服务太多域名记录不方便。</p><p>Ingress底层其实就是一个Nginx， 可以在Kuboard上直接点击安装</p><p>Kuboard安装</p><hr><p><img src="https://www.notion.sopictures/image-20220105153343642.png" alt="https://www.notion.soPictures/image-20220105153343642.png"></p><hr><p><img src="https://www.notion.sopictures/image-20220105153416367.png" alt="https://www.notion.soPictures/image-20220105153416367.png"></p><hr><p>因为副本数默认为1，但是k8s整体集群就2个节点，所以显示下面即为安装成功</p><p>安装成功</p><hr><p><img src="https://www.notion.sopictures/image-20220105153502619.png" alt="https://www.notion.soPictures/image-20220105153502619.png"></p><hr><p>可以将Ingress接收到的请求转发到不同的Service中。</p><p>推荐使用yaml文件方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: nginx-ingressspec:  ingressClassName: ingress  rules:  - host: nginx.mashibing.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: nginx-service            port:              number:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>启动时问题</p><hr><p><img src="https://www.notion.sopictures/image-20220105203819715.png" alt="https://www.notion.soPictures/image-20220105203819715.png"></p><hr><p>Kuboard安装的Ingress有admission的校验配置，需要先删除配置再启动</p><p>找到指定的ingress的校验信息，删除即可</p><p>删除信息</p><hr><p><img src="https://www.notion.sopictures/image-20220105204434044.png" alt="https://www.notion.soPictures/image-20220105204434044.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查看校验webhook的配置kubectl get -A ValidatingWebhookConfiguration# 删除指定的校验kubectl delete ValidatingWebhookConfiguration ingress-nginx-admission-my-ingress-controller</span><br></pre></td></tr></table></figure><p>配置本地hosts文件</p><p>配置hosts</p><hr><p><img src="https://www.notion.sopictures/image-20220105204921272.png" alt="https://www.notion.soPictures/image-20220105204921272.png"></p><hr><p>记下来既可以访问在Service中暴露的Nginx信息</p><p>服通过Ingress访问</p><hr><p><img src="https://www.notion.sopictures/image-20220105205407393.png" alt="https://www.notion.soPictures/image-20220105205407393.png"></p><hr><h3 id="10-5-Jenkins集成Kubernetes"><a href="#10-5-Jenkins集成Kubernetes" class="headerlink" title="10.5 Jenkins集成Kubernetes"></a>10.5 Jenkins集成Kubernetes</h3><h3 id="10-5-1-准备部署的yml文件"><a href="#10-5-1-准备部署的yml文件" class="headerlink" title="10.5.1 准备部署的yml文件"></a>10.5.1 准备部署的yml文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  namespace: test  name: pipeline  labels:    app: pipelinespec:  replicas: 2  selector:    matchLabels:      app: pipeline  template:    metadata:      labels:        app: pipeline    spec:      containers:      - name: pipeline        image: 192.168.11.102:80/repo/pipeline:v4.0.0        imagePullPolicy: Always        ports:        - containerPort: 8080---apiVersion: v1kind: Servicemetadata:  namespace: test  labels:    app: pipeline  name: pipelinespec:  selector:    app: pipeline  ports:  - port: 8081    targetPort: 8080  type: NodePort---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  namespace: test  name: pipelinespec:  ingressClassName: ingress  rules:  - host: mashibing.pipeline.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: pipeline            port:              number: 8081</span><br></pre></td></tr></table></figure><h3 id="10-5-2-Harbor私服配置"><a href="#10-5-2-Harbor私服配置" class="headerlink" title="10.5.2 Harbor私服配置"></a>10.5.2 Harbor私服配置</h3><p>在尝试用kubernetes的yml文件启动pipeline服务时，会出现Kubernetes无法拉取镜像的问题，这里需要在kubernetes所在的Linux中配置Harbor服务信息，并且保证Kubernetes可以拉取Harbor上的镜像</p><ul><li><h2 id="设置Master和Worker的私服地址信息设置Harbor私服地址"><a href="#设置Master和Worker的私服地址信息设置Harbor私服地址" class="headerlink" title="设置Master和Worker的私服地址信息设置Harbor私服地址  "></a>设置Master和Worker的私服地址信息设置Harbor私服地址  </h2><h2 id="-54"><a href="#-54" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642498962716.png" alt="https://www.notion.soPictures/1642498962716.png">  </h2></li><li><h2 id="在Kuboard上设置私服密文信息设置密文并测试测试效果"><a href="#在Kuboard上设置私服密文信息设置密文并测试测试效果" class="headerlink" title="在Kuboard上设置私服密文信息设置密文并测试测试效果  "></a>在Kuboard上设置私服密文信息设置密文并测试测试效果  </h2><h2 id="-55"><a href="#-55" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642498994935.png" alt="https://www.notion.soPictures/1642498994935.png">  </h2><h2 id="按照复制指令的位置测试认证，效果如下"><a href="#按照复制指令的位置测试认证，效果如下" class="headerlink" title="  按照复制指令的位置测试认证，效果如下  "></a>  按照复制指令的位置测试认证，效果如下  </h2><h2 id="-56"><a href="#-56" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499172789.png" alt="https://www.notion.soPictures/1642499172789.png">  </h2></li></ul><h3 id="10-5-3-测试使用效果"><a href="#10-5-3-测试使用效果" class="headerlink" title="10.5.3 测试使用效果"></a>10.5.3 测试使用效果</h3><p>执行kubectl命令，基于yml启动服务，并且基于部署后服务的提示信息以及Ingress的设置，直接访问</p><p><img src="https://www.notion.sopictures/1642499368121.png" alt="https://www.notion.soPictures/1642499368121.png"></p><hr><p><img src="https://www.notion.sopictures/1642499788199.png" alt="https://www.notion.soPictures/1642499788199.png"></p><hr><h3 id="10-5-3-Jenkins远程调用"><a href="#10-5-3-Jenkins远程调用" class="headerlink" title="10.5.3 Jenkins远程调用"></a>10.5.3 Jenkins远程调用</h3><ul><li><h2 id="将pipeline-yml配置到Gitlab中配置yml文件"><a href="#将pipeline-yml配置到Gitlab中配置yml文件" class="headerlink" title="将pipeline.yml配置到Gitlab中配置yml文件  "></a>将pipeline.yml配置到Gitlab中配置yml文件  </h2><h2 id="-57"><a href="#-57" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499885324.png" alt="https://www.notion.soPictures/1642499885324.png">  </h2></li><li><h2 id="配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器"><a href="#配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器" class="headerlink" title="配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器  "></a>配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器  </h2><h2 id="-58"><a href="#-58" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499992148.png" alt="https://www.notion.soPictures/1642499992148.png">  </h2></li><li><h2 id="修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本"><a href="#修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本" class="headerlink" title="修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本  "></a>修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本  </h2><h2 id="-59"><a href="#-59" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500061153.png" alt="https://www.notion.soPictures/1642500061153.png">  </h2><h2 id="-60"><a href="#-60" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500102996.png" alt="https://www.notion.soPictures/1642500102996.png">  </h2></li><li><h2 id="设置Jenkins无密码登录k8s-master远程执行命令无需密码-将Jenkins中公钥信息复制到k8s-master的-ssh-authorized-keysz中，保证远程连接无密码"><a href="#设置Jenkins无密码登录k8s-master远程执行命令无需密码-将Jenkins中公钥信息复制到k8s-master的-ssh-authorized-keysz中，保证远程连接无密码" class="headerlink" title="设置Jenkins无密码登录k8s-master远程执行命令无需密码  将Jenkins中公钥信息复制到k8s-master的~&#x2F;.ssh&#x2F;authorized_keysz中，保证远程连接无密码  "></a>设置Jenkins无密码登录k8s-master远程执行命令无需密码<br><br>  将Jenkins中公钥信息复制到k8s-master的~&#x2F;.ssh&#x2F;authorized_keysz中，保证远程连接无密码  </h2><h2 id="-61"><a href="#-61" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500239406.png" alt="https://www.notion.soPictures/1642500239406.png">  </h2></li><li><h2 id="设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile"><a href="#设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile" class="headerlink" title="设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile  "></a>设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile  </h2><h2 id="-62"><a href="#-62" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500378788.png" alt="https://www.notion.soPictures/1642500378788.png">  </h2></li><li><h2 id="执行查看效果执行流水线"><a href="#执行查看效果执行流水线" class="headerlink" title="执行查看效果执行流水线  "></a>执行查看效果执行流水线  </h2><h2 id="-63"><a href="#-63" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500413802.png" alt="https://www.notion.soPictures/1642500413802.png">  </h2><p>  可以查看到yml文件是由变化的， 这样k8s就会重新加载</p></li><li><h2 id="查看效果效果"><a href="#查看效果效果" class="headerlink" title="查看效果效果  "></a>查看效果效果  </h2><h2 id="-64"><a href="#-64" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500474036.png" alt="https://www.notion.soPictures/1642500474036.png">  </h2></li></ul><p>Ps：这种方式更适应与CD操作，将项目将基于某个版本部署到指定的目标服务器</p><h3 id="10-6-基于GitLab的WebHooks"><a href="#10-6-基于GitLab的WebHooks" class="headerlink" title="10.6 基于GitLab的WebHooks"></a>10.6 基于GitLab的WebHooks</h3><p>这里要实现自动化的一个CI操作，也就是开发人员Push代码到Git仓库后，Jenkins会自动的构建项目，将最新的提交点代码构建并进行打包部署，这里区别去上述的CD操作，CD操作需要基于某个版本进行部署，而这里每次都是将最新的提交点集成到主干上并测试。</p><h3 id="10-6-1-WebHooks通知"><a href="#10-6-1-WebHooks通知" class="headerlink" title="10.6.1 WebHooks通知"></a>10.6.1 WebHooks通知</h3><p>开启Jenkins的自动构建</p><p>构建触发器</p><hr><p><img src="https://www.notion.sopictures/1642500817131.png" alt="https://www.notion.soPictures/1642500817131.png"></p><hr><p>设置Gitlab的Webhooks</p><p>设置Gitlab的Webhooks</p><hr><p><img src="https://www.notion.sopictures/1642500933316.png" alt="https://www.notion.soPictures/1642500933316.png"></p><hr><p>需要关闭Jenkins的Gitlab认证</p><p>关闭Jenkins的Gitlab认证</p><hr><p><img src="https://www.notion.sopictures/1642501016474.png" alt="https://www.notion.soPictures/1642501016474.png"></p><hr><p>再次测试Gitlab</p><p>再次测试</p><hr><p><img src="https://www.notion.sopictures/1642501065243.png" alt="https://www.notion.soPictures/1642501065243.png"></p><hr><h3 id="10-6-2-修改配置"><a href="#10-6-2-修改配置" class="headerlink" title="10.6.2 修改配置"></a>10.6.2 修改配置</h3><p>修改Jenkinsfile实现基于最新提交点实现持续集成效果，将之前引用${tag}的全部去掉</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的脚本命令都放在pipeline中pipeline&#123;    // 指定任务再哪个集群节点中执行    agent any    // 声明全局变量，方便后面使用    environment &#123;        harborUser = &#x27;admin&#x27;        harborPasswd = &#x27;Harbor12345&#x27;        harborAddress = &#x27;192.168.11.102:80&#x27;        harborRepo = &#x27;repo&#x27;    &#125;    stages &#123;        stage(&#x27;拉取git仓库代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://192.168.11.101:8929/root/mytest.git&#x27;]]])            &#125;        &#125;        stage(&#x27;通过maven构建项目&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;通过SonarQube做代码质量检测&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.source=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=./target/ -Dsonar.login=40306ae8ea69a4792df2ceb4d9d25fe8a6ab1701&#x27;            &#125;        &#125;        stage(&#x27;通过Docker制作自定义镜像&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;mv ./target/*.jar ./docker/                docker build -t $&#123;JOB_NAME&#125;:latest ./docker/&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;将自定义镜像推送到Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;                docker tag $&#123;JOB_NAME&#125;:latest  $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest                docker push $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest &#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;将yml文件传到k8s-master上&#x27;) &#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;k8s&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &#x27;&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;pipeline.yml&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;        stage(&#x27;远程执行k8s-master的kubectl命令&#x27;) &#123;            steps &#123;               sh &#x27;&#x27;&#x27;ssh root@192.168.11.201 kubectl apply -f /usr/local/k8s/pipeline.yml                ssh root@192.168.11.201 kubectl rollout restart deployment pipeline -n test&#x27;&#x27;&#x27;            &#125;        &#125;    &#125;    post &#123;        success &#123;            dingtalk(                robot: &#x27;Jenkins-DingDing&#x27;,                type: &#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 成功构建：$&#123;JOB_NAME&#125;! \n- 版本：latest \n- 持续时间：$&#123;currentBuild.durationString&#125;&quot; ]            )        &#125;        failure &#123;            dingtalk(                robot: &#x27;Jenkins-DingDing&#x27;,                type: &#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 构建失败：$&#123;JOB_NAME&#125;! \n- 版本：latest \n- 持续时间：$&#123;currentBuild.durationString&#125;&quot; ]            )        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>修改pipeline.yml，更改镜像版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  namespace: test  name: pipeline  labels:    app: pipelinespec:  replicas: 2  selector:    matchLabels:      app: pipeline  template:    metadata:      labels:        app: pipeline    spec:      containers:      - name: pipeline        image: 192.168.11.102:80/repo/pipeline:latest   # 这里        imagePullPolicy: Always        ports:        - containerPort: 8080# 省略其他内容…………</span><br></pre></td></tr></table></figure><h3 id="10-6-3-滚动更新"><a href="#10-6-3-滚动更新" class="headerlink" title="10.6.3 滚动更新"></a>10.6.3 滚动更新</h3><p>因为pipeline没有改变时，每次不会重新加载，这样会导致Pod中的容器不会动态更新，这里需要使用kubectl的rollout restart命令滚动更新</p><p>设置Jenkinsfle</p><hr><p><img src="https://www.notion.sopictures/1642501521065.png" alt="https://www.notion.soPictures/1642501521065.png"></p><hr><p><img src="https://www.notion.sopictures/1642501549176.png" alt="https://www.notion.soPictures/1642501549176.png"></p><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2043.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2044.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2045.png" alt="Untitled"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
