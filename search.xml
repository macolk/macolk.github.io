<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go 语言基础之变量和常量</title>
      <link href="/posts/4a17b001.html"/>
      <url>/posts/4a17b001.html</url>
      
        <content type="html"><![CDATA[<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。<br>Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。Go语言中有25个关键字;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      func         interface    select</span><br><span class="line"><span class="keyword">case</span>         defer        go           map          struct</span><br><span class="line">chan         <span class="keyword">else</span>         goto         package      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        fallthrough  <span class="keyword">if</span>           range        type</span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Constants</span>:    <span class="literal">true</span>  <span class="literal">false</span>  iota  nil</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Types</span>:    int  int8  int16  int32  int64  </span><br><span class="line">              uint  uint8  uint16  uint32  uint64  uintptr</span><br><span class="line">              float32  float64  complex128  complex64</span><br><span class="line">              bool  byte  rune  string  error</span><br><span class="line"></span><br><span class="line"><span class="title class_">Functions</span>:   make  len  cap  <span class="keyword">new</span>  append  copy  close  <span class="keyword">delete</span></span><br><span class="line">             complex  real  imag</span><br><span class="line">             panic  recover</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string</span><br><span class="line"><span class="keyword">var</span> age int</span><br><span class="line"><span class="keyword">var</span> isOk bool</span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string</span><br><span class="line"><span class="keyword">var</span> age int</span><br><span class="line"><span class="keyword">var</span> isOk bool</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如：整型和浮点型变量的默认值为<code>0</code>。字符串变量的默认值为<code>空字符串</code>。布尔型变量默认为<code>false</code>。切片、函数、指针变量的默认为<code>nil</code>。当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string = <span class="string">&quot;Macolm&quot;</span></span><br><span class="line"><span class="keyword">var</span> age int = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;Macolm&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Macolm&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">foo</span>() (int, string) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">x, _ := <span class="title function_">foo</span>()</span><br><span class="line">_, y := <span class="title function_">foo</span>()</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。(在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code>不能使用在函数外。</li><li><code>_</code>多用于占位，表示忽略值。</li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。多个常量也可以一起声明：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之基本数据类型</title>
      <link href="/posts/4a17b002.html"/>
      <url>/posts/4a17b002.html</url>
      
        <content type="html"><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是uint32，64位操作系统上就是uint64</td></tr><tr><td>int</td><td>32位操作系统上就是int32，64位操作系统上就是int64</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong><br>在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平</p><p>台上的差异。</p><p><strong>注意事项</strong><br>获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用</p><p>中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述</p><p>时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法"><a href="#数字字面量语法" class="headerlink" title="数字字面量语法"></a>数字字面量语法</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。<br><code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。<br><code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说：<br><code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a int = <span class="number">10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b int = <span class="number">077</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c int = <span class="number">0xff</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code> 标准：</p><p><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p><p><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">        fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, math.<span class="property">Pi</span>)</span><br><span class="line">        fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, math.<span class="property">Pi</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 complex64</span><br><span class="line">c1 = <span class="number">1</span> + 2i</span><br><span class="line"><span class="keyword">var</span> c2 complex128</span><br><span class="line">c2 = <span class="number">2</span> + 3i</span><br><span class="line">fmt.<span class="title class_">Println</span>(c1)</span><br><span class="line">fmt.<span class="title class_">Println</span>(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>举个例子，我们要打印一个Windows平台下的一个文件路径：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    fmt.<span class="title class_">Println</span>(<span class="string">&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a><strong>byte和rune类型</strong></h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line">func <span class="title function_">traversalString</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line"><span class="keyword">for</span> _, r := range s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span>(h) <span class="number">101</span>(e) <span class="number">108</span>(l) <span class="number">108</span>(l) <span class="number">111</span>(o) <span class="number">230</span>(æ) <span class="number">178</span>(²) <span class="number">153</span>() <span class="number">230</span>(æ) <span class="number">178</span>(²) <span class="number">179</span>(³) </span><br><span class="line"><span class="number">104</span>(h) <span class="number">101</span>(e) <span class="number">108</span>(l) <span class="number">108</span>(l) <span class="number">111</span>(o) <span class="number">27801</span>(沙) <span class="number">27827</span>(河)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的字符串是由byte字节组成，所以字符串的长度是byte字节的长度。rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">changeString</span>(<span class="params"></span>) &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="title function_">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="title function_">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。强制类型转换的基本语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">T</span>(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">sqrtDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c int</span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="title function_">int</span>(math.<span class="title class_">Sqrt</span>(<span class="title function_">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.<span class="title class_">Println</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之流程控制</title>
      <link href="/posts/4a17b003.html"/>
      <url>/posts/4a17b003.html</url>
      
        <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">ifDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a><strong>if条件判断特殊写法</strong></h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">ifDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo3</span>(<span class="params"></span>) &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。<br>通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;大拇指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;食指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;中指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;无名指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;小拇指&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;无效的输入！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">testSwitch3</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;奇数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;偶数&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo4</span>(<span class="params"></span>) &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好学习吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好工作吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好享受吧&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo5</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">fallthrough</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。例如双层嵌套的for循环要退出时：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">gotoDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> breakFlag bool</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">gotoDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">goto breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line"><span class="attr">breakTag</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;结束for循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bread-跳出循环"><a href="#bread-跳出循环" class="headerlink" title="bread(跳出循环)"></a>bread(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。<br>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">breakDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">BREAKDEMO1</span>:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="title class_">BREAKDEMO1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a><strong>continue(继续下次循环)</strong></h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">continueDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="attr">forloop1</span>:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之运算符</title>
      <link href="/posts/4a17b004.html"/>
      <url>/posts/4a17b004.html</url>
      
        <content type="html"><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算术运算法"><a href="#算术运算法" class="headerlink" title="算术运算法"></a>算术运算法</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意：</strong><code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td></td><td></td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td></td><td></td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>«</td><td>左移n位就是乘以2的n次方。 “a«b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>»</td><td>右移n位就是除以2的n次方。 “a»b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>«&#x3D;</td><td>左移后赋值</td></tr><tr><td>»&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td></td><td>&#x3D;</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言fmt.printf使用指南</title>
      <link href="/posts/4a17b007.html"/>
      <url>/posts/4a17b007.html</url>
      
        <content type="html"><![CDATA[<p>fmt标准库是我们在学习Go语言过程中接触最早最频繁的一个了，本文介绍了fmtb包的一些常用函数。</p><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>fmt包实现了类似C语言printf和scanf的格式化I&#x2F;O。主要分为向外输出内容和获取输入内容两大部分。</p><h3 id="向外输出"><a href="#向外输出" class="headerlink" title="向外输出"></a>向外输出</h3><p>标准库<code>fmt</code>提供了以下几种输出相关函数。</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p><code>Print</code>系列函数会将内容输出到系统的标准输出，区别在于<code>Print</code>函数直接输出内容，<code>Printf</code>函数支持格式化输出字符串，<code>Println</code>函数会在输出内容的结尾添加一个换行符。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Print</span>(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Printf</span>(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Println</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>举个简单的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">fmt.<span class="title class_">Print</span>(<span class="string">&quot;在终端打印该信息。&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;我是：%s\n&quot;</span>, name)</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;在终端打印单独一行显示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在终端打印该信息。我是：沙河小王子</span><br><span class="line">在终端打印单独一行显示</span><br></pre></td></tr></table></figure><h3 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h3><p><code>Fprint</code>系列函数会将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，我们通常用这个函数往文件中写入内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Fprint</span>(w io.<span class="property">Writer</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fprintf</span>(w io.<span class="property">Writer</span>, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fprintln</span>(w io.<span class="property">Writer</span>, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向标准输出写入内容</span></span><br><span class="line">fmt.<span class="title class_">Fprintln</span>(os.<span class="property">Stdout</span>, <span class="string">&quot;向标准输出写入内容&quot;</span>)</span><br><span class="line">fileObj, err := os.<span class="title class_">OpenFile</span>(<span class="string">&quot;./xx.txt&quot;</span>, os.<span class="property">O_CREATE</span>|os.<span class="property">O_WRONLY</span>|os.<span class="property">O_APPEND</span>, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line"><span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.<span class="title class_">Fprintf</span>(fileObj, <span class="string">&quot;往文件中写如信息：%s&quot;</span>, name)</span><br></pre></td></tr></table></figure><p>注意，只要满足<code>io.Writer</code>接口的类型都支持写入。</p><h3 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h3><p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Sprint</span>(a ...interface&#123;&#125;) string</span><br><span class="line">func <span class="title class_">Sprintf</span>(format string, a ...interface&#123;&#125;) string</span><br><span class="line">func <span class="title class_">Sprintln</span>(a ...interface&#123;&#125;) string</span><br></pre></td></tr></table></figure><p>简答的示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := fmt.<span class="title class_">Sprint</span>(<span class="string">&quot;沙河小王子&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">s2 := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;name:%s,age:%d&quot;</span>, name, age)</span><br><span class="line">s3 := fmt.<span class="title class_">Sprintln</span>(<span class="string">&quot;沙河小王子&quot;</span>)</span><br><span class="line">fmt.<span class="title class_">Println</span>(s1, s2, s3)</span><br></pre></td></tr></table></figure><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Errorf</span>(format string, a ...interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>通常使用这种方式来自定义错误类型，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.<span class="title class_">Errorf</span>(<span class="string">&quot;这是一个错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e := errors.<span class="title class_">New</span>(<span class="string">&quot;原始错误e&quot;</span>)</span><br><span class="line">w := fmt.<span class="title class_">Errorf</span>(<span class="string">&quot;Wrap了一个错误%w&quot;</span>, e)</span><br></pre></td></tr></table></figure><h2 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h2><p><code>*printf</code>系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。</p><h3 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%v</td><td>值的默认格式表示</td></tr><tr><td>%+v</td><td>类似%v，但输出结构体时会添加字段名</td></tr><tr><td>%#v</td><td>值的Go语法表示</td></tr><tr><td>%T</td><td>打印值的类型</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, <span class="number">100</span>)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">o := struct&#123; name string &#125;&#123;<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%T\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;100%%\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;小王子&#125;</span><br><span class="line">struct &#123; name string &#125;&#123;<span class="attr">name</span>:<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">struct &#123; name string &#125;</span><br><span class="line"><span class="number">100</span>%</span><br></pre></td></tr></table></figure><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%t</td><td>true或false</td></tr></tbody></table><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>表示为二进制</td></tr><tr><td>%c</td><td>该值对应的unicode码值</td></tr><tr><td>%d</td><td>表示为十进制</td></tr><tr><td>%o</td><td>表示为八进制</td></tr><tr><td>%x</td><td>表示为十六进制，使用a-f</td></tr><tr><td>%X</td><td>表示为十六进制，使用A-F</td></tr><tr><td>%U</td><td>表示为Unicode格式：U+1234，等价于”U+%04X”</td></tr><tr><td>%q</td><td>该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">65</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%c\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%d\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%o\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000001</span></span><br><span class="line">A</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure><h3 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>无小数部分、二进制指数的科学计数法，如-123456p-78</td></tr><tr><td>%e</td><td>科学计数法，如-1234.456e+78</td></tr><tr><td>%E</td><td>科学计数法，如-1234.456E+78</td></tr><tr><td>%f</td><td>有小数部分但无指数部分，如123.456</td></tr><tr><td>%F</td><td>等价于%f</td></tr><tr><td>%g</td><td>根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td></tr><tr><td>%G</td><td>根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">12.34</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%E\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%g\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%G\n&quot;</span>, f)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6946802425218990p-<span class="number">49</span></span><br><span class="line"><span class="number">1.234000e+01</span></span><br><span class="line"><span class="number">1.234000E+01</span></span><br><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="number">12.34</span></span><br></pre></td></tr></table></figure><h3 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%s</td><td>直接输出字符串或者[]byte</td></tr><tr><td>%q</td><td>该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td></tr><tr><td>%x</td><td>每个字节用两字符十六进制数表示（使用a-f</td></tr><tr><td>%X</td><td>每个字节用两字符十六进制数表示（使用A-F）</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%q\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小王子</span><br><span class="line"><span class="string">&quot;小王子&quot;</span></span><br><span class="line">e5b08fe78e8be5ad90</span><br><span class="line"><span class="variable constant_">E5B08FE78E8BE5AD90</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%p</td><td>表示为十六进制，并加上前导的0x</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#p\n&quot;</span>, &amp;a)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc000094000</span></span><br><span class="line">c000094000</span><br></pre></td></tr></table></figure><h3 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h3><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%f</td><td>默认宽度，默认精度</td></tr><tr><td>%9f</td><td>宽度9，默认精度</td></tr><tr><td>%.2f</td><td>默认宽度，精度2</td></tr><tr><td>%9.2f</td><td>宽度9，精度2</td></tr><tr><td>%9.f</td><td>宽度9，精度0</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">12.34</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9.2f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9.f\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.34</span></span><br><span class="line">    <span class="number">12.34</span></span><br><span class="line">       <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="其他flag"><a href="#其他flag" class="headerlink" title="其他flag"></a>其他flag</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>‘+’</td><td>总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td></tr><tr><td>’ ‘</td><td>对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td></tr><tr><td>‘-’</td><td>在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td></tr><tr><td>‘#’</td><td>八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td></tr><tr><td>‘0’</td><td>使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td></tr></tbody></table><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%-5s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%-5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5.2s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%05s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出如下结果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小王子</span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">   小王</span><br><span class="line"><span class="number">00</span>小王子</span><br></pre></td></tr></table></figure><h2 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h2><p>Go语言<code>fmt</code>包下有<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p><h3 id="fmt-Scan"><a href="#fmt-Scan" class="headerlink" title="fmt.Scan"></a>fmt.Scan</h3><p>函数定签名如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scan</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li></ul><p>具体代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scan</span>(&amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scan</code>从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p><h3 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h3><p>函数签名如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scanf</span>(format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scanf</span>(<span class="string">&quot;1:%s 2:%d 3:%t&quot;</span>, &amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入<code>小王子</code>、<code>28</code>和<code>false</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line"><span class="number">1</span>:小王子 <span class="number">2</span>:<span class="number">28</span> <span class="number">3</span>:<span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scanf</code>不同于<code>fmt.Scan</code>简单的以空格作为输入数据的分隔符，<code>fmt.Scanf</code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p><p>例如，我们还是按照上个示例中以空格分隔的方式输入，<code>fmt.Scanf</code>就不能正确扫描到输入的数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>: <span class="attr">age</span>:<span class="number">0</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h3><p>函数签名如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scanln</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>具体代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scanln</span>(&amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scanln</code>遇到回车就结束扫描了，这个比较常用。</p><h3 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a><strong>bufio.NewReader</strong></h3><p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用<code>bufio</code>包来实现。示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">bufioDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line">reader := bufio.<span class="title class_">NewReader</span>(os.<span class="property">Stdin</span>) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">fmt.<span class="title class_">Print</span>(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line">text, _ := reader.<span class="title class_">ReadString</span>(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">text = strings.<span class="title class_">TrimSpace</span>(text)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a><strong>Fscan系列</strong></h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Fscan</span>(r io.<span class="property">Reader</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fscanln</span>(r io.<span class="property">Reader</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fscanf</span>(r io.<span class="property">Reader</span>, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><h3 id="Scaan系列"><a href="#Scaan系列" class="headerlink" title="Scaan系列"></a>Scaan系列</h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Sscan</span>(str string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Sscanln</span>(str string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Sscanf</span>(str string, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之切片</title>
      <link href="/posts/4a17b005.html"/>
      <url>/posts/4a17b005.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">arraySum</span>(x [<span class="number">3</span>]int) int&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := range x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。再比如，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []string              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []int&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []bool&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []bool&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a == nil)       <span class="comment">//true</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b == nil)       <span class="comment">//false</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c == nil)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><p><strong>简单切片表达式</strong></p><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="title function_">len</span>(s), <span class="title function_">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(s):<span class="number">2</span> <span class="title function_">cap</span>(s):<span class="number">4</span></span><br></pre></td></tr></table></figure><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="title function_">len</span>(s), <span class="title function_">cap</span>(s))</span><br><span class="line">s2 := s[<span class="number">3</span>:<span class="number">4</span>]  <span class="comment">// 索引的上限是cap(s)而不是len(s)</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;</span>, s2, <span class="title function_">len</span>(s2), <span class="title function_">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(s):<span class="number">2</span> <span class="title function_">cap</span>(s):<span class="number">4</span></span><br><span class="line"><span class="attr">s2</span>:[<span class="number">5</span>] <span class="title function_">len</span>(s2):<span class="number">1</span> <span class="title function_">cap</span>(s2):<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>完整切片表达式</strong></p><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="title function_">len</span>(t), <span class="title function_">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">t</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(t):<span class="number">2</span> <span class="title function_">cap</span>(t):<span class="number">4</span></span><br></pre></td></tr></table></figure><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">make</span>([]T, size, cap)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := <span class="title function_">make</span>([]int, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">fmt.<span class="title class_">Println</span>(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。</p><p><img src="/images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87%204a0a4768e1584c7c8b8cab4aa2131167/Untitled.png" alt="Untitled"></p><p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p><p><img src="/images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87%204a0a4768e1584c7c8b8cab4aa2131167/Untitled%201.png" alt="Untitled"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。<br>切片唯一合法的比较操作是和<code>nil</code>比较。<br>一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []int         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []int&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="title function_">make</span>([]int, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">s1 := <span class="title function_">make</span>([]int, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := []int&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(s); i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := range s &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> s []int</span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []int&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="title function_">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []int</span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []int&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="title function_">make</span>([]int)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []int</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="title function_">append</span>(numSlice, i)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="title function_">len</span>(numSlice), <span class="title function_">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]  <span class="attr">len</span>:<span class="number">1</span>  <span class="attr">cap</span>:<span class="number">1</span>  <span class="attr">ptr</span>:<span class="number">0xc0000a8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span>]  <span class="attr">len</span>:<span class="number">2</span>  <span class="attr">cap</span>:<span class="number">2</span>  <span class="attr">ptr</span>:<span class="number">0xc0000a8040</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]  <span class="attr">len</span>:<span class="number">3</span>  <span class="attr">cap</span>:<span class="number">4</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]  <span class="attr">len</span>:<span class="number">4</span>  <span class="attr">cap</span>:<span class="number">4</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]  <span class="attr">len</span>:<span class="number">5</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]  <span class="attr">len</span>:<span class="number">6</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]  <span class="attr">len</span>:<span class="number">7</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]  <span class="attr">len</span>:<span class="number">8</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]  <span class="attr">len</span>:<span class="number">9</span>  <span class="attr">cap</span>:<span class="number">16</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]  <span class="attr">len</span>:<span class="number">10</span>  <span class="attr">cap</span>:<span class="number">16</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b8000</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []string</span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []string&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;</span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, a...)</span><br><span class="line">fmt.<span class="title class_">Println</span>(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="property">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> cap &gt; doublecap &#123;</span><br><span class="line">newcap = cap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="property">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = cap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a><strong>使用copy()函数复制切片</strong></h2><p>首先我们来看一个问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">copy</span>(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="title function_">make</span>([]int, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="title function_">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []int&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="title function_">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决go get下载包失败问题</title>
      <link href="/posts/4a17b008.html"/>
      <url>/posts/4a17b008.html</url>
      
        <content type="html"><![CDATA[<p>由于某些不可抗力的原因，国内使用<code>go get</code>命令安装包时会经常会出现timeout的问题。本文介绍几个常用的解决办法。</p><h2 id="从github克隆"><a href="#从github克隆" class="headerlink" title="从github克隆"></a>从github克隆</h2><p>golang在github上建立了一个镜像库，如<code>https://github.com/golang/net</code>就对应是 <code>https://golang.org/x/net</code>的镜像库。要下载<code>golang.org/x/net</code>包，可以在本地创建包的目录后使用<code>git clone</code>来拉取相应包的源代码文件，具体操作如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/golang.<span class="property">org</span>/x</span><br><span class="line">cd $GOPATH/src/golang.<span class="property">org</span>/x</span><br><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/golang/net.git</span></span><br></pre></td></tr></table></figure><h2 id="使用gopm"><a href="#使用gopm" class="headerlink" title="使用gopm"></a>使用gopm</h2><p>使用gopm可以从golang.org的一些镜像网站上下载。</p><h3 id="安装gopm"><a href="#安装gopm" class="headerlink" title="安装gopm"></a>安装gopm</h3><aside>💡 go get -u [github.com/gpmgo/gopm](http://github.com/gpmgo/gopm)</aside><h3 id="使用gopm安装第三方包"><a href="#使用gopm安装第三方包" class="headerlink" title="使用gopm安装第三方包"></a><strong>使用gopm安装第三方包</strong></h3><p>不加<code>-g</code>参数，会把依赖包下载<code>.vendor</code>目录下面；加上<code>-g</code>参数，可以把依赖包下载到<code>GOPATH</code>目录中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopm get -g golang.<span class="property">org</span>/x/net</span><br></pre></td></tr></table></figure><h2 id="使用goproxy"><a href="#使用goproxy" class="headerlink" title="使用goproxy"></a>使用goproxy</h2><p>Go的1.11版本以后 可以设置<code>GOPROXY</code>这个变量，来设置代理。如果你自己有代理服务器就可以把这个环境变量设置成自己的代理。首先开启<code>go module</code>支持:</p><p>在Mac&#x2F;linux下执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="title class_">GO111MODULE</span>=on</span><br></pre></td></tr></table></figure><p>Windows平台执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span> <span class="title class_">GO111MODULE</span>=on</span><br></pre></td></tr></table></figure><p>我们这里以<code>https://goproxy.cn</code>为例：在Mac&#x2F;linux下可以执行以下命令来设置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="variable constant_">GOPROXY</span>=<span class="attr">https</span>:<span class="comment">//goproxy.cn</span></span><br></pre></td></tr></table></figure><p>Windows平台在<code>cmd</code>执行以下命令来设置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span> <span class="variable constant_">GOPROXY</span>=<span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure><p>或者在<code>PowerShell</code>中执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>:\&gt; <span class="attr">$env</span>:<span class="variable constant_">GOPROXY</span> = <span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之数组</title>
      <link href="/posts/4a17b006.html"/>
      <url>/posts/4a17b006.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]int</span><br></pre></td></tr></table></figure><h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>，数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。<code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]int</span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]int</span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]int                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]int</span><br><span class="line"><span class="keyword">var</span> numArray = [...]int&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [...]int&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(a); i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := range a &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := range a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := range v1 &#123;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\t&quot;</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a><strong>数组是值类型</strong></h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">modifyArray</span>(<span class="params">x [<span class="number">3</span>]int</span>) &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">modifyArray2</span>(<span class="params">x [<span class="number">3</span>][<span class="number">2</span>]int</span>) &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>]int&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="title function_">modifyArray</span>(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]int&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">modifyArray2</span>(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组支持 “&#x3D;&#x3D;”、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>[n]T</code>表示数组指针 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（四）- 文件上传&amp;&amp;重定向</title>
      <link href="/posts/773215c8.html"/>
      <url>/posts/773215c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h2><p>文件上传前端页面代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;上传文件示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>后端gin框架部分代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/upload&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 单个文件</span></span><br><span class="line">file, err := c.<span class="title class_">FormFile</span>(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusInternalServerError</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: err.<span class="title class_">Error</span>(),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.<span class="title class_">Println</span>(file.<span class="property">Filename</span>)</span><br><span class="line">dst := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;C:/tmp/%s&quot;</span>, file.<span class="property">Filename</span>)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.<span class="title class_">SaveUploadedFile</span>(file, dst)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.<span class="property">Filename</span>),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/upload&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.<span class="title class_">MultipartForm</span>()</span><br><span class="line">files := form.<span class="property">File</span>[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, file := range files &#123;</span><br><span class="line">log.<span class="title class_">Println</span>(file.<span class="property">Filename</span>)</span><br><span class="line">dst := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;C:/tmp/%s_%d&quot;</span>, file.<span class="property">Filename</span>, index)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.<span class="title class_">SaveUploadedFile</span>(file, dst)</span><br><span class="line">&#125;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="title function_">len</span>(files)),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h2><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title class_">Redirect</span>(http.<span class="property">StatusMovedPermanently</span>, <span class="string">&quot;http://www.sogo.com/&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>路由重定向，使用<code>HandleContext</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">    <span class="comment">// 指定重定向的URL</span></span><br><span class="line">    c.<span class="property">Request</span>.<span class="property">URL</span>.<span class="property">Path</span> = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.<span class="title class_">HandleContext</span>(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test2&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">    c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（五）- 路由&amp;&amp;中间件</title>
      <link href="/posts/773215c9.html"/>
      <url>/posts/773215c9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gin框架学习（五）-路由-中间件"><a href="#Gin框架学习（五）-路由-中间件" class="headerlink" title="Gin框架学习（五）- 路由&amp;&amp;中间件"></a>Gin框架学习（五）- 路由&amp;&amp;中间件</h1><h1 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h1><h2 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title class_">Any</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title class_">NoRoute</span>(<span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusNotFound</span>, <span class="string">&quot;views/404.html&quot;</span>, nil)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h2><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>&#123;&#125;</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>&#123;&#125;</code>包裹功能上没什么区别。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">userGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">userGroup.<span class="title function_">GET</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">userGroup.<span class="title function_">POST</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/cart&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">POST</span>(<span class="string">&quot;/checkout&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由组也是支持嵌套的，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/cart&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">POST</span>(<span class="string">&quot;/checkout&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line"><span class="comment">// 嵌套路由组</span></span><br><span class="line">xx := shopGroup.<span class="title class_">Group</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">xx.<span class="title function_">GET</span>(<span class="string">&quot;/oo&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>Gin框架中的路由使用的是<code>httprouter</code>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h1 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h1><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><h2 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h2><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。</p><h3 id="记录接口耗时的中间件"><a href="#记录接口耗时的中间件" class="headerlink" title="记录接口耗时的中间件"></a>记录接口耗时的中间件</h3><p>例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计耗时请求耗时的中间件</span></span><br><span class="line">func <span class="title class_">StatCost</span>() gin.<span class="property">HandlerFunc</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">start := time.<span class="title class_">Now</span>()</span><br><span class="line">c.<span class="title class_">Set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">c.<span class="title class_">Next</span>()</span><br><span class="line"><span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line"><span class="comment">// 计算耗时</span></span><br><span class="line">cost := time.<span class="title class_">Since</span>(start)</span><br><span class="line">log.<span class="title class_">Println</span>(cost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录响应体的中间件"><a href="#记录响应体的中间件" class="headerlink" title="记录响应体的中间件"></a>记录响应体的中间件</h3><p>我们有时候可能会想要记录下某些情况下返回给客户端的响应数据，这个时候就可以编写一个中间件来搞定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type bodyLogWriter struct &#123;</span><br><span class="line">gin.<span class="property">ResponseWriter</span>               <span class="comment">// 嵌入gin框架ResponseWriter</span></span><br><span class="line">body               *bytes.<span class="property">Buffer</span> <span class="comment">// 我们记录用的response</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 写入响应体数据</span></span><br><span class="line">func (w bodyLogWriter) <span class="title class_">Write</span>(b []byte) (int, error) &#123;</span><br><span class="line">w.<span class="property">body</span>.<span class="title class_">Write</span>(b)                  <span class="comment">// 我们记录一份</span></span><br><span class="line"><span class="keyword">return</span> w.<span class="property">ResponseWriter</span>.<span class="title class_">Write</span>(b) <span class="comment">// 真正写入响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件</span></span><br><span class="line"><span class="comment">// https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin</span></span><br><span class="line">func <span class="title function_">ginBodyLogMiddleware</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">blw := &amp;bodyLogWriter&#123;<span class="attr">body</span>: bytes.<span class="title class_">NewBuffer</span>([]byte&#123;&#125;), <span class="title class_">ResponseWriter</span>: c.<span class="property">Writer</span>&#125;</span><br><span class="line">c.<span class="property">Writer</span> = blw <span class="comment">// 使用我们自定义的类型替换默认的</span></span><br><span class="line"></span><br><span class="line">c.<span class="title class_">Next</span>() <span class="comment">// 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;Response body: &quot;</span> + blw.<span class="property">body</span>.<span class="title class_">String</span>()) <span class="comment">// 事后按需记录返回的响应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域中间件cors"><a href="#跨域中间件cors" class="headerlink" title="跨域中间件cors"></a>跨域中间件cors</h3><p>推荐使用社区的<a href="https://github.com/gin-contrib/cors"><code>https://github.com/gin-contrib/cors</code></a> 库，一行代码解决前后端分离架构下的跨域问题。 该中间件需要注册在业务处理函数前面。</p><p>这个库支持各种常用的配置项，具体使用方法如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router := gin.<span class="title class_">Default</span>()</span><br><span class="line">  <span class="comment">// CORS for https://foo.com and https://github.com origins, allowing:</span></span><br><span class="line">  <span class="comment">// - PUT and PATCH methods</span></span><br><span class="line">  <span class="comment">// - Origin header</span></span><br><span class="line">  <span class="comment">// - Credentials share</span></span><br><span class="line">  <span class="comment">// - Preflight requests cached for 12 hours</span></span><br><span class="line">  router.<span class="title class_">Use</span>(cors.<span class="title class_">New</span>(cors.<span class="property">Config</span>&#123;</span><br><span class="line">    <span class="title class_">AllowOrigins</span>:     []string&#123;<span class="string">&quot;https://foo.com&quot;</span>&#125;,  <span class="comment">// 允许跨域发来请求的网站</span></span><br><span class="line">    <span class="title class_">AllowMethods</span>:     []string&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>,  <span class="string">&quot;OPTIONS&quot;</span>&#125;,  <span class="comment">// 允许的请求方法</span></span><br><span class="line">    <span class="title class_">AllowHeaders</span>:     []string&#123;<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>&#125;,</span><br><span class="line">    <span class="title class_">ExposeHeaders</span>:    []string&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,</span><br><span class="line">    <span class="title class_">AllowCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title class_">AllowOriginFunc</span>: <span class="title function_">func</span>(origin string) bool &#123;  <span class="comment">// 自定义过滤源站的方法</span></span><br><span class="line">      <span class="keyword">return</span> origin == <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">MaxAge</span>: <span class="number">12</span> * time.<span class="property">Hour</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">  router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router := gin.<span class="title class_">Default</span>()</span><br><span class="line">  <span class="comment">// same as</span></span><br><span class="line">  <span class="comment">// config := cors.DefaultConfig()</span></span><br><span class="line">  <span class="comment">// config.AllowAllOrigins = true</span></span><br><span class="line">  <span class="comment">// router.Use(cors.New(config))</span></span><br><span class="line">  router.<span class="title class_">Use</span>(cors.<span class="title class_">Default</span>())</span><br><span class="line">  router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><h3 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.<span class="title class_">New</span>()</span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.<span class="title class_">Use</span>(<span class="title class_">StatCost</span>())</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">name := c.<span class="title class_">MustGet</span>(<span class="string">&quot;name&quot;</span>).(string) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.<span class="title class_">Println</span>(name)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test2&quot;</span>, <span class="title class_">StatCost</span>(), <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">name := c.<span class="title class_">MustGet</span>(<span class="string">&quot;name&quot;</span>).(string) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.<span class="title class_">Println</span>(name)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="位路由组注册中间件"><a href="#位路由组注册中间件" class="headerlink" title="位路由组注册中间件"></a>位路由组注册中间件</h3><p>为路由组注册中间件有以下两种写法。</p><p>写法1：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>, <span class="title class_">StatCost</span>())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.<span class="title class_">Use</span>(<span class="title class_">StatCost</span>())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h2><h3 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h3><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h3 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h3><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习（一）- 基础概念</title>
      <link href="/posts/ba02eb10.html"/>
      <url>/posts/ba02eb10.html</url>
      
        <content type="html"><![CDATA[<p>Docker的操作围绕镜像、容器、仓库三大核心概念。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是什么呢？通俗地讲，它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。所以你想启动一个容器，那首先必须要有一个镜像。<strong>镜像是 Docker 容器启动的先决条件。</strong></p><p>如果你想使用一个镜像，你可以使用这种方式：</p><ul><li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，你可以在基础镜像上添加一些用户自定义的内容。例如你可以基于<code>centos</code>镜像制作你自己的业务镜像，首先安装<code>nginx</code>服务，然后部署你的应用程序，最后做一些自定义配置，这样一个业务镜像就做好了。</li><li>从功能镜像仓库拉取别人制作好的镜像。一些常用的软件或者系统都会有官方已经制作好的镜像，例如<code>nginx</code>、<code>ubuntu</code>、<code>centos</code>、<code>mysql</code>等，你可以到 <a href="https://hub.docker.com/">Docker Hub</a> 搜索并下载它们。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是什么呢？容器是 Docker 的另一个核心概念。通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即<strong>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。</strong></p><p>虽然容器的本质是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。镜像仓库分为公共镜像仓库和私有镜像仓库。</p><p>目前，<a href="https://hub.docker.com/">Docker Hub</a> 是 Docker 官方的公开镜像仓库，它不仅有很多应用或者操作系统的官方镜像，还有很多组织或者个人开发的镜像供我们免费存放、下载、研究和使用。除了公开镜像仓库，你也可以构建自己的私有镜像仓库。</p><h2 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h2><p>![Untitled](images&#x2F;Docker学习（一）- 基础概念&#x2F;Untitled.png)</p><p>镜像是容器的基石，容器是由镜像创建的。一个镜像可以创建多个容器，容器是镜像运行的实体。仓库就非常好理解了，就是用来存放和分发镜像的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（三）- 获取参数</title>
      <link href="/posts/773215c7.html"/>
      <url>/posts/773215c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取querystring参数"><a href="#获取querystring参数" class="headerlink" title="获取querystring参数"></a><strong>获取querystring参数</strong></h2><p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。获取请求的querystring参数的方法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/user/search&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">username := c.<span class="title class_">DefaultQuery</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line"><span class="comment">//username := c.Query(&quot;username&quot;)</span></span><br><span class="line">address := c.<span class="title class_">Query</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取form参数"><a href="#获取form参数" class="headerlink" title="获取form参数"></a>获取form参数</h2><p>当前端请求的数据通过form表单提交时，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/user/search&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line"><span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)</span></span><br><span class="line">username := c.<span class="title class_">PostForm</span>(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.<span class="title class_">PostForm</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取JSON参数"><a href="#获取JSON参数" class="headerlink" title="获取JSON参数"></a>获取JSON参数</h2><p>当前端请求的数据通过JSON提交时，例如向<code>/json</code>发送一个JSON格式的POST请求，则获取请求参数的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/json&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 注意：下面为了举例子方便，暂时忽略了错误处理</span></span><br><span class="line">b, _ := c.<span class="title class_">GetRawData</span>()  <span class="comment">// 从c.Request.Body读取请求数据</span></span><br><span class="line"><span class="comment">// 定义map或结构体</span></span><br><span class="line"><span class="keyword">var</span> m map[string]interface&#123;&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">_ = json.<span class="title class_">Unmarshal</span>(b, &amp;m)</span><br><span class="line"></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, m)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取path参数"><a href="#获取path参数" class="headerlink" title="获取path参数"></a>获取path参数</h2><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。获取请求URL路径中的参数的方式如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">username := c.<span class="title class_">Param</span>(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.<span class="title class_">Param</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line">type <span class="title class_">Login</span> struct &#123;</span><br><span class="line"><span class="title class_">User</span>     string <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line"><span class="title class_">Password</span> string <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定JSON的示例 (&#123;&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;&#125;)</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/loginJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;login info:%#v\n&quot;</span>, login)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/loginForm&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/loginForm&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">router.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p><ol><li>如果是 <code>GET</code> 请求，只使用 <code>Form</code> 绑定引擎（<code>query</code>）。</li><li>如果是 <code>POST</code> 请求，首先检查 <code>content-type</code> 是否为 <code>JSON</code> 或 <code>XML</code>，然后再使用 <code>Form</code>（<code>form-data</code>）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（二）- Gin渲染</title>
      <link href="/posts/ba02eb07.html"/>
      <url>/posts/ba02eb07.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTML渲染"><a href="#HTML渲染" class="headerlink" title="HTML渲染"></a>HTML渲染</h2><p>我们首先定义一个存放模板文件的<code>templates</code>文件夹，然后在其内部按照业务分别定义一个<code>posts</code>文件夹和一个<code>users</code>文件夹。<code>posts/index.html</code>文件的内容如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define <span class="string">&quot;posts/index.html&quot;</span>&#125;&#125;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>users/index.html</code>文件的内容如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define <span class="string">&quot;users/index.html&quot;</span>&#125;&#125;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title class_">LoadHTMLGlob</span>(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"><span class="comment">//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/posts/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;posts/index.html&quot;</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;posts/index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;users/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;users/index.html&quot;</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;users/index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义模板函数"><a href="#自定义模板函数" class="headerlink" title="自定义模板函数"></a><strong>自定义模板函数</strong></h2><p>定义一个不转义相应内容的<code>safe</code>模板函数如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line">router.<span class="title class_">SetFuncMap</span>(template.<span class="property">FuncMap</span>&#123;</span><br><span class="line"><span class="string">&quot;safe&quot;</span>: <span class="title function_">func</span>(str string) template.<span class="property">HTML</span>&#123;</span><br><span class="line"><span class="keyword">return</span> template.<span class="title function_">HTML</span>(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">LoadHTMLFiles</span>(<span class="string">&quot;./index.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;index.tmpl&quot;</span>, <span class="string">&quot;&lt;a href=&#x27;https://liwenzhou.com&#x27;&gt;李文周的博客&lt;/a&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>index.tmpl</code>中使用定义好的<code>safe</code>模板函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>修改模板引擎的标识符<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; . | safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h2><p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用<code>gin.Static</code>方法即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title class_">Static</span>(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line">r.<span class="title class_">LoadHTMLGlob</span>(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用模版继承"><a href="#使用模版继承" class="headerlink" title="使用模版继承"></a>使用模版继承</h2><p>Gin框架默认都是使用单模板，如果需要使用<code>block template</code>功能，可以通过<code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p><p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中<code>home.tmpl</code>和<code>index.tmpl</code>继承了<code>base.tmpl</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">templates</span><br><span class="line">├── includes</span><br><span class="line">│   ├── home.<span class="property">tmpl</span></span><br><span class="line">│   └── index.<span class="property">tmpl</span></span><br><span class="line">├── layouts</span><br><span class="line">│   └── base.<span class="property">tmpl</span></span><br><span class="line">└── scripts.<span class="property">tmpl</span></span><br></pre></td></tr></table></figure><p>然后我们定义一个<code>loadTemplates</code>函数如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">loadTemplates</span>(templatesDir string) multitemplate.<span class="property">Renderer</span> &#123;</span><br><span class="line">r := multitemplate.<span class="title class_">NewRenderer</span>()</span><br><span class="line">layouts, err := filepath.<span class="title class_">Glob</span>(templatesDir + <span class="string">&quot;/layouts/*.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="title function_">panic</span>(err.<span class="title class_">Error</span>())</span><br><span class="line">&#125;</span><br><span class="line">includes, err := filepath.<span class="title class_">Glob</span>(templatesDir + <span class="string">&quot;/includes/*.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="title function_">panic</span>(err.<span class="title class_">Error</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为layouts/和includes/目录生成 templates map</span></span><br><span class="line"><span class="keyword">for</span> _, include := range includes &#123;</span><br><span class="line">layoutCopy := <span class="title function_">make</span>([]string, <span class="title function_">len</span>(layouts))</span><br><span class="line"><span class="title function_">copy</span>(layoutCopy, layouts)</span><br><span class="line">files := <span class="title function_">append</span>(layoutCopy, include)</span><br><span class="line">r.<span class="title class_">AddFromFiles</span>(filepath.<span class="title class_">Base</span>(include), files...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>函数中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">indexFunc</span>(<span class="params">c *gin.Context</span>)&#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;index.tmpl&quot;</span>, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">homeFunc</span>(<span class="params">c *gin.Context</span>)&#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;home.tmpl&quot;</span>, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="property">HTMLRender</span> = <span class="title function_">loadTemplates</span>(<span class="string">&quot;./templates&quot;</span>)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, indexFunc)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/home&quot;</span>, homeFunc)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充文件路径处理"><a href="#补充文件路径处理" class="headerlink" title="补充文件路径处理"></a><strong>补充文件路径处理</strong></h2><p>关于模板文件和静态文件的路径，我们需要根据公司&#x2F;项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">getCurrentPath</span>() string &#123;</span><br><span class="line"><span class="keyword">if</span> ex, err := os.<span class="title class_">Executable</span>(); err == nil &#123;</span><br><span class="line"><span class="keyword">return</span> filepath.<span class="title class_">Dir</span>(ex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON渲染"><a href="#JSON渲染" class="headerlink" title="JSON渲染"></a>JSON渲染</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/someJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/moreJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg struct &#123;</span><br><span class="line"><span class="title class_">Name</span>    string <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line"><span class="title class_">Message</span> string</span><br><span class="line"><span class="title class_">Age</span>     int</span><br><span class="line">&#125;</span><br><span class="line">msg.<span class="property">Name</span> = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.<span class="property">Message</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.<span class="property">Age</span> = <span class="number">18</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML渲染"><a href="#XML渲染" class="headerlink" title="XML渲染"></a>XML渲染</h2><p>注意需要使用具名的结构体类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/someXML&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.<span class="title function_">XML</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/moreXML&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line">type <span class="title class_">MessageRecord</span> struct &#123;</span><br><span class="line"><span class="title class_">Name</span>    string</span><br><span class="line"><span class="title class_">Message</span> string</span><br><span class="line"><span class="title class_">Age</span>     int</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg <span class="title class_">MessageRecord</span></span><br><span class="line">msg.<span class="property">Name</span> = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.<span class="property">Message</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.<span class="property">Age</span> = <span class="number">18</span></span><br><span class="line">c.<span class="title function_">XML</span>(http.<span class="property">StatusOK</span>, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="CRD的简单介绍"><a href="#CRD的简单介绍" class="headerlink" title="CRD的简单介绍"></a>CRD的简单介绍</h1><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><code>Custom Resource Define</code> 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。</p><p>CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个对应的控制器去监听 CRD 的各种事件来添加自定义的业务逻辑。</p><h1 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h1><p>如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。</p><p>比如我们可以定义一个如下所示的 CRD 资源清单文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: apiextensions.<span class="property">k8s</span>.<span class="property">io</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  # name 必须匹配下面的spec字段：&lt;plural&gt;.&lt;group&gt;  </span><br><span class="line">  <span class="attr">name</span>: foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # <span class="keyword">for</span> more information on the below annotation, please see</span><br><span class="line">  # <span class="attr">https</span>:<span class="comment">//github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/2337-k8s.io-group-protection/README.md</span></span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    <span class="string">&quot;api-approved.kubernetes.io&quot;</span>: <span class="string">&quot;unapproved, experimental-only; please get an approval from Kubernetes API reviewers if you&#x27;re trying to develop a CRD in the *.k8s.io or *.kubernetes.io groups&quot;</span></span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  # group 名用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义： /apis/&lt;group&gt;/&lt;version&gt;</span><br><span class="line">  <span class="attr">group</span>: crd.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # 列出自定义资源的所有 <span class="variable constant_">API</span> 版本</span><br><span class="line">  <span class="attr">versions</span>:</span><br><span class="line">    - <span class="attr">name</span>: v1  # 版本名称，比如v1，v1beta1</span><br><span class="line">      <span class="attr">served</span>: <span class="literal">true</span>  # 是否开启通过 <span class="variable constant_">REST</span> <span class="title class_">APIs</span>访问 <span class="string">`/apis/&lt;group&gt;/&lt;version&gt;/...`</span></span><br><span class="line">      <span class="attr">storage</span>: <span class="literal">true</span> # 必须将一个且只有一个版本标记为存储版本</span><br><span class="line">      <span class="attr">schema</span>: # 定义自定义对象的声明规范</span><br><span class="line">        # schema used <span class="keyword">for</span> validation</span><br><span class="line">        <span class="attr">openAPIV3Schema</span>:</span><br><span class="line">          <span class="attr">type</span>: object</span><br><span class="line">          <span class="attr">properties</span>:</span><br><span class="line">            <span class="attr">spec</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">deploymentName</span>:</span><br><span class="line">                  <span class="attr">type</span>: string</span><br><span class="line">                <span class="attr">replicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">                  <span class="attr">minimum</span>: <span class="number">1</span></span><br><span class="line">                  <span class="attr">maximum</span>: <span class="number">10</span></span><br><span class="line">            <span class="attr">status</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">availableReplicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">  <span class="attr">names</span>:</span><br><span class="line">    # kind 是 sigular 的一个驼峰形式的定义，在资源清单中会使用</span><br><span class="line">    <span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line">    # plural 名字用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义：/apis/&lt;group&gt;<span class="regexp">/&lt;version&gt;/</span>&lt;plural&gt;    </span><br><span class="line">    <span class="attr">plural</span>: foos</span><br><span class="line">    # singular 名称用于 <span class="variable constant_">CLI</span> 操作或显示的一个别名    </span><br><span class="line">    <span class="attr">singular</span>: foo</span><br><span class="line">    # shortNames 相当于缩写形式    </span><br><span class="line">    <span class="attr">shortNames</span>:</span><br><span class="line">    - fo</span><br><span class="line">  <span class="attr">scope</span>: <span class="title class_">Namespaced</span></span><br></pre></td></tr></table></figure><p>这个地方的定义和我们定义普通的资源对象比较类似，我们可以随意定义一个自定义的资源对象，但是在创建资源的时候，肯定不是任由我们随意去编写 YAML 文件的，当我们把上面的 CRD 文件提交给 Kubernetes 之后，Kubernetes 会对我们提交的声明文件进行校验，从定义可以看出 CRD 是基于 <a href="https://link.juejin.cn/?target=https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md%23schemaObject">OpenAPI v3 schem</a> 进行规范的。</p><p>当然这种校验只是对于字段的类型进行校验，比较初级，如果想要更加复杂的校验，这个时候就需要通过 Kubernetes 的 admission webhook 来实现了。关于校验的更多用法，可以前往<a href="https://link.juejin.cn/?target=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/%23validation">官方文档</a>查看。</p><p>现在我们可以直接使用kubectl来创建这个CRD资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl apply -f crd.<span class="property">example</span>.<span class="property">com_foos</span>.<span class="property">yaml</span> </span><br><span class="line">customresourcedefinition.<span class="property">apiextensions</span>.<span class="property">k8s</span>.<span class="property">io</span>/foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span> created</span><br></pre></td></tr></table></figure><p>这个时候我们可以查看到集群中已经有我们定义的这个CRD资源对象了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get crd | grep example</span><br><span class="line">foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span>                                  <span class="number">2022</span>-<span class="number">05</span>-11<span class="attr">T05</span>:<span class="number">28</span>:51Z</span><br></pre></td></tr></table></figure><p>这个时候一个新的 namespace 级别的 RESTful API 就会被创建：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/apis/crd/example.<span class="property">com</span>/v1/namespaces<span class="comment">/*/foos/...</span></span><br></pre></td></tr></table></figure><p>接着我们就可以使用这个 API 端点来创建和管理自定义的对象，这些对象的类型就是上面创建的 CRD 对象规范中的 <code>foo</code>。</p><p>现在在 Kubernetes 集群中我们就多了一种新的资源叫做<code>foos.crd.example.com</code>    ，我们就可以使用它来定义一个 <code>Foo</code> 资源对象了，这个自定义资源对象里面可以包含的字段我们在定义的时候通过 <code>schema</code> 进行了规范，比如现在我们来创建一个如下所示的资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>创建完成后我们就可以用kubectl来管理我们这里创建的Foo对象了，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo</span><br><span class="line"><span class="variable constant_">NAME</span>          <span class="variable constant_">AGE</span></span><br><span class="line">example-foo   20m</span><br></pre></td></tr></table></figure><p>在使用 kubectl 的时候，资源名称是不区分大小写的，我们可以使用 CRD 中定义的单数或者复数形式以及任何简写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo example-foo -o yaml</span><br><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    kubectl.<span class="property">kubernetes</span>.<span class="property">io</span>/last-applied-<span class="attr">configuration</span>: |</span><br><span class="line">      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;crd.example.com/v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Foo&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;default&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;deploymentName&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;replicas&quot;</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">  <span class="attr">creationTimestamp</span>: <span class="string">&quot;2022-05-11T05:40:38Z&quot;</span></span><br><span class="line">  <span class="attr">generation</span>: <span class="number">1</span></span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line">  <span class="attr">namespace</span>: <span class="keyword">default</span></span><br><span class="line">  <span class="attr">resourceVersion</span>: <span class="string">&quot;37605212&quot;</span></span><br><span class="line">  <span class="attr">uid</span>: 56d5b1d3-f6f9-<span class="number">4106</span>-90c4-a0e3c7d130c0</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就如上面我们说的，现在我们自定义的资源创建完成了，但是也只是单纯的把资源清单数据存入到了 etcd 中而已，并没有什么其他用处，因为我们没有定义一个对应的控制器来处理相关的业务逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架（一）- Gin入门</title>
      <link href="/posts/fb160171.html"/>
      <url>/posts/fb160171.html</url>
      
        <content type="html"><![CDATA[<h2 id="Gin框架介绍"><a href="#Gin框架介绍" class="headerlink" title="Gin框架介绍"></a>Gin框架介绍</h2><p>Go世界里最流行的Web框架，Github上有<code>32K+</code>star。基于httprouter开发的Web框架。<br>中文文档齐全，简单易用的轻量级框架。</p><h2 id="Gin框架的安装与使用"><a href="#Gin框架的安装与使用" class="headerlink" title="Gin框架的安装与使用"></a>Gin框架的安装与使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载并安装<code>Gin</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.<span class="property">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="第一个Gin示例"><a href="#第一个Gin示例" class="headerlink" title="第一个Gin示例"></a>第一个Gin示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line"><span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/hello&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">c.<span class="title class_">JSON</span>(<span class="number">200</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生</title>
      <link href="/posts/fb160170.html"/>
      <url>/posts/fb160170.html</url>
      
        <content type="html"><![CDATA[<h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h3 id="容器产品研发"><a href="#容器产品研发" class="headerlink" title="容器产品研发"></a>容器产品研发</h3><p>了解docker、k8s、Istio、k8s-api等云原生技术这有限</p><p>有Kubernetes二次开发经验者优先</p><h3 id="云平台-Kubernetes-专家"><a href="#云平台-Kubernetes-专家" class="headerlink" title="云平台(Kubernetes)专家"></a>云平台(Kubernetes)专家</h3><p>有go语言开发经验</p><p>熟悉Docker&#x2F;Kubernetes容器生态核心开源项目和周边服务生态项目，如监控、日志、网络等方案，精通或者有实施经验者加分；</p><ul><li>DevOps背景，有Kubernetes经验、开源项目贡献维护经历加分；</li></ul><h3 id="云计算研发工程师"><a href="#云计算研发工程师" class="headerlink" title="云计算研发工程师"></a>云计算研发工程师</h3><p>有较强的云原生应用的思维方式，熟悉 K8S 生态产品，有云原生项目实施经验者优先；</p><p>掌握MySQL、MongoDB、Redis、RabbitMQ、Kafka等常用组件；</p><p>掌握Docker或者其它容器化技术和工具使用；</p><p>掌握Prometheus、Grafana、ELK等工具的使用；</p><p>熟悉WEB后端开发技术：协议、架构、存储、缓存、安全等；</p><p>掌握 Git、Jenkins 等 CI&#x2F;CD 工具；</p><h3 id="云原生应用运维工程师"><a href="#云原生应用运维工程师" class="headerlink" title="云原生应用运维工程师"></a>云原生应用运维工程师</h3><p>熟悉 Linux 操作系统，熟悉Xen、KVM虚拟化技术；</p><p>具备良好的代码功底及编码风格，至少熟悉Shell、Python或者GO的其中一种开发语言；</p><p>精通 Docker 与 Kubernetes 的各种组件及原理，熟悉 kubernetes 云原生周边生态，如：istio, prometheus 等；</p><p>了解集群、分布式服务架构，具备高可用，高并发的系统运维经验；</p><h3 id="golang云原生工程师"><a href="#golang云原生工程师" class="headerlink" title="golang云原生工程师"></a>golang云原生工程师</h3><p>对云原生体系有一定的理解，熟悉Kubernetes, Istio,Spiffe等开源软件；</p><p>对4A(Authn,Authz,Account,Audit)体系有一定的理解和实践优先;</p><p>熟练掌握C&#x2F;C++&#x2F;Golang&#x2F;Rust编程语言中的一种；</p><p>善于学习，有技术热情，有较好的逻辑思维和分析能力，拥有良好的沟通意识和团队协作精神；</p><p>良好的中英文读写能力。</p><h3 id="云原生研发专家"><a href="#云原生研发专家" class="headerlink" title="云原生研发专家"></a>云原生研发专家</h3><p>熟悉Linux系统、TCP&#x2F;IP网络协议等计算机基础 知识；</p><p>熟悉Golang语言开发，同时熟悉Java, Python, Shell等其他一种或多种语言，有独立解决各种系统问题的能力，对Golang语言有深刻的理解者优先考虑；</p><p>有Kubernetes&#x2F;Docker项目经验的同学优先， 熟悉源码和原理者加分；</p><p>有Docker&#x2F;Kubernetes&#x2F;lstio二次开发，扩展幵发者、社区经验者优先；</p><p>对AI训练框架Tensorflow&#x2F;Pytorch, 集群调度Kubeflow，调度引擎Argo等有深入研究和实践经验者优先；</p><p>有良好的沟通能力与自我驱动能力，愿意投身云原生领域的浪潮中；</p><p>有生产级别大规模k8s集群运维经验，敏锐的集群故障定位排查能力。</p><h3 id="容器运维工程师"><a href="#容器运维工程师" class="headerlink" title="容器运维工程师"></a>容器运维工程师</h3><p>全日制统招本科（含）以上学历，计算机相关专业；</p><p>熟练linux操作系统，掌握Linux常用命令以及shell、python编程；</p><p>具有一定的网络知识，如dhcp、dns、ntp、tcp等；</p><p>熟悉Docker、Kubernetes技术，包括架构、工作方式、安装部署等，3年以上Kubernetes部署、优化、运维经验；</p><p>精通Kubernetes容器Calico,Flannel等网络组件工作原理,熟悉CNI原理；</p><p>精通Kubernetes容器编排基础组件，包含但不限于helm,prometheus,jenkins等；</p><p>熟练使用golang等技术语言，有实际项目开发经验优先；</p><p>熟悉Prometheus+grafana，有一定的实际项目经验；</p><p>熟悉Gitlab、Jenkins、Ansible、Zabbix、Grafana、Prometheus等工具。</p><h2 id="云原生-容器运维"><a href="#云原生-容器运维" class="headerlink" title="云原生&#x2F;容器运维"></a>云原生&#x2F;容器运维</h2><p>1.统招全日制本科及以上学历，计算机、信息系统等IT相关专业；</p><p>2.熟悉云计算产品 (包括计算、网络、存储、安全数据库等)，熟悉阿里云的产品特点及运维方法；</p><p>3.熟练掌握Prometheus监控系统的部署、监控指标的制定；</p><p>4.了解云原生应用基础设施，例如Server less、Kubernetes (K8S)熟悉微服务应用架构；</p><p>5.熟练使用DevOps和SRE工具，如Terraform, Ansible, Git, Jenkins等；</p><p>6.有运维开发经验, 熟练使用shell、Python或go编程；</p><p>7.在关键任务、高可用性、高性能和大规模系统基础设施方面有经验；</p><p>8.较强的分析、解决问题、人际关系和表达能力；</p><p>9.熟悉Nginx，Redis， Tomcat，消息队列等基础组件及配置、优化等；</p><p>10.有扎实的金融服务行业基础者优先。</p><h2 id="Paas工程师"><a href="#Paas工程师" class="headerlink" title="Paas工程师"></a>Paas工程师</h2><p>1、软件开发能力</p><p>1）、有java开发经验，至少有2年以年开发经验、熟悉使用spring cloud或Dubbo等微服务开发经验</p><ol start="2"><li>原理部分（Linux、脚本、docker、k8s）</li></ol><p>1）、熟悉Linux操作系统</p><p>2）、具备编程开发能力和脚本维护能力（shell、python）</p><p>3）、熟悉Kubenetes构架原理:</p><p>4）、熟悉docker镜像原理和dockerfile制作命令与流程</p><p>5）、熟悉yaml文件编写，了解微服务与DevOps原理架构，具备容器化改造与服务目录上线能力</p><p>6）、具备Docker和K8S的巡检及异常恢复能力</p><p>7）、掌握开源k8s基本操作与管理</p><ol start="3"><li>开发支持能力（devops-cpe开发支持）</li></ol><p>1）掌握开发流水线开发支持</p><p>2）熟练使用开发工具（gitlab、jenkins、SonarQube等）</p><p>4、接受出差。</p><p><a href="https://www.notion.so/Docker-8c66ab360e884ae5a025615f9baab693?pvs=21">Docker基本概念</a></p><p><a href="https://www.notion.so/Docker-32f579b95a5d4fe6aa853e78520ac226?pvs=21">Docker命令实战</a></p><p><a href="https://www.notion.so/Kubernetes-8b8ab08960cc4b828a496c05dc819303?pvs=21">Kubernetes基本概念</a></p><p><a href="https://www.notion.so/Kubernetes-91ca5cc1021f40d2b70e6e5693a29efc?pvs=21">Kubernetes核心实战</a></p><p><a href="https://www.notion.so/KubeSphere-b48825a2c827402292034aa8ab7fb296?pvs=21">KubeSphere</a></p><p><a href="https://www.notion.so/Devops-c660844a21914e1b8b1fedadd51fcaec?pvs=21">Devops</a></p><p><a href="https://www.notion.so/895cb25098ab4ecda1dbdf8b2af76c56?pvs=21">基本概念</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术随想</title>
      <link href="/posts/dfb8a81f.html"/>
      <url>/posts/dfb8a81f.html</url>
      
        <content type="html"><![CDATA[<p>我是技术随想</p>]]></content>
      
      
      <categories>
          
          <category> 乱七八糟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps</title>
      <link href="/posts/a7787d29.html"/>
      <url>/posts/a7787d29.html</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><h1 id="一、DevOps介绍"><a href="#一、DevOps介绍" class="headerlink" title="一、DevOps介绍"></a>一、DevOps介绍</h1><h2 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a>1.1、定义</h2><p>DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障(QA)部门之间的沟通、协作与整合。个人理解DevOps是一种软件管理思维模式。</p><p>思维模式：DevOps就是消除Dev与Ops之间的壁垒(QA)，促进三者之间的沟通、协作与整合，让效率最大化。</p><p>技术落地：从拉取代码、编译构建、验证测试到生产部署，整个环节通过工具构建全流程流水线，自动化触发相关活动，提升研发整体的交付效率和质量。从工具层面优化了执行效率和质量。</p><p>软件开发最开始是由两个团队组成：</p><ul><li>开发计划由<strong>开发团队</strong>从头开始设计和整体系统的构建。需要系统不停的迭代更新。</li><li><strong>运维团队</strong>将开发团队的Code进行测试后部署上线。希望系统稳定安全运行。</li></ul><p>这看似两个目标不同的团队需要协同完成一个软件的开发。</p><p>在开发团队指定好计划并完成coding后，需要提供到运维团队。</p><p>运维团队向开发团队反馈需要修复的BUG以及一些需要返工的任务。</p><p>这时开发团队需要经常等待运维团队的反馈。这无疑延长了事件并推迟了整个软件开发的周期。</p><p>会有一种方式，在开发团队等待的时候，让开发团队转移到下一个项目中。等待运维团队为之前的代码提供反馈。</p><p>可是这样就意味着一个完整的项目需要一个更长的周期才可以开发出最终代码。</p><hr><p>基于现在的互联网现状，更推崇敏捷式开发，这样就导致项目的迭代速度更快，但是由于开发团队与运维团队的沟通问题，会导致新版本上线的时间成本很高。这又违背的敏捷式开发的最初的目的。</p><p>那么如果让开发团队和运维团队整合到成一个团队，协同应对一套软件呢？这就被称为DevOps。</p><p><strong>DevOps</strong>，字面意思是Development &amp;Operations的缩写，也就是开发&amp;运维。</p><p>虽然字面意思只涉及到了开发团队和运维团队，其实QA测试团队也是参与其中的。</p><p>网上可以查看到DevOps的符号类似于一个无穷大的符号</p><p>$$<br>\Large\textsf{DevOps}<br>$$</p><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled.png" alt="Untitled"></p><p>这表明<strong>DevOps</strong>是一个不断提高效率并且持续不断工作的过程</p><p>DevOps的方式可以让公司能够更快地应对更新和市场发展变化，开发可以快速交付，部署也更加稳定。</p><p>核心就在于简化Dev和Ops团队之间的流程，使整体软件开发过程更快速。</p><p>整体的软件开发流程包括：</p><ul><li>PLAN：开发团队根据客户的目标制定开发计划</li><li>CODE：根据PLAN开始编码过程，需要将不同版本的代码存储在一个库中。</li><li>BUILD：编码完成后，需要将代码构建并且运行。</li><li>TEST：成功构建项目后，需要测试代码是否存在BUG或错误。</li><li>DEPLOY：代码经过手动测试和自动化测试后，认定代码已经准备好部署并且交给运维团队。</li><li>OPERATE：运维团队将代码部署到生产环境中。</li><li>MONITOR：项目部署上线后，需要持续的监控产品。</li><li>INTEGRATE：然后将监控阶段收到的反馈发送回PLAN阶段，整体反复的流程就是DevOps的核心，即持续集成、持续部署。</li></ul><p>为了保证整体流程可以高效的完成，各个阶段都有比较常见的工具，如下图：</p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%201.png" alt="Untitled"></p><p>最终可以给DevOps下一个定义：<strong>DevOps 强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</strong></p><p>自动化的工具协作和沟通来完成软件的生命周期管理</p><h3 id="二、Code阶段工具"><a href="#二、Code阶段工具" class="headerlink" title="二、Code阶段工具"></a>二、Code阶段工具</h3><p>在code阶段，我们需要将不同版本的代码存储到一个仓库中，常见的版本控制工具就是SVN或者Git，这里我们采用Git作为版本控制工具，GitLab作为远程仓库。</p><h3 id="2-1-Git安装"><a href="#2-1-Git安装" class="headerlink" title="2.1 Git安装"></a>2.1 Git安装</h3><p><a href="https://git-scm.com/%EF%BC%88%E5%82%BB%E7%93%9C%E5%BC%8F%E5%AE%89%E8%A3%85%EF%BC%89">https://git-scm.com/（傻瓜式安装）</a></p><h3 id="2-2-GitLab安装"><a href="#2-2-GitLab安装" class="headerlink" title="2.2 GitLab安装"></a>2.2 GitLab安装</h3><p>单独准备服务器，采用Docker安装</p><ul><li><p>查看GitLab镜像</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure></li><li><p>拉取GitLab镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure></li><li><p>准备docker-compose.yml文件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line">services:</span><br><span class="line">  gitlab:</span><br><span class="line">    image: &#x27;gitlab/gitlab-ce:latest&#x27;</span><br><span class="line">    container_name: gitlab</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url &#x27;http://192.168.11.11:8929&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 2224</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;8929:8929&#x27;</span><br><span class="line">      - &#x27;2224:2224&#x27;</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x27;./config:/etc/gitlab&#x27;</span><br><span class="line">      - &#x27;./logs:/var/log/gitlab&#x27;</span><br><span class="line">      - &#x27;./data:/var/opt/gitlab&#x27;</span><br></pre></td></tr></table></figure></li><li><p>启动容器（需要稍等一小会……）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>访问GitLab首页首页</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%202.png" alt="Untitled"></p><ul><li><p>查看root用户初始密码初始密码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab cat /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%203.png" alt="Untitled"></p><ul><li>登录root用户登录成功后跳转页面</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%204.png" alt="Untitled"></p><ul><li>第一次登录后需要修改密码修改密码</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%205.png" alt="Untitled"></p><p>搞定后，即可像Gitee、GitHub一样使用。</p><h3 id="三、Build阶段工具"><a href="#三、Build阶段工具" class="headerlink" title="三、Build阶段工具"></a>三、Build阶段工具</h3><p>构建Java项目的工具一般有两种选择，一个是Maven，一个是Gradle。</p><p>这里我们选择Maven作为项目的编译工具。</p><p>具体安装Maven流程不做阐述，但是需要确保配置好Maven仓库私服以及JDK编译版本。</p><h3 id="四、Operate阶段工具"><a href="#四、Operate阶段工具" class="headerlink" title="四、Operate阶段工具"></a>四、Operate阶段工具</h3><p>部署过程，会采用Docker进行部署，暂时只安装Docker即可，后续还需安装Kubenetes</p><h3 id="4-1-Docker安装"><a href="#4-1-Docker安装" class="headerlink" title="4.1 Docker安装"></a>4.1 Docker安装</h3><ul><li><p>准备测试环境&amp;生产环境</p></li><li><p>下载Docker依赖组件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>设置下载Docker的镜像源为阿里云</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker服务</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>安装成功后，启动Docker并设置开机自启</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 启动Docker服务systemctl start docker# 设置开机自动启动systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><h2 id="测试安装成功效果"><a href="#测试安装成功效果" class="headerlink" title="测试安装成功效果    "></a>测试安装成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>  </h2><p>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%206.png" alt="Untitled"></p></li></ul><h3 id="4-2-Docker-Compose安装"><a href="#4-2-Docker-Compose安装" class="headerlink" title="4.2 Docker-Compose安装"></a>4.2 Docker-Compose安装</h3><ul><li><p>下载Docker&#x2F;Compose：<a href="https://github.com/docker/compose">https://github.com/docker/compose</a></p></li><li><p>将下载好的docker-compose-Linux-x86_64文件移动到Linux操作系统：……</p></li><li><p>设置docker-compose-Linux-x86_64文件权限，并移动到$PATH目录中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置文件权限</span><br><span class="line">chmod a+x docker-compose-Linux-x86_64</span><br><span class="line"># 移动到/usr/bin目录下，并重命名为docker-compose</span><br><span class="line">mv docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><h2 id="测试安装成功效果-1"><a href="#测试安装成功效果-1" class="headerlink" title="测试安装成功效果    "></a>测试安装成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>  </h2><p>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%207.png" alt="Untitled"></p></li></ul><h1 id="五、Integrate工具"><a href="#五、Integrate工具" class="headerlink" title="五、Integrate工具"></a>五、Integrate工具</h1><p>持续集成、持续部署的工具很多，其中Jenkins是一个开源的持续集成平台。</p><p>Jenkins涉及到将编写完毕的代码发布到测试环境和生产环境的任务，并且还涉及到了构建项目等任务。</p><p>Jenkins需要大量的插件保证工作，安装成本较高，下面会基于Docker搭建Jenkins。</p><h2 id="5-1-Jenkins介绍"><a href="#5-1-Jenkins介绍" class="headerlink" title="5.1 Jenkins介绍"></a>5.1 Jenkins介绍</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具</p><p>Jenkins应用广泛，大多数互联网公司都采用Jenkins配合GitLab、Docker、K8s作为实现DevOps的核心工具。</p><p>Jenkins最强大的就在于插件，Jenkins官方提供了大量的插件库，来自动化CI&#x2F;CD过程中的各种琐碎功能。</p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%208.png" alt="Untitled"></p><p>Jenkins最主要的工作就是将GitLab上可以构建的工程代码拉取并且进行构建，再根据流程可以选择发布到测试环境或是生产环境。</p><p>一般是GitLab上的代码经过大量的测试后，确定发行版本，再发布到生产环境。</p><p>CI&#x2F;CD可以理解为：</p><ul><li>CI过程即是通过Jenkins将代码拉取、构建、制作镜像交给测试人员测试。<ul><li>持续集成：让软件代码可以持续的集成到主干上，并自动构建和测试。</li></ul></li><li>CD过程即是通过Jenkins将打好标签的发行版本代码拉取、构建、制作镜像交给运维人员部署。<ul><li>持续交付：让经过持续集成的代码可以进行手动部署。</li><li>持续部署：让可以持续交付的代码随时随地的自动化部署。</li></ul></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%209.png" alt="Untitled"></p><h2 id="5-2-Jenkins安装"><a href="#5-2-Jenkins安装" class="headerlink" title="5.2 Jenkins安装"></a>5.2 Jenkins安装</h2><ul><li><p>拉取Jenkins镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br></pre></td></tr></table></figure></li><li><p>编写docker-compose.yml</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 50000:50000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/:/var/jenkins_home/</span><br></pre></td></tr></table></figure></li><li><p>首次启动会因为数据卷data目录没有权限导致启动失败，设置data目录写权限错误日志</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2010.png" alt="Untitled"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+w data/</span><br></pre></td></tr></table></figure><ul><li><p>重新启动Jenkins容器后，由于Jenkins需要下载大量内容，但是由于默认下载地址下载速度较慢，需要重新设置下载地址为国内镜像站</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 修改数据卷中的hudson.model.UpdateCenter.xml文件</span><br><span class="line">&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"># 将下载地址替换为http://mirror.esuni.jp/jenkins/updates/update-center.json</span><br><span class="line">&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;http://mirror.esuni.jp/jenkins/updates/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"># 清华大学的插件源也可以https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure></li><li><p>再次重启Jenkins容器，访问Jenkins（需要稍微等会）Jenkins首页</p></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2011.png" alt="Untitled"></p><ul><li><h2 id="查看密码登录Jenkins，并登录下载插件登录并下载插件"><a href="#查看密码登录Jenkins，并登录下载插件登录并下载插件" class="headerlink" title="查看密码登录Jenkins，并登录下载插件登录并下载插件    "></a>查看密码登录Jenkins，并登录下载插件登录并下载插件<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>  </h2>  <img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2012.png" alt="Untitled"></li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2013.png" alt="Untitled"></p><ul><li>选择需要安装的插件选择需要安装的插件</li><li>下载完毕设置信息进入首页（可能会出现下载失败的插件）</li></ul><h2 id="5-3、Jenkins入门配置"><a href="#5-3、Jenkins入门配置" class="headerlink" title="5.3、Jenkins入门配置"></a>5.3、Jenkins入门配置</h2><p>由于Jenkins需要从Git拉取代码、需要本地构建、甚至需要直接发布自定义镜像到Docker仓库，所以Jenkins需要配置大量内容。</p><h3 id="5-3-1-构建任务"><a href="#5-3-1-构建任务" class="headerlink" title="5.3.1 构建任务"></a>5.3.1 构建任务</h3><p>准备好GitLab仓库中的项目，并且通过Jenkins配置项目的实现当前项目的DevOps基本流程。</p><ul><li>构建Maven工程发布到GitLab（Gitee、Github均可）GitLab查看项目</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2014.png" alt="Untitled"></p><ul><li>Jenkins点击左侧导航新建任务新建任务</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2015.png" alt="Untitled"></p><ul><li>选择自由风格构建任务构建任务</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2016.png" alt="Untitled"></p><h3 id="5-3-1-配置源码拉取地址"><a href="#5-3-1-配置源码拉取地址" class="headerlink" title="5.3.1 配置源码拉取地址"></a>5.3.1 配置源码拉取地址</h3><p>Jenkins需要将Git上存放的源码存储到Jenkins服务所在磁盘的本地</p><ul><li>配置任务源码拉取的地址源码管理</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2017.png" alt="Untitled"></p><ul><li>Jenkins立即构建点击任务test中的立即构建</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2018.png" alt="Untitled"></p><ul><li>查看构建工程的日志，点击上述③的任务条即可查看任务拉取Git源码日志</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2019.png" alt="Untitled"></p><hr><p>可以看到源码已经拉取带Jenkins本地，可以根据第三行日志信息，查看Jenkins本地拉取到的源码。</p><ul><li>查看Jenkins容器中&#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;test的源码</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2020.png" alt="Untitled"></p><h3 id="5-3-2-配置Maven构建代码"><a href="#5-3-2-配置Maven构建代码" class="headerlink" title="5.3.2 配置Maven构建代码"></a>5.3.2 配置Maven构建代码</h3><p>代码拉取到Jenkins本地后，需要在Jenkins中对代码进行构建，这里需要Maven的环境，而Maven需要Java的环境，接下来需要在Jenkins中安装JDK和Maven，并且配置到Jenkins服务。</p><ul><li>准备JDK、Maven压缩包通过数据卷映射到Jenkins容器内部数据卷存放位置</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2021.png" alt="Untitled"></p><ul><li><p>解压压缩包，并配置Maven的settings.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云镜像地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK1.8编译插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Jenkins配置JDK&amp;Maven并保存</p></li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2022.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2023.png" alt="Untitled"></p><ul><li>配置Jenkins任务构建代码</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2024.png" alt="Untitled"></p><ul><li>立即构建测试，查看target下的jar包构建源码</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2025.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2026.png" alt="Untitled"></p><h3 id="5-3-3-配置Publish发布-远程操作"><a href="#5-3-3-配置Publish发布-远程操作" class="headerlink" title="5.3.3 配置Publish发布&amp;远程操作"></a>5.3.3 配置Publish发布&amp;远程操作</h3><p>jar包构建好之后，就可以根据情况发布到测试或生产环境，这里需要用到之前下载好的插件Publish Over SSH。</p><ul><li>配置Publish Over SSH连接测试、生产环境Publish Over SSH配置</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2027.png" alt="Untitled"></p><ul><li>配置任务的构建后操作，发布jar包到目标服务配置构建后操作</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2028.png" alt="Untitled"></p><p>- </p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2029.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2030.png" alt="Untitled"></p><ul><li>立即构建任务，并去目标服务查看</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2031.png" alt="Untitled"></p><h3 id="六、CI、CD入门操作"><a href="#六、CI、CD入门操作" class="headerlink" title="六、CI、CD入门操作"></a>六、CI、CD入门操作</h3><p>基于Jenkins拉取GitLab的SpringBoot代码进行构建发布到测试环境实现持续集成</p><p>基于Jenkins拉取GitLab指定发行版本的SpringBoot代码进行构建发布到生产环境实现CD实现持续部署</p><h3 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h3><p>为了让程序代码可以自动推送到测试环境基于Docker服务运行，需要添加Docker配置和脚本文件让程序可以在集成到主干的同时运行起来。</p><ul><li>添加Dockerfile文件构建自定义镜像</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2032.png" alt="Untitled"></p><ul><li>添加docker-compose.yml文件加载自定义镜像启动容器</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2033.png" alt="Untitled"></p><ul><li>追加Jenkins构建后操作脚本命令构建后发布并执行脚本命令</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2034.png" alt="Untitled"></p><ul><li>发布到GitLab后由Jenkins立即构建并托送到目标服务器</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2035.png" alt="Untitled"></p><ul><li>测试部署到目标服务器程序</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2036.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2037.png" alt="Untitled"></p><h3 id="6-2-持续交付、部署"><a href="#6-2-持续交付、部署" class="headerlink" title="6.2 持续交付、部署"></a>6.2 持续交付、部署</h3><p>程序代码在经过多次集成操作到达最终可以交付，持续交付整体流程和持续集成类似，不过需要选取指定的发行版本</p><ul><li>下载Git Parameter插件</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2038.png" alt="Untitled"></p><hr><ul><li>设置项目参数化构建-基于Git标签构建</li></ul><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2039.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2040.png" alt="Untitled"></p><ul><li>给项目添加tag版本添加tag版本</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2041.png" alt="Untitled"></p><ul><li>基于Parameter构建任务，任务发布到目标服务器</li></ul><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2042.png" alt="Untitled"></p><h3 id="七、集成Sonar-Qube"><a href="#七、集成Sonar-Qube" class="headerlink" title="七、集成Sonar Qube"></a>七、集成Sonar Qube</h3><h3 id="7-1-Sonar-Qube介绍"><a href="#7-1-Sonar-Qube介绍" class="headerlink" title="7.1 Sonar Qube介绍"></a>7.1 Sonar Qube介绍</h3><p>Sonar Qube是一个开源的代码分析平台，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，可以检测出重复代码、代码漏洞、代码规范和安全性漏洞的问题。</p><p>Sonar Qube可以与多种软件整合进行代码扫描，比如Maven，Gradle，Git，Jenkins等，并且会将代码检测结果推送回Sonar Qube并且在系统提供的UI界面上显示出来</p><p>Sonar Qube的UI界面</p><hr><p><img src="https://www.notion.sopictures/image-20211129190039986.png" alt="https://www.notion.soPictures/image-20211129190039986.png"></p><hr><h3 id="7-2-Sonar-Qube环境搭建"><a href="#7-2-Sonar-Qube环境搭建" class="headerlink" title="7.2 Sonar Qube环境搭建"></a>7.2 Sonar Qube环境搭建</h3><h3 id="7-2-1-Sonar-Qube安装"><a href="#7-2-1-Sonar-Qube安装" class="headerlink" title="7.2.1 Sonar Qube安装"></a>7.2.1 Sonar Qube安装</h3><p>Sonar Qube在7.9版本中已经放弃了对MySQL的支持，并且建议在商业环境中采用PostgreSQL，那么安装Sonar Qube时需要依赖PostgreSQL。</p><p>并且这里会安装Sonar Qube的长期支持版本8.9</p><ul><li><p>拉取镜像</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgresdocker pull sonarqube:8.9.3-community</span><br></pre></td></tr></table></figure></li><li><p>编写docker-compoe.yml</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;services:  db:    image: postgres    container_name: db    ports:      - 5432:5432    networks:      - sonarnet    environment:      POSTGRES_USER: sonar      POSTGRES_PASSWORD: sonar  sonarqube:    image: sonarqube:8.9.3-community    container_name: sonarqube    depends_on:      - db    ports:      - &quot;9000:9000&quot;    networks:      - sonarnet    environment:      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar      SONAR_JDBC_USERNAME: sonar      SONAR_JDBC_PASSWORD: sonarnetworks:  sonarnet:    driver: bridge</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><h2 id="需要设置sysctl-conf文件信息设置vm-max-map-count"><a href="#需要设置sysctl-conf文件信息设置vm-max-map-count" class="headerlink" title="需要设置sysctl.conf文件信息设置vm.max_map_count  "></a>需要设置sysctl.conf文件信息设置vm.max_map_count  </h2><h2 id=""><a href="#" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211207145215817.png" alt="https://www.notion.soPictures/image-20211207145215817.png">  </h2><h2 id="-1"><a href="#-1" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211207145342350.png" alt="https://www.notion.soPictures/image-20211207145342350.png">  </h2><p>  并执行命令刷新</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><h2 id="重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志"><a href="#重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志" class="headerlink" title="重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志  "></a>重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功容器日志  </h2><h2 id="-2"><a href="#-2" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129191426344.png" alt="https://www.notion.soPictures/image-20211129191426344.png">  </h2></li><li><h2 id="访问Sonar-Qube首页登录"><a href="#访问Sonar-Qube首页登录" class="headerlink" title="访问Sonar Qube首页登录  "></a>访问Sonar Qube首页登录  </h2><h2 id="-3"><a href="#-3" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129191537050.png" alt="https://www.notion.soPictures/image-20211129191537050.png">  </h2></li><li><h2 id="还需要重新设置一次密码重新设置密码"><a href="#还需要重新设置一次密码重新设置密码" class="headerlink" title="还需要重新设置一次密码重新设置密码  "></a>还需要重新设置一次密码重新设置密码  </h2><h2 id="-4"><a href="#-4" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129193824428.png" alt="https://www.notion.soPictures/image-20211129193824428.png">  </h2></li><li><h2 id="Sonar-Qube首页Sonar-Qube首页"><a href="#Sonar-Qube首页Sonar-Qube首页" class="headerlink" title="Sonar Qube首页Sonar Qube首页  "></a>Sonar Qube首页Sonar Qube首页  </h2><h2 id="-5"><a href="#-5" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129194148239.png" alt="https://www.notion.soPictures/image-20211129194148239.png">  </h2></li></ul><h3 id="7-2-2-安装中文插件"><a href="#7-2-2-安装中文插件" class="headerlink" title="7.2.2 安装中文插件"></a>7.2.2 安装中文插件</h3><p>安装中文插件</p><hr><p><img src="https://www.notion.sopictures/image-20211129194621820.png" alt="https://www.notion.soPictures/image-20211129194621820.png"></p><hr><p>安装成功后需要重启，安装失败重新点击install重装即可。</p><p>安装成功后，会查看到重启按钮，点击即可</p><p>重启按钮</p><hr><p><img src="https://www.notion.sopictures/image-20211129194748765.png" alt="https://www.notion.soPictures/image-20211129194748765.png"></p><hr><p>重启后查看效果</p><p>首页效果</p><hr><p><img src="https://www.notion.sopictures/image-20211129194931944.png" alt="https://www.notion.soPictures/image-20211129194931944.png"></p><hr><h3 id="7-3-Sonar-Qube基本使用"><a href="#7-3-Sonar-Qube基本使用" class="headerlink" title="7.3 Sonar Qube基本使用"></a>7.3 Sonar Qube基本使用</h3><p>Sonar Qube的使用方式很多，Maven可以整合，也可以采用sonar-scanner的方式，再查看Sonar Qube的检测效果</p><h3 id="7-3-1-Maven实现代码检测"><a href="#7-3-1-Maven实现代码检测" class="headerlink" title="7.3.1 Maven实现代码检测"></a>7.3.1 Maven实现代码检测</h3><ul><li><p>修改Maven的settings.xml文件配置Sonar Qube信息</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.login</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">sonar.login</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.password</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">sonar.password</span>&gt;</span>        <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span>http://192.168.11.11:9000<span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span>    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h2 id="在代码位置执行命令：mvn-sonar-sonar执行代码检测"><a href="#在代码位置执行命令：mvn-sonar-sonar执行代码检测" class="headerlink" title="在代码位置执行命令：mvn sonar:sonar执行代码检测  "></a>在代码位置执行命令：mvn sonar:sonar执行代码检测  </h2><h2 id="-6"><a href="#-6" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129195430146.png" alt="https://www.notion.soPictures/image-20211129195430146.png">  </h2></li><li><h2 id="查看Sonar-Qube界面检测结果Sonar-Qube检测结果"><a href="#查看Sonar-Qube界面检测结果Sonar-Qube检测结果" class="headerlink" title="查看Sonar Qube界面检测结果Sonar Qube检测结果  "></a>查看Sonar Qube界面检测结果Sonar Qube检测结果  </h2><h2 id="-7"><a href="#-7" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129195503762.png" alt="https://www.notion.soPictures/image-20211129195503762.png">  </h2></li></ul><h3 id="7-3-2-Sonar-scanner实现代码检测"><a href="#7-3-2-Sonar-scanner实现代码检测" class="headerlink" title="7.3.2 Sonar-scanner实现代码检测"></a>7.3.2 Sonar-scanner实现代码检测</h3><ul><li><p>下载Sonar-scanner：<a href="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/">https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/</a></p><p>  下载4.6.x版本即可，要求Linux版本</p></li><li><p>解压并配置sonar服务端信息</p><ul><li><p>由于是zip压缩包，需要安装unzip解压插件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install unzip</span><br></pre></td></tr></table></figure></li><li><p>解压压缩包</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br></pre></td></tr></table></figure></li><li><h2 id="配置sonarQube服务端地址，修改conf下的sonar-scanner-properties配置服务端信息"><a href="#配置sonarQube服务端地址，修改conf下的sonar-scanner-properties配置服务端信息" class="headerlink" title="配置sonarQube服务端地址，修改conf下的sonar-scanner.properties配置服务端信息  "></a>配置sonarQube服务端地址，修改conf下的sonar-scanner.properties配置服务端信息  </h2><h2 id="-8"><a href="#-8" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130140043382.png" alt="https://www.notion.soPictures/image-20211130140043382.png">  </h2></li></ul></li><li><h2 id="执行命令检测代码查看日志信息-Ps：主要查看我的sonar-scanner执行命令的位置"><a href="#执行命令检测代码查看日志信息-Ps：主要查看我的sonar-scanner执行命令的位置" class="headerlink" title="执行命令检测代码查看日志信息    Ps：主要查看我的sonar-scanner执行命令的位置  "></a>执行命令检测代码查看日志信息<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 在项目所在目录执行以下命令~/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=demo -Dsonar.projectKey=java -Dsonar.java.binaries=target/</span><br></pre></td></tr></table></figure><br><br>  Ps：主要查看我的sonar-scanner执行命令的位置  </h2><h2 id="-9"><a href="#-9" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130141303457.png" alt="https://www.notion.soPictures/image-20211130141303457.png">  </h2></li><li><h2 id="查看SonarQube界面检测结果检测结果"><a href="#查看SonarQube界面检测结果检测结果" class="headerlink" title="查看SonarQube界面检测结果检测结果  "></a>查看SonarQube界面检测结果检测结果  </h2><h2 id="-10"><a href="#-10" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130144608025.png" alt="https://www.notion.soPictures/image-20211130144608025.png">  </h2></li></ul><h3 id="7-4-Jenkins集成Sonar-Qube"><a href="#7-4-Jenkins集成Sonar-Qube" class="headerlink" title="7.4 Jenkins集成Sonar Qube"></a>7.4 Jenkins集成Sonar Qube</h3><p>Jenkins继承Sonar Qube实现代码扫描需要先下载整合插件</p><h3 id="7-4-1-Jenkins安装插件"><a href="#7-4-1-Jenkins安装插件" class="headerlink" title="7.4.1 Jenkins安装插件"></a>7.4.1 Jenkins安装插件</h3><p>下载Sonar Qube插件</p><hr><p><img src="https://www.notion.sopictures/image-20211129201625561.png" alt="https://www.notion.soPictures/image-20211129201625561.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211129201607240.png" alt="https://www.notion.soPictures/image-20211129201607240.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211129202147390.png" alt="https://www.notion.soPictures/image-20211129202147390.png"></p><hr><h3 id="7-4-2-Jenkins配置Sonar-Qube"><a href="#7-4-2-Jenkins配置Sonar-Qube" class="headerlink" title="7.4.2 Jenkins配置Sonar Qube"></a>7.4.2 Jenkins配置Sonar Qube</h3><ul><li><h2 id="开启Sonar-Qube权限验证开启Sonar-Qube权限校验"><a href="#开启Sonar-Qube权限验证开启Sonar-Qube权限校验" class="headerlink" title="开启Sonar Qube权限验证开启Sonar Qube权限校验  "></a>开启Sonar Qube权限验证开启Sonar Qube权限校验  </h2><h2 id="-11"><a href="#-11" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130144850186.png" alt="https://www.notion.soPictures/image-20211130144850186.png">  </h2></li><li><h2 id="获取Sonar-Qube的令牌获取令牌"><a href="#获取Sonar-Qube的令牌获取令牌" class="headerlink" title="获取Sonar Qube的令牌获取令牌  "></a>获取Sonar Qube的令牌获取令牌  </h2><h2 id="-12"><a href="#-12" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203102334.png" alt="https://www.notion.soPictures/image-20211129203102334.png">  </h2></li><li><h2 id="配置Jenkins的Sonar-Qube信息"><a href="#配置Jenkins的Sonar-Qube信息" class="headerlink" title="配置Jenkins的Sonar Qube信息    "></a>配置Jenkins的Sonar Qube信息<br><br>  <img src="https://www.notion.sopictures/image-20211129203235019.png" alt="https://www.notion.soPictures/image-20211129203235019.png">  </h2><h2 id="-13"><a href="#-13" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203342171.png" alt="https://www.notion.soPictures/image-20211129203342171.png">  </h2><h2 id="-14"><a href="#-14" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211129203457604.png" alt="https://www.notion.soPictures/image-20211129203457604.png">  </h2></li></ul><h3 id="7-4-3-配置Sonar-scanner"><a href="#7-4-3-配置Sonar-scanner" class="headerlink" title="7.4.3 配置Sonar-scanner"></a>7.4.3 配置Sonar-scanner</h3><ul><li><h2 id="将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner"><a href="#将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner" class="headerlink" title="将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner  "></a>将Sonar-scaner添加到Jenkins数据卷中并配置全局配置配置Sonar-scanner  </h2><h2 id="-15"><a href="#-15" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130153628925.png" alt="https://www.notion.soPictures/image-20211130153628925.png">  </h2></li><li><h2 id="配置任务的Sonar-scanner配置任务的Sonar-scanner"><a href="#配置任务的Sonar-scanner配置任务的Sonar-scanner" class="headerlink" title="配置任务的Sonar-scanner配置任务的Sonar-scanner  "></a>配置任务的Sonar-scanner配置任务的Sonar-scanner  </h2><h2 id="-16"><a href="#-16" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130155849143.png" alt="https://www.notion.soPictures/image-20211130155849143.png">  </h2></li></ul><h3 id="7-4-4-构建任务"><a href="#7-4-4-构建任务" class="headerlink" title="7.4.4 构建任务"></a>7.4.4 构建任务</h3><p>构建任务</p><hr><p><img src="https://www.notion.sopictures/image-20211130160017465.png" alt="https://www.notion.soPictures/image-20211130160017465.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211130160047648.png" alt="https://www.notion.soPictures/image-20211130160047648.png"></p><hr><h3 id="八、集成Harbor"><a href="#八、集成Harbor" class="headerlink" title="八、集成Harbor"></a>八、集成Harbor</h3><h3 id="8-1-Harbor介绍"><a href="#8-1-Harbor介绍" class="headerlink" title="8.1 Harbor介绍"></a>8.1 Harbor介绍</h3><p>前面在部署项目时，我们主要采用Jenkins推送jar包到指定服务器，再通过脚本命令让目标服务器对当前jar进行部署，这种方式在项目较多时，每个目标服务器都需要将jar包制作成自定义镜像再通过docker进行启动，重复操作比较多，会降低项目部署时间。</p><p>我们可以通过Harbor作为私有的Docker镜像仓库。让Jenkins统一将项目打包并制作成Docker镜像发布到Harbor仓库中，只需要通知目标服务，让目标服务统一去Harbor仓库上拉取镜像并在本地部署即可。</p><p>Docker官方提供了Registry镜像仓库，但是Registry的功能相对简陋。Harbor是VMware公司提供的一款镜像仓库，提供了权限控制、分布式发布、强大的安全扫描与审查机制等功能</p><h3 id="8-2-Harbor安装"><a href="#8-2-Harbor安装" class="headerlink" title="8.2 Harbor安装"></a>8.2 Harbor安装</h3><p>这里采用原生的方式安装Harbor。</p><ul><li><p>下载Harbor安装包：<a href="https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz">https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz</a></p></li><li><p>拖拽到Linux并解压：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.3.4.tgz -C /usr/local/</span><br></pre></td></tr></table></figure></li><li><p>修改Harbor配置文件：</p><ul><li><p>首先复制一份harbor.yml配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.yml</span><br></pre></td></tr></table></figure></li><li><h2 id="编辑harbor-yml配置文件配置Harbor文件"><a href="#编辑harbor-yml配置文件配置Harbor文件" class="headerlink" title="编辑harbor.yml配置文件配置Harbor文件  "></a>编辑harbor.yml配置文件配置Harbor文件  </h2><h2 id="-17"><a href="#-17" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130215555218.png" alt="https://www.notion.soPictures/image-20211130215555218.png">  </h2></li></ul></li><li><h2 id="启动Harbor查看日志"><a href="#启动Harbor查看日志" class="headerlink" title="启动Harbor查看日志    "></a>启动Harbor查看日志<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>  </h2><h2 id="-18"><a href="#-18" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130215941857.png" alt="https://www.notion.soPictures/image-20211130215941857.png">  </h2></li><li><h2 id="登录Harbor登录Harbor"><a href="#登录Harbor登录Harbor" class="headerlink" title="登录Harbor登录Harbor  "></a>登录Harbor登录Harbor  </h2><h2 id="-19"><a href="#-19" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130220028840.png" alt="https://www.notion.soPictures/image-20211130220028840.png">  </h2></li><li><h2 id="首页信息首页信息"><a href="#首页信息首页信息" class="headerlink" title="首页信息首页信息  "></a>首页信息首页信息  </h2><h2 id="-20"><a href="#-20" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211130220111602.png" alt="https://www.notion.soPictures/image-20211130220111602.png">  </h2></li></ul><h3 id="8-3-Harbor使用方式"><a href="#8-3-Harbor使用方式" class="headerlink" title="8.3 Harbor使用方式"></a>8.3 Harbor使用方式</h3><p>Harbor作为镜像仓库，主要的交互方式就是将镜像上传到Harbor上，以及从Harbor上下载指定镜像</p><p>在传输镜像前，可以先使用Harbor提供的权限管理，将项目设置为私有项目，并对不同用户设置不同角色，从而更方便管理镜像。</p><h3 id="8-3-1-添加用户构建项目"><a href="#8-3-1-添加用户构建项目" class="headerlink" title="8.3.1 添加用户构建项目"></a>8.3.1 添加用户构建项目</h3><ul><li><h2 id="创建用户创建用户"><a href="#创建用户创建用户" class="headerlink" title="创建用户创建用户  "></a>创建用户创建用户  </h2><h2 id="-21"><a href="#-21" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213427157.png" alt="https://www.notion.soPictures/image-20211201213427157.png">  </h2></li><li><h2 id="构建项目（设置为私有）构建项目"><a href="#构建项目（设置为私有）构建项目" class="headerlink" title="构建项目（设置为私有）构建项目  "></a>构建项目（设置为私有）构建项目  </h2><h2 id="-22"><a href="#-22" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213751780.png" alt="https://www.notion.soPictures/image-20211201213751780.png">  </h2></li><li><h2 id="给项目追加用户追加用户管理"><a href="#给项目追加用户追加用户管理" class="headerlink" title="给项目追加用户追加用户管理  "></a>给项目追加用户追加用户管理  </h2><h2 id="-23"><a href="#-23" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201213832458.png" alt="https://www.notion.soPictures/image-20211201213832458.png">  </h2></li><li><h2 id="切换测试用户切换测试用户"><a href="#切换测试用户切换测试用户" class="headerlink" title="切换测试用户切换测试用户  "></a>切换测试用户切换测试用户  </h2><h2 id="-24"><a href="#-24" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201214008303.png" alt="https://www.notion.soPictures/image-20211201214008303.png">  </h2></li></ul><h3 id="8-3-2-发布镜像到Harbor"><a href="#8-3-2-发布镜像到Harbor" class="headerlink" title="8.3.2 发布镜像到Harbor"></a>8.3.2 发布镜像到Harbor</h3><ul><li><h2 id="修改镜像名称修改镜像名称-名称要求：harbor地址-项目名-镜像名-版本"><a href="#修改镜像名称修改镜像名称-名称要求：harbor地址-项目名-镜像名-版本" class="headerlink" title="修改镜像名称修改镜像名称  名称要求：harbor地址&#x2F;项目名&#x2F;镜像名:版本  "></a>修改镜像名称修改镜像名称<br><br>  名称要求：harbor地址&#x2F;项目名&#x2F;镜像名:版本  </h2><h2 id="-25"><a href="#-25" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221040200.png" alt="https://www.notion.soPictures/image-20211201221040200.png">  </h2></li><li><h2 id="修改daemon-json，支持Docker仓库，并重启Docker修改daemon-json，支持Docker仓库"><a href="#修改daemon-json，支持Docker仓库，并重启Docker修改daemon-json，支持Docker仓库" class="headerlink" title="修改daemon.json，支持Docker仓库，并重启Docker修改daemon.json，支持Docker仓库  "></a>修改daemon.json，支持Docker仓库，并重启Docker修改daemon.json，支持Docker仓库  </h2><h2 id="-26"><a href="#-26" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201215931237.png" alt="https://www.notion.soPictures/image-20211201215931237.png">  </h2></li><li><p>设置登录仓库信息</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码 Harbor地址</span><br></pre></td></tr></table></figure></li><li><h2 id="推送镜像到Harbor推送镜像到Harbor"><a href="#推送镜像到Harbor推送镜像到Harbor" class="headerlink" title="推送镜像到Harbor推送镜像到Harbor  "></a>推送镜像到Harbor推送镜像到Harbor  </h2><h2 id="-27"><a href="#-27" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221225196.png" alt="https://www.notion.soPictures/image-20211201221225196.png">  </h2><h2 id="-28"><a href="#-28" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211201221300055.png" alt="https://www.notion.soPictures/image-20211201221300055.png">  </h2></li></ul><h3 id="8-3-3-从Harbor拉取镜像ls"><a href="#8-3-3-从Harbor拉取镜像ls" class="headerlink" title="8.3.3 从Harbor拉取镜像ls"></a>8.3.3 从Harbor拉取镜像ls</h3><p>跟传统方式一样，不过需要先配置&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>        <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://pee6w651.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>        <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.11.11:80&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>拉取镜像</p><hr><p><img src="https://www.notion.sopictures/image-20211201222450091.png" alt="https://www.notion.soPictures/image-20211201222450091.png"></p><hr><h3 id="8-3-4-Jenkins容器使用宿主机Docker"><a href="#8-3-4-Jenkins容器使用宿主机Docker" class="headerlink" title="8.3.4 Jenkins容器使用宿主机Docker"></a>8.3.4 Jenkins容器使用宿主机Docker</h3><p>构建镜像和发布镜像到harbor都需要使用到docker命令。而在Jenkins容器内部安装Docker官方推荐直接采用宿主机带的Docker即可。</p><p>设置Jenkins容器使用宿主机Docker</p><ul><li><p>设置宿主机docker.sock权限：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root:root /var/run/docker.socksudo chmod o+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure></li><li><p>添加数据卷</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;services:  jenkins:    image: jenkins/jenkins    container_name: jenkins    ports:      - 8080:8080      - 50000:50000    volumes:      - ./data/:/var/jenkins_home/      - /usr/bin/docker:/usr/bin/docker      - /var/run/docker.sock:/var/run/docker.sock      - /etc/docker/daemon.json:/etc/docker/daemon.json</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-5-添加构建操作"><a href="#8-3-5-添加构建操作" class="headerlink" title="8.3.5 添加构建操作"></a>8.3.5 添加构建操作</h3><p>制作自定义镜像</p><hr><p><img src="https://www.notion.sopictures/image-20211229155834500.png" alt="https://www.notion.soPictures/image-20211229155834500.png"></p><hr><h3 id="8-3-6-编写部署脚本"><a href="#8-3-6-编写部署脚本" class="headerlink" title="8.3.6 编写部署脚本"></a>8.3.6 编写部署脚本</h3><p>部署项目需要通过Publish Over SSH插件，让目标服务器执行命令。为了方便一次性实现拉取镜像和启动的命令，推荐采用脚本文件的方式。</p><p>添加脚本文件到目标服务器，再通过Publish Over SSH插件让目标服务器执行脚本即可。</p><ul><li><h2 id="编写脚本文件，添加到目标服务器如图-并设置权限为可执行"><a href="#编写脚本文件，添加到目标服务器如图-并设置权限为可执行" class="headerlink" title="编写脚本文件，添加到目标服务器如图    并设置权限为可执行    "></a>编写脚本文件，添加到目标服务器如图<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">harbor_url=$1harbor_project_name=$2project_name=$3tag=$4port=$5imageName=$harbor_url/$harbor_project_name/$project_name:$tagcontainerId=`docker ps -a | grep $&#123;project_name&#125; | awk &#x27;&#123;print $1&#125;&#x27;`if [ &quot;$containerId&quot; != &quot;&quot; ] ; then    docker stop $containerId    docker rm $containerId    echo &quot;Delete Container Success&quot;fiimageId=`docker images | grep $&#123;project_name&#125; | awk &#x27;&#123;print $3&#125;&#x27;`if [ &quot;$imageId&quot; != &quot;&quot; ] ; then    docker rmi -f $imageId    echo &quot;Delete Image Success&quot;fidocker login -u DevOps -p P@ssw0rd $harbor_urldocker pull $imageNamedocker run -d -p $port:$port --name $project_name $imageNameecho &quot;Start Container Success&quot;echo $project_name</span><br></pre></td></tr></table></figure><br><br>  并设置权限为可执行<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x deploy.sh</span><br></pre></td></tr></table></figure>  </h2><h2 id="-29"><a href="#-29" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211203192047357.png" alt="https://www.notion.soPictures/image-20211203192047357.png">  </h2></li></ul><h3 id="8-3-7-配置构建后操作"><a href="#8-3-7-配置构建后操作" class="headerlink" title="8.3.7 配置构建后操作"></a>8.3.7 配置构建后操作</h3><p>执行脚本文件</p><hr><p><img src="https://www.notion.sopictures/image-20211229155949038.png" alt="https://www.notion.soPictures/image-20211229155949038.png"></p><hr><h3 id="九、Jenkins流水线"><a href="#九、Jenkins流水线" class="headerlink" title="九、Jenkins流水线"></a>九、Jenkins流水线</h3><h3 id="9-1-Jenkins流水线任务介绍"><a href="#9-1-Jenkins流水线任务介绍" class="headerlink" title="9.1 Jenkins流水线任务介绍"></a>9.1 Jenkins流水线任务介绍</h3><p>之前采用Jenkins的自由风格构建的项目，每个步骤流程都要通过不同的方式设置，并且构建过程中整体流程是不可见的，无法确认每个流程花费的时间，并且问题不方便定位问题。</p><p>Jenkins的Pipeline可以让项目的发布整体流程可视化，明确执行的阶段，可以快速的定位问题。并且整个项目的生命周期可以通过一个Jenkinsfile文件管理，而且Jenkinsfile文件是可以放在项目中维护。</p><p>所以Pipeline相对自由风格或者其他的项目风格更容易操作。</p><h3 id="9-2-Jenkins流水线任务"><a href="#9-2-Jenkins流水线任务" class="headerlink" title="9.2 Jenkins流水线任务"></a>9.2 Jenkins流水线任务</h3><h3 id="9-2-1-构建Jenkins流水线任务"><a href="#9-2-1-构建Jenkins流水线任务" class="headerlink" title="9.2.1 构建Jenkins流水线任务"></a>9.2.1 构建Jenkins流水线任务</h3><ul><li><h2 id="构建任务构建Jenkins流水线任务"><a href="#构建任务构建Jenkins流水线任务" class="headerlink" title="构建任务构建Jenkins流水线任务  "></a>构建任务构建Jenkins流水线任务  </h2><h2 id="-30"><a href="#-30" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144429302.png" alt="https://www.notion.soPictures/image-20211202144429302.png">  </h2></li><li><h2 id="生成Groovy脚本Hello-World脚本生成"><a href="#生成Groovy脚本Hello-World脚本生成" class="headerlink" title="生成Groovy脚本Hello World脚本生成  "></a>生成Groovy脚本Hello World脚本生成  </h2><h2 id="-31"><a href="#-31" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144531749.png" alt="https://www.notion.soPictures/image-20211202144531749.png">  </h2></li><li><h2 id="构建后查看视图构建后查看视图"><a href="#构建后查看视图构建后查看视图" class="headerlink" title="构建后查看视图构建后查看视图  "></a>构建后查看视图构建后查看视图  </h2><h2 id="-32"><a href="#-32" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202144616117.png" alt="https://www.notion.soPictures/image-20211202144616117.png">  </h2></li></ul><h3 id="9-2-2-Groovy脚本"><a href="#9-2-2-Groovy脚本" class="headerlink" title="9.2.2 Groovy脚本"></a>9.2.2 Groovy脚本</h3><ul><li><p>Groovy脚本基础语法</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 所有脚本命令包含在pipeline&#123;&#125;中pipeline &#123;  // 指定任务在哪个节点执行（Jenkins支持分布式）    agent any    // 配置全局环境，指定变量名=变量值信息    environment&#123;      host = &#x27;192.168.11.11&#x27;    &#125;    // 存放所有任务的合集    stages &#123;      // 单个任务        stage(&#x27;任务1&#x27;) &#123;          // 实现任务的具体流程            steps &#123;                echo &#x27;do something&#x27;            &#125;        &#125;      // 单个任务        stage(&#x27;任务2&#x27;) &#123;          // 实现任务的具体流程            steps &#123;                echo &#x27;do something&#x27;            &#125;        &#125;        // ……    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="编写例子测试配置Grovvy脚本"><a href="#编写例子测试配置Grovvy脚本" class="headerlink" title="编写例子测试配置Grovvy脚本    "></a>编写例子测试配置Grovvy脚本<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                echo &#x27;拉取Git代码&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                echo &#x27;检测代码质量&#x27;            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                echo &#x27;构建代码&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                echo &#x27;制作自定义镜像并发布Harbor&#x27;            &#125;        &#125;        stage(&#x27;基于Harbor部署工程&#x27;) &#123;            steps &#123;                echo &#x27;基于Harbor部署工程&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>  </h2><h2 id="-33"><a href="#-33" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202145155428.png" alt="https://www.notion.soPictures/image-20211202145155428.png">  </h2></li><li><h2 id="查看效果查看效果"><a href="#查看效果查看效果" class="headerlink" title="查看效果查看效果  "></a>查看效果查看效果  </h2><h2 id="-34"><a href="#-34" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202145240166.png" alt="https://www.notion.soPictures/image-20211202145240166.png">  </h2></li></ul><p>Ps：涉及到特定脚本，Jenkins给予了充足的提示，可以自动生成命令</p><p>生成命令位置</p><hr><p><img src="https://www.notion.sopictures/image-20211202145349043.png" alt="https://www.notion.soPictures/image-20211202145349043.png"></p><hr><h3 id="9-2-3-Jenkinsfile实现"><a href="#9-2-3-Jenkinsfile实现" class="headerlink" title="9.2.3 Jenkinsfile实现"></a>9.2.3 Jenkinsfile实现</h3><p>Jenkinsfile方式需要将脚本内容编写到项目中的Jenkinsfile文件中，每次构建会自动拉取项目并且获取项目中Jenkinsfile文件对项目进行构建</p><ul><li><h2 id="配置pipeline配置pipeline"><a href="#配置pipeline配置pipeline" class="headerlink" title="配置pipeline配置pipeline  "></a>配置pipeline配置pipeline  </h2><h2 id="-35"><a href="#-35" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151127254.png" alt="https://www.notion.soPictures/image-20211202151127254.png">  </h2></li><li><h2 id="准备Jenkinsfile准备Jenkinsfile文件"><a href="#准备Jenkinsfile准备Jenkinsfile文件" class="headerlink" title="准备Jenkinsfile准备Jenkinsfile文件  "></a>准备Jenkinsfile准备Jenkinsfile文件  </h2><h2 id="-36"><a href="#-36" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151155145.png" alt="https://www.notion.soPictures/image-20211202151155145.png">  </h2></li><li><h2 id="测试效果测试效果"><a href="#测试效果测试效果" class="headerlink" title="测试效果测试效果  "></a>测试效果测试效果  </h2><h2 id="-37"><a href="#-37" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211202151225161.png" alt="https://www.notion.soPictures/image-20211202151225161.png">  </h2></li></ul><h3 id="9-3-Jenkins流水线任务实现"><a href="#9-3-Jenkins流水线任务实现" class="headerlink" title="9.3 Jenkins流水线任务实现"></a>9.3 Jenkins流水线任务实现</h3><h3 id="9-3-1-参数化构建"><a href="#9-3-1-参数化构建" class="headerlink" title="9.3.1 参数化构建"></a>9.3.1 参数化构建</h3><p>添加参数化构建，方便选择不的项目版本</p><p>Git参数化构建</p><hr><p><img src="https://www.notion.sopictures/image-20211202191944277.png" alt="https://www.notion.soPictures/image-20211202191944277.png"></p><hr><h3 id="9-3-2-拉取Git代码"><a href="#9-3-2-拉取Git代码" class="headerlink" title="9.3.2 拉取Git代码"></a>9.3.2 拉取Git代码</h3><p>通过流水线语法生成Checkout代码的脚本</p><p>语法生成</p><hr><p><img src="https://www.notion.sopictures/image-20211202192047619.png" alt="https://www.notion.soPictures/image-20211202192047619.png"></p><hr><p><img src="https://www.notion.sopictures/image-20211202192129895.png" alt="https://www.notion.soPictures/image-20211202192129895.png"></p><p>将*&#x2F;master更改为标签</p><p>${tag}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-3-构建代码"><a href="#9-3-3-构建代码" class="headerlink" title="9.3.3 构建代码"></a>9.3.3 构建代码</h3><p>通过脚本执行mvn的构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-4-代码质量检测"><a href="#9-3-4-代码质量检测" class="headerlink" title="9.3.4 代码质量检测"></a>9.3.4 代码质量检测</h3><p>通过脚本执行sonar-scanner命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-5-制作自定义镜像并发布"><a href="#9-3-5-制作自定义镜像并发布" class="headerlink" title="9.3.5 制作自定义镜像并发布"></a>9.3.5 制作自定义镜像并发布</h3><ul><li><p>生成自定义镜像脚本</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment&#123;        harborHost = &#x27;192.168.11.11:80&#x27;        harborRepo = &#x27;repository&#x27;        harborUser = &#x27;DevOps&#x27;        harborPasswd = &#x27;P@ssw0rd&#x27;    &#125;    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;cp ./target/*.jar ./docker/                cd ./docker                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./&#x27;&#x27;&#x27;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;&#x27;&#x27;&#x27;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成Publish Over SSH脚本</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment&#123;        harborHost = &#x27;192.168.11.11:80&#x27;        harborRepo = &#x27;repository&#x27;        harborUser = &#x27;DevOps&#x27;        harborPasswd = &#x27;P@ssw0rd&#x27;    &#125;    // 存放所有任务的合集    stages &#123;        stage(&#x27;拉取Git代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;tag&#125;&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/test.git&#x27;]]])            &#125;        &#125;        stage(&#x27;构建代码&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;docker        stage(&#x27;检测代码质量&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=7d66af4b39cfe4f52ac0a915d4c9d5c513207098&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像并发布Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;cp ./target/*.jar ./docker/                cd ./docker                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./&#x27;&#x27;&#x27;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;目标服务器拉取镜像并运行&#x27;) &#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;testEnvironment&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &quot;/usr/bin/deploy.sh $harborHost $harborRepo $JOB_NAME $tag $port &quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Ps：由于采用变量，记得使用双引号</p><h3 id="9-4-Jenkins流水线整合钉钉"><a href="#9-4-Jenkins流水线整合钉钉" class="headerlink" title="9.4 Jenkins流水线整合钉钉"></a>9.4 Jenkins流水线整合钉钉</h3><p>在程序部署成功后，可以通过钉钉的机器人及时向群众发送部署的最终结果通知</p><ul><li><h2 id="安装插件安装插件"><a href="#安装插件安装插件" class="headerlink" title="安装插件安装插件  "></a>安装插件安装插件  </h2><h2 id="-38"><a href="#-38" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209151549412.png" alt="https://www.notion.soPictures/image-20211209151549412.png">  </h2></li><li><h2 id="钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人"><a href="#钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人" class="headerlink" title="钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人  "></a>钉钉内部创建群组并构建机器人钉钉内部创建群组并构建机器人  </h2><h2 id="-39"><a href="#-39" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152217433.png" alt="https://www.notion.soPictures/image-20211209152217433.png">  </h2><h2 id="-40"><a href="#-40" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152252050.png" alt="https://www.notion.soPictures/image-20211209152252050.png">  </h2><h2 id="-41"><a href="#-41" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209152403312.png" alt="https://www.notion.soPictures/image-20211209152403312.png">  </h2><p>  最终或获取到Webhook信息</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://oapi.dingtalk.com/robot/send?access_token=kej4ehkj34gjhg34jh5bh5jb34hj53b4</span><br></pre></td></tr></table></figure></li><li><h2 id="系统配置添加钉钉通知配置钉钉通知"><a href="#系统配置添加钉钉通知配置钉钉通知" class="headerlink" title="系统配置添加钉钉通知配置钉钉通知  "></a>系统配置添加钉钉通知配置钉钉通知  </h2><h2 id="-42"><a href="#-42" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209162923440.png" alt="https://www.notion.soPictures/image-20211209162923440.png">  </h2></li><li><p>任务中追加流水线配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;    agent any    environment &#123;        sonarLogin = &#x27;2bab7bf7d5af25e2c2ca2f178af2c3c55c64d5d8&#x27;        harborUser = &#x27;admin&#x27;        harborPassword = &#x27;Harbor12345&#x27;        harborHost = &#x27;192.168.11.12:8888&#x27;        harborRepo = &#x27;repository&#x27;    &#125;    stages &#123;        stage(&#x27;拉取Git代码&#x27;)&#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$tag&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://49.233.115.171:8929/root/lsx.git&#x27;]]])            &#125;        &#125;        stage(&#x27;Maven构建代码&#x27;)&#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;SonarQube检测代码&#x27;)&#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=$&#123;sonarLogin&#125;&#x27;            &#125;        &#125;        stage(&#x27;制作自定义镜像&#x27;)&#123;            steps &#123;                sh &#x27;&#x27;&#x27;cd docker                mv ../target/*.jar ./                docker build -t $&#123;JOB_NAME&#125;:$tag .                &#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;推送自定义镜像&#x27;)&#123;            steps &#123;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPassword&#125; $&#123;harborHost&#125;                docker tag $&#123;JOB_NAME&#125;:$tag $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;通知目标服务器&#x27;)&#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;centos-docker&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &quot;/usr/bin/deploy.sh $harborHost $harborRepo $JOB_NAME $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;    &#125;    post &#123;        success &#123;            dingtalk (                robot: &#x27;Jenkins-DingDing&#x27;,                type:&#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 成功构建:$&#123;JOB_NAME&#125;项目!\n- 版本:$&#123;tag&#125;\n- 持续时间:$&#123;currentBuild.durationString&#125;\n- 任务:#$&#123;JOB_NAME&#125;&quot;]            )        &#125;        failure &#123;            dingtalk (                robot: &#x27;Jenkins-DingDing&#x27;,                type:&#x27;MARKDOWN&#x27;,                title: &quot;fail: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 失败构建:$&#123;JOB_NAME&#125;项目!\n- 版本:$&#123;tag&#125;\n- 持续时间:$&#123;currentBuild.durationString&#125;\n- 任务:#$&#123;JOB_NAME&#125;&quot;]            )        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="查看效果钉钉通知效果"><a href="#查看效果钉钉通知效果" class="headerlink" title="查看效果钉钉通知效果  "></a>查看效果钉钉通知效果  </h2><h2 id="-43"><a href="#-43" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211209163021396.png" alt="https://www.notion.soPictures/image-20211209163021396.png">  </h2></li></ul><p>###十、Kubernetes编排工具</p><h3 id="10-1-Kubernetes介绍"><a href="#10-1-Kubernetes介绍" class="headerlink" title="10.1 Kubernetes介绍"></a>10.1 Kubernetes介绍</h3><p>Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。</p><p>Kubernetes主要能帮助我们完成：</p><ul><li><p>服务发现和负载均衡</p><p>  Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p>存储编排</p><p>  Kubernetes 允许你自动挂载你选择的存储系统，比如本地存储，类似Docker的数据卷。</p></li><li><p>自动部署和回滚</p><p>  你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。Kubernetes 会自动帮你根据情况部署创建新容器，并删除现有容器给新容器提供资源。</p></li><li><p>自动完成装箱计算</p><p>  Kubernetes 允许你设置每个容器的资源，比如CPU和内存。</p></li><li><p>自我修复</p><p>  Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的容器，并运行状况检查的容器。</p></li><li><p>秘钥与配置管理</p><p>  Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h3 id="10-2-Kubernetes架构"><a href="#10-2-Kubernetes架构" class="headerlink" title="10.2 Kubernetes架构"></a>10.2 Kubernetes架构</h3><p>Kubernetes 搭建需要至少两个节点，一个Master负责管理，一个Slave搭建在工作服务器上负责分配。</p><p>kubernetes架构</p><hr><p><img src="https://www.notion.sopictures/image-20211210114507638.png" alt="https://www.notion.soPictures/image-20211210114507638.png"></p><hr><p>从图中可以看到各个组件的基本功能：</p><ul><li>API Server：作为K8s通讯的核心组件，K8s内部交互以及接收发送指令的组件。</li><li>controller-manager：作为K8s的核心组件，主要做资源调度，根据集群情况分配资源</li><li>etcd：一个key-value的数据库，存储存储集群的状态信息</li><li>scheduler：负责调度每个工作节点</li><li>cloud-controller-manager：负责调度其他云服务产品</li><li>kubelet：管理Pods上面的容器。</li><li>kube-proxy：负责处理其他Slave或客户端的请求。</li><li>Pod：可以理解为就是运行的容器</li></ul><h3 id="10-3-Kubernetes安装"><a href="#10-3-Kubernetes安装" class="headerlink" title="10.3 Kubernetes安装"></a>10.3 Kubernetes安装</h3><p>这里会采用<a href="https://kuboard.cn/%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85K8s%EF%BC%8C%E5%AE%89%E8%A3%85%E5%8D%95Master%E8%8A%82%E7%82%B9">https://kuboard.cn/提供的方式安装K8s，安装单Master节点</a></p><ul><li>要求使用Centos7.8版本：<a href="https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso">https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso</a></li><li>至少2台 <strong>2核4G</strong> 的服务器</li></ul><p>安装流程</p><p>安装流程</p><hr><p><img src="https://www.notion.sopictures/image-20211210190653687.png" alt="https://www.notion.soPictures/image-20211210190653687.png"></p><hr><p>准备好服务器后开始安装</p><ul><li><p>重新设置hostname，不允许为localhost</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 修改 hostname，名字不允许使用下划线、小数点、大写字母，不能叫masterhostnamectl set-hostname your-new-host-name# 查看修改结果hostnamectl status# 设置 hostname 解析echo &quot;127.0.0.1   $(hostname)&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>要求2台服务之间可以相互通讯</p></li><li><p>安装软件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 阿里云 docker hub 镜像export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.comcurl -sSL https://kuboard.cn/install-script/v1.19.x/install_kubelet.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure></li></ul><p>首先初始化Master节点</p><blockquote><p>关于初始化时用到的环境变量</p><ul><li><strong>APISERVER_NAME</strong> 不能是 master 的 hostname</li><li><strong>APISERVER_NAME</strong> 必须全为小写字母、数字、小数点，不能包含减号</li><li><strong>POD_SUBNET</strong> 所使用的网段不能与 <em><strong>master节点&#x2F;worker节点</strong></em> 所在的网段重叠。该字段的取值为一个 <a href="https://kuboard.cn/glossary/cidr.html">CIDR</a> 值，如果您对 CIDR 这个概念还不熟悉，请仍然执行 export POD_SUBNET&#x3D;10.100.0.0&#x2F;16 命令，不做修改</li></ul></blockquote><ul><li><p>设置ip，域名，网段并执行初始化操作</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行# 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令export MASTER_IP=192.168.11.32# 替换 apiserver.demo 为 您想要的 dnsNameexport APISERVER_NAME=apiserver.demo# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中export POD_SUBNET=10.100.0.1/16echo &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hostscurl -sSL https://kuboard.cn/install-script/v1.19.x/init_master.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure></li><li><p>检查Master启动状态</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态watch kubectl get pod -n kube-system -o wide# 查看 master 节点初始化结果kubectl get nodes -o wide</span><br></pre></td></tr></table></figure></li></ul><p><code>Ps：如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;EOFmkdir /usr/share/oci-umount/oci-umount.d -pmkdir /run/flannel/cat &lt;&lt;EOF&gt; /run/flannel/subnet.envFLANNEL_NETWORK=172.100.0.0/16FLANNEL_SUBNET=172.100.1.0/24FLANNEL_MTU=1450FLANNEL_IPMASQ=trueEOFkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>安装网络服务插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export POD_SUBNET=10.100.0.0/16kubectl apply -f https://kuboard.cn/install-script/v1.22.x/calico-operator.yamlwget https://kuboard.cn/install-script/v1.22.x/calico-custom-resources.yamlsed -i &quot;s#192.168.0.0/16#$&#123;POD_SUBNET&#125;#&quot; calico-custom-resources.yamlkubectl apply -f calico-custom-resources.yaml</span><br></pre></td></tr></table></figure><p>初始化worker节点</p><ul><li><h2 id="获取Join命令参数，在Master节点执行获取命令"><a href="#获取Join命令参数，在Master节点执行获取命令" class="headerlink" title="获取Join命令参数，在Master节点执行获取命令    "></a>获取Join命令参数，在Master节点执行获取命令<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>  </h2><h2 id="-44"><a href="#-44" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213183025291.png" alt="https://www.notion.soPictures/image-20211213183025291.png">  </h2></li><li><p>在worker节点初始化</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 worker 节点执行# 替换 x.x.x.x 为 master 节点的内网 IPexport MASTER_IP=192.168.11.32# 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAMEexport APISERVER_NAME=apiserver.demoecho &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hosts# 替换为 master 节点上 kubeadm token create 命令的输出kubeadm join apiserver.demo:6443 --token vwfilu.3nhndohc5gn1jv9k     --discovery-token-ca-cert-hash sha256:22ff15cabfe87ab48a7db39b3bbf986fee92ec92eb8efc7fe9b0abe2175ff0c2</span><br></pre></td></tr></table></figure></li></ul><p>检查最终运行效果</p><ul><li><p>在 master 节点上执行</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只在 master 节点执行kubectl get nodes -o wide</span><br></pre></td></tr></table></figure></li></ul><p><code>Ps：如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;EOFmkdir /usr/share/oci-umount/oci-umount.d -pmkdir /run/flannel/cat &lt;&lt;EOF&gt; /run/flannel/subnet.envFLANNEL_NETWORK=172.100.0.0/16FLANNEL_SUBNET=172.100.1.0/24FLANNEL_MTU=1450FLANNEL_IPMASQ=trueEOFkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li><h2 id="输出结果如下所示：搭建成功效果"><a href="#输出结果如下所示：搭建成功效果" class="headerlink" title="输出结果如下所示：搭建成功效果    "></a>输出结果如下所示：搭建成功效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8smaster ~]# kubectl get nodes</span><br></pre></td></tr></table></figure>  </h2><h2 id="-45"><a href="#-45" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211210184851810.png" alt="https://www.notion.soPictures/image-20211210184851810.png">  </h2></li></ul><p>安装Kuboard管理K8s集群</p><ul><li><p>安装Kuboard</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml# 您也可以使用下面的指令，唯一的区别是，该指令使用华为云的镜像仓库替代 docker hub 分发 Kuboard 所需要的镜像# kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml</span><br></pre></td></tr></table></figure></li><li><h2 id="查看启动情况查看效果"><a href="#查看启动情况查看效果" class="headerlink" title="查看启动情况查看效果    "></a>查看启动情况查看效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch kubectl get pods -n kuboard</span><br></pre></td></tr></table></figure>  </h2><h2 id="-46"><a href="#-46" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184701784.png" alt="https://www.notion.soPictures/image-20211213184701784.png">  </h2></li><li><h2 id="在浏览器中打开链接-http-your-node-ip-address-30080首页"><a href="#在浏览器中打开链接-http-your-node-ip-address-30080首页" class="headerlink" title="在浏览器中打开链接 http://your-node-ip-address:30080首页  "></a>在浏览器中打开链接 <a href="http://your-node-ip-address:30080首页">http://your-node-ip-address:30080首页</a>  </h2><h2 id="-47"><a href="#-47" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184742709.png" alt="https://www.notion.soPictures/image-20211213184742709.png">  </h2></li><li><h2 id="输入初始用户名和密码，并登录首页效果-用户名：-admin-密码：-Kuboard123"><a href="#输入初始用户名和密码，并登录首页效果-用户名：-admin-密码：-Kuboard123" class="headerlink" title="输入初始用户名和密码，并登录首页效果  - 用户名： admin  - 密码： Kuboard123  "></a>输入初始用户名和密码，并登录首页效果<br>  - 用户名： <code>admin</code><br>  - 密码： <code>Kuboard123</code>  </h2><h2 id="-48"><a href="#-48" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20211213184840120.png" alt="https://www.notion.soPictures/image-20211213184840120.png">  </h2></li></ul><h3 id="10-4-Kubernetes操作"><a href="#10-4-Kubernetes操作" class="headerlink" title="10.4 Kubernetes操作"></a>10.4 Kubernetes操作</h3><p>首先我们要了解Kubernetes在运行我们的资源时，关联到了哪些内容</p><ul><li>资源的构建方式：<ul><li>采用kubectl的命令方式</li><li>yaml文件方式</li></ul></li></ul><h3 id="10-4-1-Namespace"><a href="#10-4-1-Namespace" class="headerlink" title="10.4.1 Namespace"></a>10.4.1 Namespace</h3><ul><li><p>命名空间：主要是为了对Kubernetes中运行的资源进行过隔离， 但是网络是互通的，类似Docker的容器，可以将多个资源配置到一个NameSpace中。而NameSpace可以对不同环境进行资源隔离，默认情况下Kubernetes提供了default命名空间，在构建资源时，如果不指定资源，默认采用default资源。 命令方式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查看现有的全部命名空间kubectl get ns# 构建命名空间kubectl create ns 命名空间名称# 删除现有命名空间， 并且会删除空间下的全部资源kubectl delete ns 命名空间名称</span><br></pre></td></tr></table></figure><p>  yaml文件方式：（构建资源时，设置命名空间）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Namespacemetadata:  name:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-2-Pod"><a href="#10-4-2-Pod" class="headerlink" title="10.4.2 Pod"></a>10.4.2 Pod</h3><ul><li>Pod：Kubernetes运行的一组容器，Pod是Kubernetes的最小单位，但是对于Docker而然，Pod中会运行多个Docker容器<ul><li><p>命令方式：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有运行的podkubectl get pods -A# 查看指定Namespace下的Podkubectl get pod [-n 命名空间]  #（默认default）# 创建Podkubectl run pod名称 --image=镜像名称# 查看Pod详细信息kubectl describe pod pod名称# 删除podkubectl delete pod pod名称 [-n 命名空间]  #（默认default）# 查看pod输出的日志kubectl logs -f pod名称# 进去pod容器内部kubectl exec -it pod名称 -- bash# 查看kubernetes给Pod分配的ip信息，并且通过ip和容器的端口，可以直接访问kubectl get pod -owide</span></span><br></pre></td></tr></table></figure></li><li><p>yaml方式（推荐）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Podmetadata:  labels:    run:</span> <span class="string">运行的pod名称</span>  <span class="attr">name:</span> <span class="string">pod名称</span>  <span class="attr">namespace:</span> <span class="string">命名空间spec:</span>  <span class="attr">containers:  - image:</span> <span class="string">镜像名称</span>    <span class="attr">name:</span> <span class="string">容器名称#</span> <span class="string">启动Pod：kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">yaml文件名称#</span> <span class="string">删除Pod：kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">yaml文件名称</span></span><br></pre></td></tr></table></figure></li><li><h2 id="Pod中运行多个容器Kuboard效果-启动后可以查看到"><a href="#Pod中运行多个容器Kuboard效果-启动后可以查看到" class="headerlink" title="Pod中运行多个容器Kuboard效果    启动后可以查看到  "></a>Pod中运行多个容器Kuboard效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1kind: Podmetadata:  labels:    run: 运行的pod名称  name: pod名称  namespace: 命名空间spec:  containers:  - image: 镜像名称    name: 容器名称  - image: 镜像名称    name: 容器名称…………</span><br></pre></td></tr></table></figure><br><br>  启动后可以查看到  </h2><h2 id="-49"><a href="#-49" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104203155749.png" alt="https://www.notion.soPictures/image-20220104203155749.png">  </h2></li></ul></li></ul><h3 id="10-4-3-Deployment"><a href="#10-4-3-Deployment" class="headerlink" title="10.4.3 Deployment"></a>10.4.3 Deployment</h3><p>部署时，可以通过Deployment管理和编排Pod</p><p>Deployment部署实现</p><ul><li><p>命令方式</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 基于Deployment启动容器kubectl create deployment deployment名称 --image=镜像名称# 用deployment启动的容器会在被删除后自动再次创建，达到故障漂移的效果# 需要使用deploy的方式删除deploy# 查看现在的deploymentkubectl get deployment# 删除deploymentkubectl delete deployment deployment名称# 基于Deployment启动容器并设置Pod集群数kubectl create deployment deployment名称 --image=镜像名称 --replicas 集群个数</span><br></pre></td></tr></table></figure></li><li><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">配置文件方式</a></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx       image: nginx       ports:       - containerPort: 80</span><br></pre></td></tr></table></figure><p>  正常使用kubectl运行yaml即可</p></li></ul><p>弹性伸缩功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 基于scale实现弹性伸缩kubectl scale deploy/Deployment名称 --replicas 集群个数# 或者修改yaml文件kubectl edit deploy Deployment名称</span><br></pre></td></tr></table></figure><p>图形化页面修改</p><hr><p><img src="https://www.notion.sopictures/image-20220104210823057.png" alt="https://www.notion.soPictures/image-20220104210823057.png"></p><hr><p>灰度发布</p><p>Deploy可以在部署新版本数据时，成功启动一个pod，才会下线一个老版本的Pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/Deployment名称 容器名=镜像:版本</span><br></pre></td></tr></table></figure><h3 id="10-4-4-Service"><a href="#10-4-4-Service" class="headerlink" title="10.4.4 Service"></a>10.4.4 Service</h3><p>可以将多个Pod对外暴露一个Service，让客户端可以通过Service访问到这一组Pod，并且可以实现负载均衡</p><p>ClusterIP方式：</p><p>ClusterIP是集群内部Pod之间的访问方式</p><ul><li><h2 id="命令实现效果kubectl-get-service在服务容器内执行-之后通过kubectl-get-service查看Service提供的ip，即可访问"><a href="#命令实现效果kubectl-get-service在服务容器内执行-之后通过kubectl-get-service查看Service提供的ip，即可访问" class="headerlink" title="命令实现效果kubectl get service在服务容器内执行    之后通过kubectl get service查看Service提供的ip，即可访问  "></a>命令实现效果kubectl get service在服务容器内执行<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口</span><br></pre></td></tr></table></figure><br><br>  之后通过<code>kubectl get service</code>查看Service提供的ip，即可访问  </h2><h2 id="-50"><a href="#-50" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104214659229.png" alt="https://www.notion.soPictures/image-20220104214659229.png">  </h2><h2 id="也可以通过Deployment名称-namespace名称-svc作为域名访问"><a href="#也可以通过Deployment名称-namespace名称-svc作为域名访问" class="headerlink" title="  也可以通过Deployment名称.namespace名称.svc作为域名访问  "></a>  也可以通过<code>Deployment名称.namespace名称.svc</code>作为域名访问  </h2><h2 id="-51"><a href="#-51" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104215030265.png" alt="https://www.notion.soPictures/image-20220104215030265.png">  </h2></li></ul><p>NodePort方式</p><p>ClusterIP的方式只能在Pod内部实现访问，但是一般需要对外暴露网关，所以需要NodePort的方式Pod外暴露访问</p><ul><li><h2 id="命令实现方式查看Service效果"><a href="#命令实现方式查看Service效果" class="headerlink" title="命令实现方式查看Service效果    "></a>命令实现方式查看Service效果<br><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口 --type=NodePort</span><br></pre></td></tr></table></figure>  </h2><h2 id="-52"><a href="#-52" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104222750733.png" alt="https://www.notion.soPictures/image-20220104222750733.png">  </h2><h2 id="-53"><a href="#-53" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/image-20220104222819455.png" alt="https://www.notion.soPictures/image-20220104222819455.png">  </h2></li></ul><p>Service也可以通过yaml文件实现</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1kind: Servicemetadata:  labels    app: nginx  name: nginx  spec:    selector:      app: nginx    ports:    - port: 8888     protocol: TCP     targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>通过apply启动就也可以创建Service</p><p>测试效果-Deployment部署，通过Service暴露</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginx-deploymentspec:  replicas: 2  selector:    matchLabels:      app: nginx-deployment  template:    metadata:      labels:        app: nginx-deployment    spec:      containers:      - name: nginx-deployment        image: nginx        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  labels:    app: nginx-service  name: nginx-servicespec:  selector:    app: nginx-deployment  ports:  - port: 8888    protocol: TCP    targetPort: 80  type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>可以查看到暴露的信息</p><p>Service信息</p><hr><p><img src="https://www.notion.sopictures/image-20220105205334996.png" alt="https://www.notion.soPictures/image-20220105205334996.png"></p><hr><h3 id="10-4-5-Ingress"><a href="#10-4-5-Ingress" class="headerlink" title="10.4.5 Ingress"></a>10.4.5 Ingress</h3><p>Kubernetes推荐将Ingress作为所有Service的入口，提供统一的入口，避免多个服务之间需要记录大量的IP或者域名，毕竟IP可能改变，服务太多域名记录不方便。</p><p>Ingress底层其实就是一个Nginx， 可以在Kuboard上直接点击安装</p><p>Kuboard安装</p><hr><p><img src="https://www.notion.sopictures/image-20220105153343642.png" alt="https://www.notion.soPictures/image-20220105153343642.png"></p><hr><p><img src="https://www.notion.sopictures/image-20220105153416367.png" alt="https://www.notion.soPictures/image-20220105153416367.png"></p><hr><p>因为副本数默认为1，但是k8s整体集群就2个节点，所以显示下面即为安装成功</p><p>安装成功</p><hr><p><img src="https://www.notion.sopictures/image-20220105153502619.png" alt="https://www.notion.soPictures/image-20220105153502619.png"></p><hr><p>可以将Ingress接收到的请求转发到不同的Service中。</p><p>推荐使用yaml文件方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: nginx-ingressspec:  ingressClassName: ingress  rules:  - host: nginx.mashibing.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: nginx-service            port:              number:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>启动时问题</p><hr><p><img src="https://www.notion.sopictures/image-20220105203819715.png" alt="https://www.notion.soPictures/image-20220105203819715.png"></p><hr><p>Kuboard安装的Ingress有admission的校验配置，需要先删除配置再启动</p><p>找到指定的ingress的校验信息，删除即可</p><p>删除信息</p><hr><p><img src="https://www.notion.sopictures/image-20220105204434044.png" alt="https://www.notion.soPictures/image-20220105204434044.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查看校验webhook的配置kubectl get -A ValidatingWebhookConfiguration# 删除指定的校验kubectl delete ValidatingWebhookConfiguration ingress-nginx-admission-my-ingress-controller</span><br></pre></td></tr></table></figure><p>配置本地hosts文件</p><p>配置hosts</p><hr><p><img src="https://www.notion.sopictures/image-20220105204921272.png" alt="https://www.notion.soPictures/image-20220105204921272.png"></p><hr><p>记下来既可以访问在Service中暴露的Nginx信息</p><p>服通过Ingress访问</p><hr><p><img src="https://www.notion.sopictures/image-20220105205407393.png" alt="https://www.notion.soPictures/image-20220105205407393.png"></p><hr><h3 id="10-5-Jenkins集成Kubernetes"><a href="#10-5-Jenkins集成Kubernetes" class="headerlink" title="10.5 Jenkins集成Kubernetes"></a>10.5 Jenkins集成Kubernetes</h3><h3 id="10-5-1-准备部署的yml文件"><a href="#10-5-1-准备部署的yml文件" class="headerlink" title="10.5.1 准备部署的yml文件"></a>10.5.1 准备部署的yml文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  namespace: test  name: pipeline  labels:    app: pipelinespec:  replicas: 2  selector:    matchLabels:      app: pipeline  template:    metadata:      labels:        app: pipeline    spec:      containers:      - name: pipeline        image: 192.168.11.102:80/repo/pipeline:v4.0.0        imagePullPolicy: Always        ports:        - containerPort: 8080---apiVersion: v1kind: Servicemetadata:  namespace: test  labels:    app: pipeline  name: pipelinespec:  selector:    app: pipeline  ports:  - port: 8081    targetPort: 8080  type: NodePort---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  namespace: test  name: pipelinespec:  ingressClassName: ingress  rules:  - host: mashibing.pipeline.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: pipeline            port:              number: 8081</span><br></pre></td></tr></table></figure><h3 id="10-5-2-Harbor私服配置"><a href="#10-5-2-Harbor私服配置" class="headerlink" title="10.5.2 Harbor私服配置"></a>10.5.2 Harbor私服配置</h3><p>在尝试用kubernetes的yml文件启动pipeline服务时，会出现Kubernetes无法拉取镜像的问题，这里需要在kubernetes所在的Linux中配置Harbor服务信息，并且保证Kubernetes可以拉取Harbor上的镜像</p><ul><li><h2 id="设置Master和Worker的私服地址信息设置Harbor私服地址"><a href="#设置Master和Worker的私服地址信息设置Harbor私服地址" class="headerlink" title="设置Master和Worker的私服地址信息设置Harbor私服地址  "></a>设置Master和Worker的私服地址信息设置Harbor私服地址  </h2><h2 id="-54"><a href="#-54" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642498962716.png" alt="https://www.notion.soPictures/1642498962716.png">  </h2></li><li><h2 id="在Kuboard上设置私服密文信息设置密文并测试测试效果"><a href="#在Kuboard上设置私服密文信息设置密文并测试测试效果" class="headerlink" title="在Kuboard上设置私服密文信息设置密文并测试测试效果  "></a>在Kuboard上设置私服密文信息设置密文并测试测试效果  </h2><h2 id="-55"><a href="#-55" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642498994935.png" alt="https://www.notion.soPictures/1642498994935.png">  </h2><h2 id="按照复制指令的位置测试认证，效果如下"><a href="#按照复制指令的位置测试认证，效果如下" class="headerlink" title="  按照复制指令的位置测试认证，效果如下  "></a>  按照复制指令的位置测试认证，效果如下  </h2><h2 id="-56"><a href="#-56" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499172789.png" alt="https://www.notion.soPictures/1642499172789.png">  </h2></li></ul><h3 id="10-5-3-测试使用效果"><a href="#10-5-3-测试使用效果" class="headerlink" title="10.5.3 测试使用效果"></a>10.5.3 测试使用效果</h3><p>执行kubectl命令，基于yml启动服务，并且基于部署后服务的提示信息以及Ingress的设置，直接访问</p><p><img src="https://www.notion.sopictures/1642499368121.png" alt="https://www.notion.soPictures/1642499368121.png"></p><hr><p><img src="https://www.notion.sopictures/1642499788199.png" alt="https://www.notion.soPictures/1642499788199.png"></p><hr><h3 id="10-5-3-Jenkins远程调用"><a href="#10-5-3-Jenkins远程调用" class="headerlink" title="10.5.3 Jenkins远程调用"></a>10.5.3 Jenkins远程调用</h3><ul><li><h2 id="将pipeline-yml配置到Gitlab中配置yml文件"><a href="#将pipeline-yml配置到Gitlab中配置yml文件" class="headerlink" title="将pipeline.yml配置到Gitlab中配置yml文件  "></a>将pipeline.yml配置到Gitlab中配置yml文件  </h2><h2 id="-57"><a href="#-57" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499885324.png" alt="https://www.notion.soPictures/1642499885324.png">  </h2></li><li><h2 id="配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器"><a href="#配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器" class="headerlink" title="配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器  "></a>配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上设置目标服务器  </h2><h2 id="-58"><a href="#-58" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642499992148.png" alt="https://www.notion.soPictures/1642499992148.png">  </h2></li><li><h2 id="修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本"><a href="#修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本" class="headerlink" title="修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本  "></a>修改Jenkinsfile，重新设置流水线任务脚本，并测试效果传递yml文件脚本  </h2><h2 id="-59"><a href="#-59" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500061153.png" alt="https://www.notion.soPictures/1642500061153.png">  </h2><h2 id="-60"><a href="#-60" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500102996.png" alt="https://www.notion.soPictures/1642500102996.png">  </h2></li><li><h2 id="设置Jenkins无密码登录k8s-master远程执行命令无需密码-将Jenkins中公钥信息复制到k8s-master的-ssh-authorized-keysz中，保证远程连接无密码"><a href="#设置Jenkins无密码登录k8s-master远程执行命令无需密码-将Jenkins中公钥信息复制到k8s-master的-ssh-authorized-keysz中，保证远程连接无密码" class="headerlink" title="设置Jenkins无密码登录k8s-master远程执行命令无需密码  将Jenkins中公钥信息复制到k8s-master的~&#x2F;.ssh&#x2F;authorized_keysz中，保证远程连接无密码  "></a>设置Jenkins无密码登录k8s-master远程执行命令无需密码<br><br>  将Jenkins中公钥信息复制到k8s-master的~&#x2F;.ssh&#x2F;authorized_keysz中，保证远程连接无密码  </h2><h2 id="-61"><a href="#-61" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500239406.png" alt="https://www.notion.soPictures/1642500239406.png">  </h2></li><li><h2 id="设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile"><a href="#设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile" class="headerlink" title="设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile  "></a>设置执行kubectl的脚本到Jenkinsfile设置Jenkinsfile  </h2><h2 id="-62"><a href="#-62" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500378788.png" alt="https://www.notion.soPictures/1642500378788.png">  </h2></li><li><h2 id="执行查看效果执行流水线"><a href="#执行查看效果执行流水线" class="headerlink" title="执行查看效果执行流水线  "></a>执行查看效果执行流水线  </h2><h2 id="-63"><a href="#-63" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500413802.png" alt="https://www.notion.soPictures/1642500413802.png">  </h2><p>  可以查看到yml文件是由变化的， 这样k8s就会重新加载</p></li><li><h2 id="查看效果效果"><a href="#查看效果效果" class="headerlink" title="查看效果效果  "></a>查看效果效果  </h2><h2 id="-64"><a href="#-64" class="headerlink" title="    "></a>  <img src="https://www.notion.sopictures/1642500474036.png" alt="https://www.notion.soPictures/1642500474036.png">  </h2></li></ul><p>Ps：这种方式更适应与CD操作，将项目将基于某个版本部署到指定的目标服务器</p><h3 id="10-6-基于GitLab的WebHooks"><a href="#10-6-基于GitLab的WebHooks" class="headerlink" title="10.6 基于GitLab的WebHooks"></a>10.6 基于GitLab的WebHooks</h3><p>这里要实现自动化的一个CI操作，也就是开发人员Push代码到Git仓库后，Jenkins会自动的构建项目，将最新的提交点代码构建并进行打包部署，这里区别去上述的CD操作，CD操作需要基于某个版本进行部署，而这里每次都是将最新的提交点集成到主干上并测试。</p><h3 id="10-6-1-WebHooks通知"><a href="#10-6-1-WebHooks通知" class="headerlink" title="10.6.1 WebHooks通知"></a>10.6.1 WebHooks通知</h3><p>开启Jenkins的自动构建</p><p>构建触发器</p><hr><p><img src="https://www.notion.sopictures/1642500817131.png" alt="https://www.notion.soPictures/1642500817131.png"></p><hr><p>设置Gitlab的Webhooks</p><p>设置Gitlab的Webhooks</p><hr><p><img src="https://www.notion.sopictures/1642500933316.png" alt="https://www.notion.soPictures/1642500933316.png"></p><hr><p>需要关闭Jenkins的Gitlab认证</p><p>关闭Jenkins的Gitlab认证</p><hr><p><img src="https://www.notion.sopictures/1642501016474.png" alt="https://www.notion.soPictures/1642501016474.png"></p><hr><p>再次测试Gitlab</p><p>再次测试</p><hr><p><img src="https://www.notion.sopictures/1642501065243.png" alt="https://www.notion.soPictures/1642501065243.png"></p><hr><h3 id="10-6-2-修改配置"><a href="#10-6-2-修改配置" class="headerlink" title="10.6.2 修改配置"></a>10.6.2 修改配置</h3><p>修改Jenkinsfile实现基于最新提交点实现持续集成效果，将之前引用${tag}的全部去掉</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的脚本命令都放在pipeline中pipeline&#123;    // 指定任务再哪个集群节点中执行    agent any    // 声明全局变量，方便后面使用    environment &#123;        harborUser = &#x27;admin&#x27;        harborPasswd = &#x27;Harbor12345&#x27;        harborAddress = &#x27;192.168.11.102:80&#x27;        harborRepo = &#x27;repo&#x27;    &#125;    stages &#123;        stage(&#x27;拉取git仓库代码&#x27;) &#123;            steps &#123;                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], extensions: [], userRemoteConfigs: [[url: &#x27;http://192.168.11.101:8929/root/mytest.git&#x27;]]])            &#125;        &#125;        stage(&#x27;通过maven构建项目&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/maven/bin/mvn clean package -DskipTests&#x27;            &#125;        &#125;        stage(&#x27;通过SonarQube做代码质量检测&#x27;) &#123;            steps &#123;                sh &#x27;/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.source=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=./target/ -Dsonar.login=40306ae8ea69a4792df2ceb4d9d25fe8a6ab1701&#x27;            &#125;        &#125;        stage(&#x27;通过Docker制作自定义镜像&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;mv ./target/*.jar ./docker/                docker build -t $&#123;JOB_NAME&#125;:latest ./docker/&#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;将自定义镜像推送到Harbor&#x27;) &#123;            steps &#123;                sh &#x27;&#x27;&#x27;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;                docker tag $&#123;JOB_NAME&#125;:latest  $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest                docker push $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest &#x27;&#x27;&#x27;            &#125;        &#125;        stage(&#x27;将yml文件传到k8s-master上&#x27;) &#123;            steps &#123;                sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;k8s&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &#x27;&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;pipeline.yml&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;        stage(&#x27;远程执行k8s-master的kubectl命令&#x27;) &#123;            steps &#123;               sh &#x27;&#x27;&#x27;ssh root@192.168.11.201 kubectl apply -f /usr/local/k8s/pipeline.yml                ssh root@192.168.11.201 kubectl rollout restart deployment pipeline -n test&#x27;&#x27;&#x27;            &#125;        &#125;    &#125;    post &#123;        success &#123;            dingtalk(                robot: &#x27;Jenkins-DingDing&#x27;,                type: &#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 成功构建：$&#123;JOB_NAME&#125;! \n- 版本：latest \n- 持续时间：$&#123;currentBuild.durationString&#125;&quot; ]            )        &#125;        failure &#123;            dingtalk(                robot: &#x27;Jenkins-DingDing&#x27;,                type: &#x27;MARKDOWN&#x27;,                title: &quot;success: $&#123;JOB_NAME&#125;&quot;,                text: [&quot;- 构建失败：$&#123;JOB_NAME&#125;! \n- 版本：latest \n- 持续时间：$&#123;currentBuild.durationString&#125;&quot; ]            )        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>修改pipeline.yml，更改镜像版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1kind: Deploymentmetadata:  namespace: test  name: pipeline  labels:    app: pipelinespec:  replicas: 2  selector:    matchLabels:      app: pipeline  template:    metadata:      labels:        app: pipeline    spec:      containers:      - name: pipeline        image: 192.168.11.102:80/repo/pipeline:latest   # 这里        imagePullPolicy: Always        ports:        - containerPort: 8080# 省略其他内容…………</span><br></pre></td></tr></table></figure><h3 id="10-6-3-滚动更新"><a href="#10-6-3-滚动更新" class="headerlink" title="10.6.3 滚动更新"></a>10.6.3 滚动更新</h3><p>因为pipeline没有改变时，每次不会重新加载，这样会导致Pod中的容器不会动态更新，这里需要使用kubectl的rollout restart命令滚动更新</p><p>设置Jenkinsfle</p><hr><p><img src="https://www.notion.sopictures/1642501521065.png" alt="https://www.notion.soPictures/1642501521065.png"></p><hr><p><img src="https://www.notion.sopictures/1642501549176.png" alt="https://www.notion.soPictures/1642501549176.png"></p><hr><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2043.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2044.png" alt="Untitled"></p><p><img src="/DevOps%201d0ecefd93284e9c825a46e9952a6576/Untitled%2045.png" alt="Untitled"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
