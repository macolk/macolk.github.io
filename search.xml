<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kubebuilder 实战演练 之 自定义CronJob(二)</title>
      <link href="/posts/4a17d0018.html"/>
      <url>/posts/4a17d0018.html</url>
      
        <content type="html"><![CDATA[<h2 id="webhook编写"><a href="#webhook编写" class="headerlink" title="webhook编写"></a>webhook编写</h2><h3 id="kubebuilder生成webhook脚手架"><a href="#kubebuilder生成webhook脚手架" class="headerlink" title="kubebuilder生成webhook脚手架"></a>kubebuilder生成webhook脚手架</h3><p>kubebuilder 提供了webhook脚手架的生成命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create webhook --group batch --version v1 --kind CronJob --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure><p>命令执行结束，会在 api&#x2F;v1 目录下生成 cronjob_webhook.go，文件包含两类方法：</p><ul><li>默认值校验方法：Default()</li><li>操作校验方法：ValidateCreate()、ValidateUpdate()、ValidateDelete()</li></ul><h3 id="webhook的Default-方法编写"><a href="#webhook的Default-方法编写" class="headerlink" title="webhook的Default()方法编写"></a>webhook的Default()方法编写</h3><p>在api&#x2F;v1&#x2F;cronjob_webhook.go文件中，有Default()，编写逻辑如下：</p><ul><li>默认允许并发策略</li><li>默认不暂停任务</li><li>默认保存成功历史任务3个</li><li>默认保存失败历史人物1个<br>代码编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//+kubebuilder:webhook:path=/mutate-batch-graham924-com-v1-cronjob,mutating=true,failurePolicy=fail,sideEffects=None,groups=batch.graham924.com,resources=cronjobs,verbs=create;update,versions=v1,name=mcronjob.kb.io,admissionReviewVersions=v1</span><br><span class="line"></span><br><span class="line">var _ webhook.Defaulter = &amp;CronJob&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (r *CronJob) Default() &#123;</span><br><span class="line">cronjoblog.Info(&quot;default&quot;, &quot;name&quot;, r.Name)</span><br><span class="line"></span><br><span class="line">if r.Spec.ConcurrencyPolicy == &quot;&quot; &#123;</span><br><span class="line">r.Spec.ConcurrencyPolicy = AllowConcurrent</span><br><span class="line">&#125;</span><br><span class="line">if r.Spec.Suspend == nil &#123;</span><br><span class="line">r.Spec.Suspend = new(bool)</span><br><span class="line">&#125;</span><br><span class="line">if r.Spec.SuccessfulJobsHistoryLimit == nil &#123;</span><br><span class="line">r.Spec.SuccessfulJobsHistoryLimit = new(int32)</span><br><span class="line">*r.Spec.SuccessfulJobsHistoryLimit = 3</span><br><span class="line">&#125;</span><br><span class="line">if r.Spec.FailedJobsHistoryLimit == nil &#123;</span><br><span class="line">r.Spec.FailedJobsHistoryLimit = new(int32)</span><br><span class="line">*r.Spec.FailedJobsHistoryLimit = 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="webhook的CUD验证方法编写"><a href="#webhook的CUD验证方法编写" class="headerlink" title="webhook的CUD验证方法编写"></a>webhook的CUD验证方法编写</h3><p>验证逻辑</p><ul><li>create 和 update 时，都需要对cronjob的spec、name进行校验<ul><li>spec校验：spec下面的schedule字段，应该符合标准cron表达式</li><li>name校验：name长度最大不可超过52个字符</li></ul></li><li>delete 时，不需要校验，kubernetes会自动把相关资源全部删除<br>代码编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// TODO(user): change verbs to &quot;verbs=create;update;delete&quot; if you want to enable deletion validation.</span><br><span class="line">//+kubebuilder:webhook:path=/validate-batch-graham924-com-v1-cronjob,mutating=false,failurePolicy=fail,sideEffects=None,groups=batch.graham924.com,resources=cronjobs,verbs=create;update,versions=v1,name=vcronjob.kb.io,admissionReviewVersions=v1</span><br><span class="line"></span><br><span class="line">var _ webhook.Validator = &amp;CronJob&#123;&#125;</span><br><span class="line"></span><br><span class="line">// ValidateCreate implements webhook.Validator so a webhook will be registered for the type</span><br><span class="line">func (r *CronJob) ValidateCreate() (admission.Warnings, error) &#123;</span><br><span class="line">cronjoblog.Info(&quot;validate create&quot;, &quot;name&quot;, r.Name)</span><br><span class="line"></span><br><span class="line">// TODO(user): fill in your validation logic upon object creation.</span><br><span class="line">return nil, r.validateCronJob()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type</span><br><span class="line">func (r *CronJob) ValidateUpdate(old runtime.Object) (admission.Warnings, error) &#123;</span><br><span class="line">cronjoblog.Info(&quot;validate update&quot;, &quot;name&quot;, r.Name)</span><br><span class="line"></span><br><span class="line">// TODO(user): fill in your validation logic upon object update.</span><br><span class="line">return nil, r.validateCronJob()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ValidateDelete implements webhook.Validator so a webhook will be registered for the type</span><br><span class="line">func (r *CronJob) ValidateDelete() (admission.Warnings, error) &#123;</span><br><span class="line">cronjoblog.Info(&quot;validate delete&quot;, &quot;name&quot;, r.Name)</span><br><span class="line"></span><br><span class="line">// TODO(user): fill in your validation logic upon object deletion.</span><br><span class="line">return nil, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *CronJob) validateCronJob() error &#123;</span><br><span class="line">var allErrs field.ErrorList</span><br><span class="line">if err := r.validateCronJobName(); err != nil &#123;</span><br><span class="line">allErrs = append(allErrs, err)</span><br><span class="line">&#125;</span><br><span class="line">if err := r.validateCronJobSpec(); err != nil &#123;</span><br><span class="line">allErrs = append(allErrs, err)</span><br><span class="line">&#125;</span><br><span class="line">if len(allErrs) == 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return apierrors.NewInvalid(</span><br><span class="line">schema.GroupKind&#123;Group: &quot;batch.tutorial.kubebuilder.io&quot;, Kind: &quot;CronJob&quot;&#125;,</span><br><span class="line">r.Name, allErrs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *CronJob) validateCronJobSpec() *field.Error &#123;</span><br><span class="line">// The field helpers from the kubernetes API machinery help us return nicely</span><br><span class="line">// structured validation errors.</span><br><span class="line">return validateScheduleFormat(</span><br><span class="line">r.Spec.Schedule,</span><br><span class="line">field.NewPath(&quot;spec&quot;).Child(&quot;schedule&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">We&#x27;ll need to validate the [cron](https://en.wikipedia.org/wiki/Cron) schedule</span><br><span class="line">is well-formatted.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">func validateScheduleFormat(schedule string, fldPath *field.Path) *field.Error &#123;</span><br><span class="line">if _, err := cron.ParseStandard(schedule); err != nil &#123;</span><br><span class="line">return field.Invalid(fldPath, schedule, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Validating the length of a string field can be done declaratively by</span><br><span class="line">the validation schema.</span><br><span class="line"></span><br><span class="line">But the `ObjectMeta.Name` field is defined in a shared package under</span><br><span class="line">the apimachinery repo, so we can&#x27;t declaratively validate it using</span><br><span class="line">the validation schema.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">func (r *CronJob) validateCronJobName() *field.Error &#123;</span><br><span class="line">if len(r.ObjectMeta.Name) &gt; validationutils.DNS1035LabelMaxLength-11 &#123;</span><br><span class="line">// The job name length is 63 character like all Kubernetes objects</span><br><span class="line">// (which must fit in a DNS subdomain). The cronjob controller appends</span><br><span class="line">// a 11-character suffix to the cronjob (`-$TIMESTAMP`) when creating</span><br><span class="line">// a job. The job name length limit is 63 characters. Therefore cronjob</span><br><span class="line">// names must have length &lt;= 63-11=52. If we don&#x27;t validate this here,</span><br><span class="line">// then job creation will fail later.</span><br><span class="line">return field.Invalid(field.NewPath(&quot;metadata&quot;).Child(&quot;name&quot;), r.Name, &quot;must be no more than 52 characters&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看目前的main方法"><a href="#查看目前的main方法" class="headerlink" title="查看目前的main方法"></a>查看目前的main方法</h3><p>可以看到，在main方法中，除了启动了Controller，还注册启动了Webhook：SetupWebhookWithManager<br>但是启动Webhook的前提是环境变量 ENABLE_WEBHOOKS 为true，我们可以用这个开关，控制webhook的启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;crypto/tls&quot;</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line"></span><br><span class="line">// Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)</span><br><span class="line">// to ensure that exec-entrypoint and run can make use of them.</span><br><span class="line">_ &quot;k8s.io/client-go/plugin/pkg/client/auth&quot;</span><br><span class="line"></span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">utilruntime &quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br><span class="line">clientgoscheme &quot;k8s.io/client-go/kubernetes/scheme&quot;</span><br><span class="line">ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/healthz&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/log/zap&quot;</span><br><span class="line">metricsserver &quot;sigs.k8s.io/controller-runtime/pkg/metrics/server&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/webhook&quot;</span><br><span class="line"></span><br><span class="line">batchv1 &quot;graham924.com/cronJob-operator/api/v1&quot;</span><br><span class="line">&quot;graham924.com/cronJob-operator/internal/controller&quot;</span><br><span class="line">//+kubebuilder:scaffold:imports</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">scheme   = runtime.NewScheme()</span><br><span class="line">setupLog = ctrl.Log.WithName(&quot;setup&quot;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">utilruntime.Must(clientgoscheme.AddToScheme(scheme))</span><br><span class="line"></span><br><span class="line">utilruntime.Must(batchv1.AddToScheme(scheme))</span><br><span class="line">//+kubebuilder:scaffold:scheme</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var metricsAddr string</span><br><span class="line">var enableLeaderElection bool</span><br><span class="line">var probeAddr string</span><br><span class="line">var secureMetrics bool</span><br><span class="line">var enableHTTP2 bool</span><br><span class="line">flag.StringVar(&amp;metricsAddr, &quot;metrics-bind-address&quot;, &quot;:8080&quot;, &quot;The address the metric endpoint binds to.&quot;)</span><br><span class="line">flag.StringVar(&amp;probeAddr, &quot;health-probe-bind-address&quot;, &quot;:8081&quot;, &quot;The address the probe endpoint binds to.&quot;)</span><br><span class="line">flag.BoolVar(&amp;enableLeaderElection, &quot;leader-elect&quot;, false,</span><br><span class="line">&quot;Enable leader election for controller manager. &quot;+</span><br><span class="line">&quot;Enabling this will ensure there is only one active controller manager.&quot;)</span><br><span class="line">flag.BoolVar(&amp;secureMetrics, &quot;metrics-secure&quot;, false,</span><br><span class="line">&quot;If set the metrics endpoint is served securely&quot;)</span><br><span class="line">flag.BoolVar(&amp;enableHTTP2, &quot;enable-http2&quot;, false,</span><br><span class="line">&quot;If set, HTTP/2 will be enabled for the metrics and webhook servers&quot;)</span><br><span class="line">opts := zap.Options&#123;</span><br><span class="line">Development: true,</span><br><span class="line">&#125;</span><br><span class="line">opts.BindFlags(flag.CommandLine)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))</span><br><span class="line"></span><br><span class="line">// if the enable-http2 flag is false (the default), http/2 should be disabled</span><br><span class="line">// due to its vulnerabilities. More specifically, disabling http/2 will</span><br><span class="line">// prevent from being vulnerable to the HTTP/2 Stream Cancelation and</span><br><span class="line">// Rapid Reset CVEs. For more information see:</span><br><span class="line">// - https://github.com/advisories/GHSA-qppj-fm5r-hxr3</span><br><span class="line">// - https://github.com/advisories/GHSA-4374-p667-p6c8</span><br><span class="line">disableHTTP2 := func(c *tls.Config) &#123;</span><br><span class="line">setupLog.Info(&quot;disabling http/2&quot;)</span><br><span class="line">c.NextProtos = []string&#123;&quot;http/1.1&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsOpts := []func(*tls.Config)&#123;&#125;</span><br><span class="line">if !enableHTTP2 &#123;</span><br><span class="line">tlsOpts = append(tlsOpts, disableHTTP2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webhookServer := webhook.NewServer(webhook.Options&#123;</span><br><span class="line">TLSOpts: tlsOpts,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">Scheme: scheme,</span><br><span class="line">Metrics: metricsserver.Options&#123;</span><br><span class="line">BindAddress:   metricsAddr,</span><br><span class="line">SecureServing: secureMetrics,</span><br><span class="line">TLSOpts:       tlsOpts,</span><br><span class="line">&#125;,</span><br><span class="line">WebhookServer:          webhookServer,</span><br><span class="line">HealthProbeBindAddress: probeAddr,</span><br><span class="line">LeaderElection:         enableLeaderElection,</span><br><span class="line">LeaderElectionID:       &quot;a8a7eff2.graham924.com&quot;,</span><br><span class="line">// LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily</span><br><span class="line">// when the Manager ends. This requires the binary to immediately end when the</span><br><span class="line">// Manager is stopped, otherwise, this setting is unsafe. Setting this significantly</span><br><span class="line">// speeds up voluntary leader transitions as the new leader don&#x27;t have to wait</span><br><span class="line">// LeaseDuration time first.</span><br><span class="line">//</span><br><span class="line">// In the default scaffold provided, the program ends immediately after</span><br><span class="line">// the manager stops, so would be fine to enable this option. However,</span><br><span class="line">// if you are doing or is intended to do any operation such as perform cleanups</span><br><span class="line">// after the manager stops then its usage might be unsafe.</span><br><span class="line">// LeaderElectionReleaseOnCancel: true,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;unable to start manager&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err = (&amp;controller.CronJobReconciler&#123;</span><br><span class="line">Client: mgr.GetClient(),</span><br><span class="line">Scheme: mgr.GetScheme(),</span><br><span class="line">&#125;).SetupWithManager(mgr); err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;unable to create controller&quot;, &quot;controller&quot;, &quot;CronJob&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">if os.Getenv(&quot;ENABLE_WEBHOOKS&quot;) != &quot;false&quot; &#123;</span><br><span class="line">if err = (&amp;batchv1.CronJob&#123;&#125;).SetupWebhookWithManager(mgr); err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;unable to create webhook&quot;, &quot;webhook&quot;, &quot;CronJob&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//+kubebuilder:scaffold:builder</span><br><span class="line"></span><br><span class="line">if err := mgr.AddHealthzCheck(&quot;healthz&quot;, healthz.Ping); err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;unable to set up health check&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">if err := mgr.AddReadyzCheck(&quot;readyz&quot;, healthz.Ping); err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;unable to set up ready check&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupLog.Info(&quot;starting manager&quot;)</span><br><span class="line">if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil &#123;</span><br><span class="line">setupLog.Error(err, &quot;problem running manager&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h2><h3 id="暂不开启webhook验证"><a href="#暂不开启webhook验证" class="headerlink" title="暂不开启webhook验证"></a>暂不开启webhook验证</h3><p>执行命令<br>1、前台启动controller，用来看日志的打印</p><ul><li>部署CRD<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make manifests</span><br><span class="line">make install</span><br><span class="line">export ENABLE_WEBHOOKS=false</span><br><span class="line">make run</span><br></pre></td></tr></table></figure></li><li>关闭webhook开关<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ENABLE_WEBHOOKS=false</span><br></pre></td></tr></table></figure></li></ul><p>前台启动Controller，验证一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cronJob-operator]# make run</span><br><span class="line">/root/zgy/project/share-code-operator-study/cronJob-operator/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd:maxDescLen=0 webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/root/zgy/project/share-code-operator-study/cronJob-operator/bin/controller-gen-v0.14.0 object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./cmd/main.go</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    setup   starting manager</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    controller-runtime.metrics      Starting metrics server</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    controller-runtime.metrics      Serving metrics server  &#123;&quot;bindAddress&quot;: &quot;:8080&quot;, &quot;secure&quot;: false&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    starting server &#123;&quot;kind&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;source&quot;: &quot;kind source: *v1.CronJob&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;source&quot;: &quot;kind source: *v1.Job&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting Controller     &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;&#125;</span><br><span class="line">2024-03-13T17:25:21+08:00       INFO    Starting workers        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;worker count&quot;: 1&#125;</span><br></pre></td></tr></table></figure><p>2、打开第二个终端，创建实例查看结果</p><ul><li>创建一个 cronjob.batch.graham924.com 示例<ul><li>修改 config&#x2F;samples&#x2F;batch_v1_cronjob.yaml 文件如下，每分钟触发任务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch.graham924.com/v1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: cronjob</span><br><span class="line">    app.kubernetes.io/instance: cronjob-sample</span><br><span class="line">    app.kubernetes.io/part-of: cronjob-operator</span><br><span class="line">    app.kubernetes.io/managed-by: kustomize</span><br><span class="line">    app.kubernetes.io/created-by: cronjob-operator</span><br><span class="line">  name: cronjob-sample</span><br><span class="line">spec:</span><br><span class="line">  schedule: &quot;*/1 * * * *&quot;</span><br><span class="line">  startingDeadlineSeconds: 60</span><br><span class="line">  concurrencyPolicy: Allow</span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - date; echo Hello from the Kubernetes cluster</span><br><span class="line">          restartPolicy: OnFailure</span><br></pre></td></tr></table></figure>执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f config/samples/batch_v1_cronjob.yaml</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>查看创建结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有的 cronjob.batch.graham924.com 实例</span><br><span class="line">[root@localhost cronJob-operator]# kubectl get cronjob.batch.graham924.com</span><br><span class="line">NAME             AGE</span><br><span class="line">cronjob-sample   73s</span><br><span class="line"></span><br><span class="line"># 获取当前所有的jobs</span><br><span class="line">[root@localhost cronJob-operator]# kubectl get jobs</span><br><span class="line">NAME                        COMPLETIONS   DURATION   AGE</span><br><span class="line">cronjob-sample-1710323280   1/1           8s         67s</span><br><span class="line">cronjob-sample-1710323340   1/1           5s         7s</span><br><span class="line"></span><br><span class="line"># 获取当前所有的pods，每个job会创建一个pod</span><br><span class="line">[root@localhost cronJob-operator]# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS      RESTARTS   AGE</span><br><span class="line">cronjob-sample-1710323280-kh5hn   0/1     Completed   0          106s</span><br><span class="line">cronjob-sample-1710323340-r2nnf   0/1     Completed   0          46s</span><br><span class="line"></span><br><span class="line"># 查看第二个任务的日志，发现打印内容与期望一致</span><br><span class="line">[root@localhost cronJob-operator]# kubectl logs cronjob-sample-1710323340-r2nnf</span><br><span class="line">Wed Mar 13 09:49:03 UTC 2024</span><br><span class="line">Hello from the Kubernetes cluster</span><br></pre></td></tr></table></figure><p>可以看到已经成功创建了cronjob.batch.graham924.com，并且该cronjob正在按照预期创建job执行任务。第一个任务和第二个任务之间正好差了60s</p><p>3、controller终端的输出</p><p>可以看到，controller终端这边，随着我们创建cronjob资源，也有了调谐方法中的日志打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cronJob-operator]# make run</span><br><span class="line">/root/zgy/project/share-code-operator-study/cronJob-operator/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd:maxDcLen=0 webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/root/zgy/project/share-code-operator-study/cronJob-operator/bin/controller-gen-v0.14.0 object:headerFile=&quot;hack/boilerplateo.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./cmd/main.go</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    setup   starting manager</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    controller-runtime.metrics      Starting metrics server</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    controller-runtime.metrics      Serving metrics server  &#123;&quot;bindAddress&quot;: &quot;:8080&quot;, &quot;sure&quot;: false&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    starting server &#123;&quot;kind&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham9.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;source&quot;: &quot;kind source: *v1.CronJob&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham9.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;source&quot;: &quot;kind source: *v1.Job&quot;&#125;</span><br><span class="line">2024-03-13T17:25:20+08:00       INFO    Starting Controller     &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham9.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;&#125;</span><br><span class="line">2024-03-13T17:25:21+08:00       INFO    Starting workers        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham9.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;worker count&quot;: 1&#125;</span><br><span class="line">2024-03-13T17:47:39+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;1f36e9a2-44aa-4a43-898d-cf0ee80c49af&quot;, &quot;active jobs&quot;: 0, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">2024-03-13T17:47:39+08:00       INFO    KubeAPIWarningLogger    unknown field &quot;spec.jobTemplate.metadata.creationTimestamp&quot;</span><br><span class="line">2024-03-13T17:47:39+08:00       INFO    KubeAPIWarningLogger    unknown field &quot;spec.jobTemplate.spec.template.metadata.creationTimestamp&quot;</span><br><span class="line">2024-03-13T17:47:39+08:00       DEBUG   no upcoming scheduled times, sleeping until next        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;1f36e9a2-44aa-4a43-898d-cf0ee80c49af&quot;, &quot;now&quot;: &quot;2024-03-13T17:47:39+08:00&quot;, &quot;next run&quot;: &quot;2024-03-13T17:48:00+08:00&quot;&#125;</span><br><span class="line">2024-03-13T17:47:39+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;db68f73a-3fed-4ea0-bdda-966be262357a&quot;, &quot;active jobs&quot;: 0, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">2024-03-13T17:47:39+08:00       DEBUG   no upcoming scheduled times, sleeping until next        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;db68f73a-3fed-4ea0-bdda-966be262357a&quot;, &quot;now&quot;: &quot;2024-03-13T17:47:39+08:00&quot;, &quot;next run&quot;: &quot;2024-03-13T17:48:00+08:00&quot;&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;254f30e0-d9ed-4c06-839c-3bdf7f8a8f06&quot;, &quot;active jobs&quot;: 0, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   created Job for CronJob run     &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;254f30e0-d9ed-4c06-839c-3bdf7f8a8f06&quot;, &quot;now&quot;: &quot;2024-03-13T17:48:00+08:00&quot;, &quot;next run&quot;: &quot;2024-03-13T17:49:00+08:00&quot;, &quot;current run&quot;: &quot;2024-03-13T17:48:00+08:00&quot;, &quot;job&quot;: &#123;&quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample-1710323280&quot;&#125;&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;285e0e69-2fa7-4310-9a1a-502128c18f9b&quot;, &quot;active jobs&quot;: 1, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   no upcoming scheduled times, sleeping until next        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;285e0e69-2fa7-4310-9a1a-502128c18f9b&quot;, &quot;now&quot;: &quot;2024-03-13T17:48:00+08:00&quot;, &quot;next run&quot;: &quot;2024-03-13T17:49:00+08:00&quot;&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;8c67ee37-c6d1-4213-89a6-8ab7db3f65d9&quot;, &quot;active jobs&quot;: 1, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   no upcoming scheduled times, sleeping until next        &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;8c67ee37-c6d1-4213-89a6-8ab7db3f65d9&quot;, &quot;now&quot;: &quot;2024-03-13T17:48:00+08:00&quot;, &quot;next run&quot;: &quot;2024-03-13T17:49:00+08:00&quot;&#125;</span><br><span class="line">2024-03-13T17:48:00+08:00       DEBUG   job count       &#123;&quot;controller&quot;: &quot;cronjob&quot;, &quot;controllerGroup&quot;: &quot;batch.graham924.com&quot;, &quot;controllerKind&quot;: &quot;CronJob&quot;, &quot;CronJob&quot;: &#123;&quot;name&quot;:&quot;cronjob-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;cronjob-sample&quot;, &quot;reconcileID&quot;: &quot;f55c3ed0-a65f-4509-a018-0dd100c4db3f&quot;, &quot;active jobs&quot;: 1, &quot;successful jobs&quot;: 0, &quot;failed jobs&quot;: 0&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="开启webhook验证"><a href="#开启webhook验证" class="headerlink" title="开启webhook验证"></a>开启webhook验证</h3><p>1、安装cert-manager</p><p>为什么需要给webhook提供证书</p><ul><li>API Server 通过 HTTPS POST 访问 Webhook Server, 因此 Webhook Server 必须要监听在 https 协议上</li><li>因此我们需要给webhook提供证书<br>kubebuilder官方也 建议使用 cert-manager 为 webhook 服务器提供证书</li><li>安装cert-manager<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml</span><br></pre></td></tr></table></figure></li></ul><p>查看安装结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cert-manager]# kubectl get pod -n cert-manager</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">cert-manager-7fb948f468-r5dj2              1/1     Running   0          142m</span><br><span class="line">cert-manager-cainjector-75c5fc965c-shtx6   1/1     Running   0          142m</span><br><span class="line">cert-manager-webhook-757c9d4bb7-vhgt7      1/1     Running   0          142m</span><br><span class="line"></span><br><span class="line">[root@localhost cert-manager]# kubectl get ValidatingWebhookConfiguration</span><br><span class="line">NAME                   WEBHOOKS   AGE</span><br><span class="line">cert-manager-webhook   1          143m</span><br><span class="line"></span><br><span class="line">[root@localhost cert-manager]# kubectl get MutatingWebhookConfiguration</span><br><span class="line">NAME                   WEBHOOKS   AGE</span><br><span class="line">cert-manager-webhook   1          143m</span><br></pre></td></tr></table></figure><p>2、修改配置文件</p><p>让我们的webhook，使用cert-manager提供的证书，还需要修改项目中的几个配置文件</p><p>修改 config&#x2F;default&#x2F;kustomization.yaml，将关于WEBHOOK、CERTMANAGER 的 都取消注释即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"># Adds namespace to all resources.</span><br><span class="line">namespace: cronjob-operator-system</span><br><span class="line"></span><br><span class="line"># Value of this field is prepended to the</span><br><span class="line"># names of all resources, e.g. a deployment named</span><br><span class="line"># &quot;wordpress&quot; becomes &quot;alices-wordpress&quot;.</span><br><span class="line"># Note that it should also match with the prefix (text before &#x27;-&#x27;) of the namespace</span><br><span class="line"># field above.</span><br><span class="line">namePrefix: cronjob-operator-</span><br><span class="line"></span><br><span class="line"># Labels to add to all resources and selectors.</span><br><span class="line">#labels:</span><br><span class="line">#- includeSelectors: true</span><br><span class="line">#  pairs:</span><br><span class="line">#    someName: someValue</span><br><span class="line"></span><br><span class="line">resources:</span><br><span class="line">- ../crd</span><br><span class="line">- ../rbac</span><br><span class="line">- ../manager</span><br><span class="line"># [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in</span><br><span class="line"># crd/kustomization.yaml</span><br><span class="line">- ../webhook</span><br><span class="line"># [CERTMANAGER] To enable cert-manager, uncomment all sections with &#x27;CERTMANAGER&#x27;. &#x27;WEBHOOK&#x27; components are required.</span><br><span class="line">- ../certmanager</span><br><span class="line"># [PROMETHEUS] To enable prometheus monitor, uncomment all sections with &#x27;PROMETHEUS&#x27;.</span><br><span class="line">- ../prometheus</span><br><span class="line"></span><br><span class="line">patches:</span><br><span class="line"># Protect the /metrics endpoint by putting it behind auth.</span><br><span class="line"># If you want your controller-manager to expose the /metrics</span><br><span class="line"># endpoint w/o any authn/z, please comment the following line.</span><br><span class="line">- path: manager_auth_proxy_patch.yaml</span><br><span class="line"></span><br><span class="line"># [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in</span><br><span class="line"># crd/kustomization.yaml</span><br><span class="line">- path: manager_webhook_patch.yaml</span><br><span class="line"></span><br><span class="line"># [CERTMANAGER] To enable cert-manager, uncomment all sections with &#x27;CERTMANAGER&#x27;.</span><br><span class="line"># Uncomment &#x27;CERTMANAGER&#x27; sections in crd/kustomization.yaml to enable the CA injection in the admission webhooks.</span><br><span class="line"># &#x27;CERTMANAGER&#x27; needs to be enabled to use ca injection</span><br><span class="line">- path: webhookcainjection_patch.yaml</span><br><span class="line"></span><br><span class="line"># [CERTMANAGER] To enable cert-manager, uncomment all sections with &#x27;CERTMANAGER&#x27; prefix.</span><br><span class="line"># Uncomment the following replacements to add the cert-manager CA injection annotations</span><br><span class="line">replacements:</span><br><span class="line"> - source: # Add cert-manager annotation to ValidatingWebhookConfiguration, MutatingWebhookConfiguration and CRDs</span><br><span class="line">     kind: Certificate</span><br><span class="line">     group: cert-manager.io</span><br><span class="line">     version: v1</span><br><span class="line">     name: serving-cert # this name should match the one in certificate.yaml</span><br><span class="line">     fieldPath: .metadata.namespace # namespace of the certificate CR</span><br><span class="line">   targets:</span><br><span class="line">     - select:</span><br><span class="line">         kind: ValidatingWebhookConfiguration</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 0</span><br><span class="line">         create: true</span><br><span class="line">     - select:</span><br><span class="line">         kind: MutatingWebhookConfiguration</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 0</span><br><span class="line">         create: true</span><br><span class="line">     - select:</span><br><span class="line">         kind: CustomResourceDefinition</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 0</span><br><span class="line">         create: true</span><br><span class="line"> - source:</span><br><span class="line">     kind: Certificate</span><br><span class="line">     group: cert-manager.io</span><br><span class="line">     version: v1</span><br><span class="line">     name: serving-cert # this name should match the one in certificate.yaml</span><br><span class="line">     fieldPath: .metadata.name</span><br><span class="line">   targets:</span><br><span class="line">     - select:</span><br><span class="line">         kind: ValidatingWebhookConfiguration</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 1</span><br><span class="line">         create: true</span><br><span class="line">     - select:</span><br><span class="line">         kind: MutatingWebhookConfiguration</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 1</span><br><span class="line">         create: true</span><br><span class="line">     - select:</span><br><span class="line">         kind: CustomResourceDefinition</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .metadata.annotations.[cert-manager.io/inject-ca-from]</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;/&#x27;</span><br><span class="line">         index: 1</span><br><span class="line">         create: true</span><br><span class="line"> - source: # Add cert-manager annotation to the webhook Service</span><br><span class="line">     kind: Service</span><br><span class="line">     version: v1</span><br><span class="line">     name: webhook-service</span><br><span class="line">     fieldPath: .metadata.name # namespace of the service</span><br><span class="line">   targets:</span><br><span class="line">     - select:</span><br><span class="line">         kind: Certificate</span><br><span class="line">         group: cert-manager.io</span><br><span class="line">         version: v1</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .spec.dnsNames.0</span><br><span class="line">         - .spec.dnsNames.1</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;.&#x27;</span><br><span class="line">         index: 0</span><br><span class="line">         create: true</span><br><span class="line"> - source:</span><br><span class="line">     kind: Service</span><br><span class="line">     version: v1</span><br><span class="line">     name: webhook-service</span><br><span class="line">     fieldPath: .metadata.namespace # namespace of the service</span><br><span class="line">   targets:</span><br><span class="line">     - select:</span><br><span class="line">         kind: Certificate</span><br><span class="line">         group: cert-manager.io</span><br><span class="line">         version: v1</span><br><span class="line">       fieldPaths:</span><br><span class="line">         - .spec.dnsNames.0</span><br><span class="line">         - .spec.dnsNames.1</span><br><span class="line">       options:</span><br><span class="line">         delimiter: &#x27;.&#x27;</span><br><span class="line">         index: 1</span><br><span class="line">         create: true</span><br></pre></td></tr></table></figure><ul><li>修改 config&#x2F;crd&#x2F;kustomization.yaml，为每个 CRD 启用 CA 注入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># This kustomization.yaml is not intended to be run by itself,</span><br><span class="line"># since it depends on service name and namespace that are out of this kustomize package.</span><br><span class="line"># It should be run by config/default</span><br><span class="line">resources:</span><br><span class="line">- bases/batch.graham924.com_cronjobs.yaml</span><br><span class="line">#+kubebuilder:scaffold:crdkustomizeresource</span><br><span class="line"></span><br><span class="line">patches:</span><br><span class="line"># [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix.</span><br><span class="line"># patches here are for enabling the conversion webhook for each CRD</span><br><span class="line">- path: patches/webhook_in_cronjobs.yaml</span><br><span class="line">#+kubebuilder:scaffold:crdkustomizewebhookpatch</span><br><span class="line"></span><br><span class="line"># [CERTMANAGER] To enable cert-manager, uncomment all the sections with [CERTMANAGER] prefix.</span><br><span class="line"># patches here are for enabling the CA injection for each CRD</span><br><span class="line">- path: patches/cainjection_in_cronjobs.yaml</span><br><span class="line">#+kubebuilder:scaffold:crdkustomizecainjectionpatch</span><br><span class="line"></span><br><span class="line"># [WEBHOOK] To enable webhook, uncomment the following section</span><br><span class="line"># the following config is for teaching kustomize how to do kustomization for CRDs.</span><br><span class="line"></span><br><span class="line">configurations:</span><br><span class="line">- kustomizeconfig.yaml</span><br></pre></td></tr></table></figure></li></ul><p>3、开启webhook环境变量开关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ENABLE_WEBHOOKS=true</span><br></pre></td></tr></table></figure><p>4、打包镜像并上传仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker-build docker-push IMG=gesang321/cronjob-operator:v2</span><br></pre></td></tr></table></figure><p>5、部署和验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make deploy IMG=gesang321/cronjob-operator:v2</span><br><span class="line">kubectl create -f config/samples/batch_v1_cronjob.yaml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubebuilder 实战演练 之 自定义CronJob(一)</title>
      <link href="/posts/4a17d0018.html"/>
      <url>/posts/4a17d0018.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目和API"><a href="#创建项目和API" class="headerlink" title="创建项目和API"></a>创建项目和API</h2><p>创建项目和API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir cronJob-operator</span><br><span class="line">cd cronJob-operator</span><br><span class="line">kubebuilder init --domain=graham924.com --repo=graham924.com/cronJob-operator</span><br><span class="line">kubebuilder create api --group batch --version v1 --kind CronJob</span><br></pre></td></tr></table></figure><p>执行结束，项目目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[root@master cronJob-operator]# tree</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── cronjob_types.go</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       └── zz_generated.deepcopy.go</span><br><span class="line">├── bin</span><br><span class="line">│   └── controller-gen-v0.14.0</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_auth_proxy_patch.yaml</span><br><span class="line">│   │   └── manager_config_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── auth_proxy_client_clusterrole.yaml</span><br><span class="line">│   │   ├── auth_proxy_role_binding.yaml</span><br><span class="line">│   │   ├── auth_proxy_role.yaml</span><br><span class="line">│   │   ├── auth_proxy_service.yaml</span><br><span class="line">│   │   ├── cronjob_editor_role.yaml</span><br><span class="line">│   │   ├── cronjob_viewer_role.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   └── samples</span><br><span class="line">│       ├── batch_v1_cronjob.yaml</span><br><span class="line">│       └── kustomization.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── cronjob_controller.go</span><br><span class="line">│       ├── cronjob_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">17 directories, 41 files</span><br></pre></td></tr></table></figure><h2 id="设计API"><a href="#设计API" class="headerlink" title="设计API"></a>设计API</h2><h3 id="Spec设计"><a href="#Spec设计" class="headerlink" title="Spec设计"></a>Spec设计</h3><p>从核心功能上说，CronJob 至少需要以下2个部分:</p><ul><li>一个执行计划Schedule</li><li>一个执行任务Job</li></ul><p>除此之外，我们还可以添加一些其他部分，使得我们自己的cronJob更加简单易用</p><ul><li>执行本轮任务的最后期限：如果错过了这个期限，就需要等到下一个预定时间</li><li>多任务并行策略：如果多个作业同时运行，我们要停止旧的作业? 还是同时运行两个作业？还是禁止并行？</li><li>暂停标记：使用一个标记，控制 CronJob 运行的暂停</li><li>成功的任务数量限制：执行成功的任务数量限制</li><li>失败的任务数量限制：执行失败的任务数量限制</li></ul><p>因此，Spec应该具有7个字段</p><h3 id="Status设计"><a href="#Status设计" class="headerlink" title="Status设计"></a>Status设计</h3><p>Status主要设计一些可观测信息，让用户和其他Controller能够方便的观测资源的状态信息。我们希望 Status 包含下面两部分信息</p><ul><li>当前正在运行的任务</li><li>上一次运行成功任务的时间</li></ul><h2 id="api-v1-目录"><a href="#api-v1-目录" class="headerlink" title="api&#x2F;v1 目录"></a>api&#x2F;v1 目录</h2><h3 id="cronjob-types-go文件编写"><a href="#cronjob-types-go文件编写" class="headerlink" title="cronjob_types.go文件编写"></a>cronjob_types.go文件编写</h3><p>按照上面设计的Spec、Status，编写cronjob_types.go</p><ul><li>Spec 的多任务并行策略，用枚举写成 ConcurrencyPolicy，并且加上 +kubebuilder:validation:Enum&#x3D;Allow;Forbid;Replace，可以对值进行单独的检查</li><li>Status 的 上一次运行成功任务的时间，使用 metav1.Time 替换 time.Time，能够获得更稳定的序列化能力等</li><li>type CronJob struct 结构体上方，需要使用 &#x2F;&#x2F;+kubebuilder:subresource:status 标记开启子资源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">batchv1 &quot;k8s.io/api/batch/v1&quot;</span><br><span class="line">corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!</span><br><span class="line">// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.</span><br><span class="line"></span><br><span class="line">// ConcurrencyPolicy describes how the job will be handled.</span><br><span class="line">// Only one of the following concurrent policies may be specified.</span><br><span class="line">// If none of the following policies is specified, the default one</span><br><span class="line">// is AllowConcurrent.</span><br><span class="line">// +kubebuilder:validation:Enum=Allow;Forbid;Replace</span><br><span class="line">type ConcurrencyPolicy string</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">// AllowConcurrency allows CronJobs to run concurrently.</span><br><span class="line">AllowConcurrency ConcurrencyPolicy = &quot;Allow&quot;</span><br><span class="line"></span><br><span class="line">// ForbidConcurrency forbids concurrent runs, skipping next run if previous</span><br><span class="line">ForbidConcurrency ConcurrencyPolicy = &quot;Forbid&quot;</span><br><span class="line"></span><br><span class="line">// ReplaceConcurrency cancels currently running job and replaces it with a new one.</span><br><span class="line">ReplaceConcurrency ConcurrencyPolicy = &quot;Replace&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CronJobSpec defines the desired state of CronJob</span><br><span class="line">type CronJobSpec struct &#123;</span><br><span class="line">//+kubebuilder:validation:MinLength=0</span><br><span class="line"></span><br><span class="line">// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.</span><br><span class="line">Schedule string `json:&quot;schedule&quot;`</span><br><span class="line"></span><br><span class="line">// Specifies the job that will be created when executing a CronJob.</span><br><span class="line">JobTemplate batchv1.JobTemplateSpec `json:&quot;jobTemplate&quot;`</span><br><span class="line"></span><br><span class="line">// Optional deadline in seconds for starting the job if it misses scheduled</span><br><span class="line">// time for any reason.  Missed jobs executions will be counted as failed ones.</span><br><span class="line">// +optional</span><br><span class="line">StartingDeadlineSeconds *int64 `json:&quot;startingDeadlineSeconds,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">// Specifies how to treat concurrent executions of a Job.</span><br><span class="line">// Valid values are:</span><br><span class="line">// - &quot;Allow&quot; (default): allows CronJobs to run concurrently;</span><br><span class="line">// - &quot;Forbid&quot;: forbids concurrent runs, skipping next run if previous run hasn&#x27;t finished yet;</span><br><span class="line">// - &quot;Replace&quot;: cancels currently running job and replaces it with a new one</span><br><span class="line">// +optional</span><br><span class="line">ConcurrencyPolicy ConcurrencyPolicy `json:&quot;concurrencyPolicy,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">// This flag tells the controller to suspend subsequent executions, it does</span><br><span class="line">// not apply to already started executions.  Defaults to false.</span><br><span class="line">// +optional</span><br><span class="line">Suspend *bool `json:&quot;suspend,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">//+kubebuilder:validation:Minimum=0</span><br><span class="line"></span><br><span class="line">// The number of successful finished jobs to retain.</span><br><span class="line">// This is a pointer to distinguish between explicit zero and not specified.</span><br><span class="line">// +optional</span><br><span class="line">SuccessfulJobsHistoryLimit *int32 `json:&quot;successfulJobsHistoryLimit,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">//+kubebuilder:validation:Minimum=0</span><br><span class="line"></span><br><span class="line">// The number of failed finished jobs to retain.</span><br><span class="line">// This is a pointer to distinguish between explicit zero and not specified.</span><br><span class="line">// +optional</span><br><span class="line">FailedJobsHistoryLimit *int32 `json:&quot;failedJobsHistoryLimit,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CronJobStatus defines the observed state of CronJob</span><br><span class="line">type CronJobStatus struct &#123;</span><br><span class="line">// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span><br><span class="line">// Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line"></span><br><span class="line">// A list of pointers to currently running jobs.</span><br><span class="line">// +optional</span><br><span class="line">Active []corev1.ObjectReferencen `json:&quot;active,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">// Information when was the last time the job was successfully scheduled.</span><br><span class="line">// +optional</span><br><span class="line">LastScheduleTime *metav1.Time `json:&quot;lastScheduleTime,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//+kubebuilder:object:root=true</span><br><span class="line">//+kubebuilder:subresource:status</span><br><span class="line"></span><br><span class="line">// CronJob is the Schema for the cronjobs API</span><br><span class="line">type CronJob struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   CronJobSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">Status CronJobStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//+kubebuilder:object:root=true</span><br><span class="line"></span><br><span class="line">// CronJobList contains a list of CronJob</span><br><span class="line">type CronJobList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Items           []CronJob `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">SchemeBuilder.Register(&amp;CronJob&#123;&#125;, &amp;CronJobList&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="groupversion-info-go文件学习"><a href="#groupversion-info-go文件学习" class="headerlink" title="groupversion_info.go文件学习"></a>groupversion_info.go文件学习</h3><p>该文件无需更改，但是需要了解一下里面的内容. 文件完整内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Package v1 contains API Schema definitions for the batch v1 API group</span><br><span class="line">// +kubebuilder:object:generate=true</span><br><span class="line">// +groupName=batch.graham924.com</span><br><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/scheme&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// GroupVersion is group version used to register these objects</span><br><span class="line">GroupVersion = schema.GroupVersion&#123;Group: &quot;batch.graham924.com&quot;, Version: &quot;v1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// SchemeBuilder is used to add go types to the GroupVersionKind scheme</span><br><span class="line">SchemeBuilder = &amp;scheme.Builder&#123;GroupVersion: GroupVersion&#125;</span><br><span class="line"></span><br><span class="line">// AddToScheme adds the types in this group-version to the given scheme.</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Groupversion_info. go 包含关于 group-version 的公共元数据。首先，我们有一些包级别的标记</p><ul><li>+kubebuilder:object:generate&#x3D;true 表示在这个包中有 Kubernetes 对象，对象生成器可以知道有要生成的对象</li><li>+groupName&#x3D;batch.graham924.com 表示这个包代表组 batch.graham924.com，CRD 生成器根据此标记，为它从这个包创建的 CRD 生成正确的元数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Package v1 contains API Schema definitions for the batch v1 API group</span><br><span class="line">// +kubebuilder:object:generate=true</span><br><span class="line">// +groupName=batch.graham924.com</span><br><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">    &quot;sigs.k8s.io/controller-runtime/pkg/scheme&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><pre><code>  1  2  3  4  5  6  7  8  9</code></pre></li></ul><p>然后，声明了一些全局变量，用于设置 Scheme。</p><ul><li>GroupVersion 描述 GV 信息</li><li>SchemeBuilder 简化了 将自定义的类型添加到Scheme的过程</li><li>AddToScheme 是 SchemeBuilder.AddToScheme 方法的别称，目的是更方便使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">// GroupVersion is group version used to register these objects</span><br><span class="line">GroupVersion = schema.GroupVersion&#123;Group: &quot;batch.graham924.com&quot;, Version: &quot;v1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// SchemeBuilder is used to add go types to the GroupVersionKind scheme</span><br><span class="line">SchemeBuilder = &amp;scheme.Builder&#123;GroupVersion: GroupVersion&#125;</span><br><span class="line"></span><br><span class="line">// AddToScheme adds the types in this group-version to the given scheme.</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="zz-generated-deepcopy-go文件学习"><a href="#zz-generated-deepcopy-go文件学习" class="headerlink" title="zz_generated.deepcopy.go文件学习"></a>zz_generated.deepcopy.go文件学习</h3><p>zz_generated.deepcopy.go文件 无需更改，是自动生成的</p><p>在 cronjob_types.go 文件中，带有 +kubebuilder:object:root&#x3D;true 标记的所有 Kind（本例中是CronJob、CronJobList），controller-gen工具都会对该 Kind 生成 runtime.Object 的 DeepCopyObject 方法实现。另外，controller-gen 还为每个 根类型 及其 所有子类型 生成另外两个其他的方法: DeepCopy 和 DeepCopyInto</p><ul><li>所有根类型：CronJob、CronJobList</li><li>所有子类型：CronJobSpec、CronJobStatus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">runtime &quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *CronJob) DeepCopyInto(out *CronJob) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">out.TypeMeta = in.TypeMeta</span><br><span class="line">in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)</span><br><span class="line">out.Spec = in.Spec</span><br><span class="line">out.Status = in.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJob.</span><br><span class="line">func (in *CronJob) DeepCopy() *CronJob &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(CronJob)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.</span><br><span class="line">func (in *CronJob) DeepCopyObject() runtime.Object &#123;</span><br><span class="line">if c := in.DeepCopy(); c != nil &#123;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *CronJobList) DeepCopyInto(out *CronJobList) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">out.TypeMeta = in.TypeMeta</span><br><span class="line">in.ListMeta.DeepCopyInto(&amp;out.ListMeta)</span><br><span class="line">if in.Items != nil &#123;</span><br><span class="line">in, out := &amp;in.Items, &amp;out.Items</span><br><span class="line">*out = make([]CronJob, len(*in))</span><br><span class="line">for i := range *in &#123;</span><br><span class="line">(*in)[i].DeepCopyInto(&amp;(*out)[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobList.</span><br><span class="line">func (in *CronJobList) DeepCopy() *CronJobList &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(CronJobList)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.</span><br><span class="line">func (in *CronJobList) DeepCopyObject() runtime.Object &#123;</span><br><span class="line">if c := in.DeepCopy(); c != nil &#123;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *CronJobSpec) DeepCopyInto(out *CronJobSpec) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobSpec.</span><br><span class="line">func (in *CronJobSpec) DeepCopy() *CronJobSpec &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(CronJobSpec)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *CronJobStatus) DeepCopyInto(out *CronJobStatus) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobStatus.</span><br><span class="line">func (in *CronJobStatus) DeepCopy() *CronJobStatus &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(CronJobStatus)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="internal-controller目录"><a href="#internal-controller目录" class="headerlink" title="internal&#x2F;controller目录"></a>internal&#x2F;controller目录</h2><h3 id="cronjob-controller-go空文件学习"><a href="#cronjob-controller-go空文件学习" class="headerlink" title="cronjob_controller.go空文件学习"></a>cronjob_controller.go空文件学习</h3><p>kubebuilder create api命令，已经为我们创建了一个controller的框架，我们下面对空的框架进行介绍</p><h4 id="控制器基本知识"><a href="#控制器基本知识" class="headerlink" title="控制器基本知识"></a>控制器基本知识</h4><p>控制器的作用：控制器 确保 资源的 实际状态 和 期望状态 保持一致，该过程被称作 调谐Reconcile。<br>Reconciler结构体：每个控制器 中，都自动生成了一个 …Reconciler结构体，专门用于实现调谐过程。比如我们这里的 CronJobReconciler</p><h4 id="cronjob-controller-go的默认import"><a href="#cronjob-controller-go的默认import" class="headerlink" title="cronjob_controller.go的默认import"></a>cronjob_controller.go的默认import</h4><p>一个控制器，默认都需要导入3种包：controller-runtime包、客户端包、api包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package controllers</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line"></span><br><span class="line">    &quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">    ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">    &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span><br><span class="line">    &quot;sigs.k8s.io/controller-runtime/pkg/log&quot;</span><br><span class="line"></span><br><span class="line">    batchv1 &quot;tutorial.kubebuilder.io/project/api/v1&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="CronJobReconciler-结构体"><a href="#CronJobReconciler-结构体" class="headerlink" title="CronJobReconciler 结构体"></a>CronJobReconciler 结构体</h4><p>kubebuilder 为我们搭建了一个基本的 Reconciler结构。几乎每个协调器都需要进行日志记录，并且需要客户端去获取对象，所以基本的 Reconciler结构里，已经默认内置了这两个字段。如果后续有需要，可以往结构体里加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CronJobReconciler reconciles a CronJob object</span><br><span class="line">type CronJobReconciler struct &#123;</span><br><span class="line">client.Client</span><br><span class="line">Scheme *runtime.Scheme</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reconciler-的-RBAC权限"><a href="#Reconciler-的-RBAC权限" class="headerlink" title="Reconciler 的 RBAC权限"></a>Reconciler 的 RBAC权限</h4><p>大多数控制器最终都会在集群上运行，因此它们需要 RBAC 权限，我们使用kubebuilder 的 RBAC 标记 来指定这些权限。这些是运行所需的最低权限。后期有需要的时候，会进行更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs/status,verbs=get;update;patch</span><br><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs/finalizers,verbs=update</span><br></pre></td></tr></table></figure><h4 id="Reconcile-函数框架"><a href="#Reconcile-函数框架" class="headerlink" title="Reconcile 函数框架"></a>Reconcile 函数框架</h4><ul><li><p>Reconcile 函数代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (r *CronJobReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">    _ = log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">    // your logic here</span><br><span class="line"></span><br><span class="line">    return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Reconcile 函数的参数</p><ul><li>ctx context.Context：上下文对象，提供了方法执行所需的环境信息和控制操作的手段。它可以用来取消操作、传递元数据等。</li><li>req ctrl.Request：这是用于指示需要调谐的对象的请求。其中包含了对象的类型信息和名称。</li></ul></li><li><p>Reconcile 函数的返回值</p><ul><li>ctrl.Result：这是一个结构体，用于表示调谐操作的结果，包括是否需要重新调谐、重试的时间间隔等信息。如果调谐成功，则返回空结果</li><li>error：如果发生错误，可以返回一个非空的 error 对象，用于表示错误的信息。</li></ul></li><li><p>Reconcile 的日志记录</p><ul><li>Reconcile 函数中默认给我们创建了一个日志记录器，使用的是 log.FromContext(ctx)</li><li>log.FromContext(ctx) 是 controller-runtime&#x2F;pkg&#x2F;log 提供的一个方法，会返回一个 logr.Logger 对象</li><li>controller-runtime 就是通过这个名为 logr 的库使用结构化日志记录的</li></ul></li></ul><h4 id="Reconcile-注册到-Manager"><a href="#Reconcile-注册到-Manager" class="headerlink" title="Reconcile 注册到 Manager"></a>Reconcile 注册到 Manager</h4><p>Reconcile开发完毕，还不能直接被使用，需要将其注册到Manager管理器中，这样在启动Manager的时候，就可以同步将Reconcile启动了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error &#123;</span><br><span class="line">    return ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">        For(&amp;batchv1.CronJob&#123;&#125;).</span><br><span class="line">        Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    1    2    3    4    5</code></pre><h3 id="cronjob-controller-go编写"><a href="#cronjob-controller-go编写" class="headerlink" title="cronjob_controller.go编写"></a>cronjob_controller.go编写</h3><h4 id="cronjob-controller-逻辑分析"><a href="#cronjob-controller-逻辑分析" class="headerlink" title="cronjob_controller 逻辑分析"></a>cronjob_controller 逻辑分析</h4><p>编写 Reconcile 之前，我们先分析一下先后的逻辑</p><ul><li>获取发生变化（待调谐）的 CronJob 对象</li><li>获取当前所有的 Active Job，更新 Status.Active 字段</li><li>根据任务的历史界限，清理旧的Job</li><li>检查当前 CronJob 是否已经被暂停（如果被停职，就不要再去做其他事情了）</li><li>按 Schedule 执行下一次 Job</li><li>如果按计划运行一个新 Job，注意不要超过最后期限，也不要被我们的并发策略阻塞</li><li>当我们看到一个正在运行的Job（自动完成），或者到了进行下一次计划运行的时间时，请重新排队。</li></ul><h4 id="cronjob-controller代码编写"><a href="#cronjob-controller代码编写" class="headerlink" title="cronjob_controller代码编写"></a>cronjob_controller代码编写</h4><ul><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line">package controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/robfig/cron&quot;</span><br><span class="line">corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">ref &quot;k8s.io/client-go/tools/reference&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">batchv1 &quot;graham924.com/cronJob-operator/api/v1&quot;</span><br><span class="line">kbatch &quot;k8s.io/api/batch/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span><br><span class="line">&quot;sigs.k8s.io/controller-runtime/pkg/log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// CronJobReconciler reconciles a CronJob object</span><br><span class="line">type CronJobReconciler struct &#123;</span><br><span class="line">client.Client</span><br><span class="line">Scheme *runtime.Scheme</span><br><span class="line">Clock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type realClock struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (_ realClock) Now() time.Time &#123;</span><br><span class="line">return time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Clock interface &#123;</span><br><span class="line">Now() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs/status,verbs=get;update;patch</span><br><span class="line">//+kubebuilder:rbac:groups=batch.graham924.com,resources=cronjobs/finalizers,verbs=update</span><br><span class="line">//+kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=batch,resources=jobs/status,verbs=get</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">scheduledTimeAnnotation = &quot;batch.tutorial.kubebuilder.io/scheduled-at&quot;</span><br><span class="line">jobOwnerKey             = &quot;.metadata.controller&quot;</span><br><span class="line">apiGVStr                = batchv1.GroupVersion.String()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span><br><span class="line">// move the current state of the cluster closer to the desired state.</span><br><span class="line">// TODO(user): Modify the Reconcile function to compare the state specified by</span><br><span class="line">// the CronJob object against the actual cluster state, and then</span><br><span class="line">// perform operations to make the cluster state reflect the state specified by</span><br><span class="line">// the user.</span><br><span class="line">//</span><br><span class="line">// For more details, check Reconcile and its Result here:</span><br><span class="line">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.17.0/pkg/reconcile</span><br><span class="line">func (r *CronJobReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">var cronJob batchv1.CronJob</span><br><span class="line">if err := r.Get(ctx, req.NamespacedName, &amp;cronJob); err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to fetch CronJob&quot;)</span><br><span class="line">// we&#x27;ll ignore not-found errors, since they can&#x27;t be fixed by an immediate</span><br><span class="line">// requeue (we&#x27;ll need to wait for a new notification), and we can get them</span><br><span class="line">// on deleted requests.</span><br><span class="line">return ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var childJobs kbatch.JobList</span><br><span class="line">if err := r.List(ctx, &amp;childJobs, client.InNamespace(req.Namespace), client.MatchingFields&#123;jobOwnerKey: req.Name&#125;); err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to list child Jobs&quot;)</span><br><span class="line">return ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// find the active list of jobs</span><br><span class="line">var activeJobs []*kbatch.Job</span><br><span class="line">var successfulJobs []*kbatch.Job</span><br><span class="line">var failedJobs []*kbatch.Job</span><br><span class="line">var mostRecentTime *time.Time // find the last run so we can update the status</span><br><span class="line"></span><br><span class="line">isJobFinished := func(job *kbatch.Job) (bool, kbatch.JobConditionType) &#123;</span><br><span class="line">for _, c := range job.Status.Conditions &#123;</span><br><span class="line">if (c.Type == kbatch.JobComplete || c.Type == kbatch.JobFailed) &amp;&amp; c.Status == corev1.ConditionTrue &#123;</span><br><span class="line">return true, c.Type</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false, &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getScheduledTimeForJob := func(job *kbatch.Job) (*time.Time, error) &#123;</span><br><span class="line">timeRaw := job.Annotations[scheduledTimeAnnotation]</span><br><span class="line">if len(timeRaw) == 0 &#123;</span><br><span class="line">return nil, nil</span><br><span class="line">&#125;</span><br><span class="line">timeParsed, err := time.Parse(time.RFC3339, timeRaw)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return &amp;timeParsed, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i, job := range childJobs.Items &#123;</span><br><span class="line">_, conditionType := isJobFinished(&amp;job)</span><br><span class="line">switch conditionType &#123;</span><br><span class="line">case kbatch.JobComplete:</span><br><span class="line">successfulJobs = append(successfulJobs, &amp;childJobs.Items[i])</span><br><span class="line">case kbatch.JobFailed:</span><br><span class="line">failedJobs = append(failedJobs, &amp;childJobs.Items[i])</span><br><span class="line">default:</span><br><span class="line">activeJobs = append(activeJobs, &amp;childJobs.Items[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduledTimeForJob, err := getScheduledTimeForJob(&amp;job)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to parse scheduled time for job&quot;, &quot;job&quot;, job)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if scheduledTimeForJob != nil &#123;</span><br><span class="line">if mostRecentTime == nil || scheduledTimeForJob.After(*mostRecentTime) &#123;</span><br><span class="line">mostRecentTime = scheduledTimeForJob</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if mostRecentTime != nil &#123;</span><br><span class="line">cronJob.Status.LastScheduleTime = &amp;metav1.Time&#123;Time: *mostRecentTime&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cronJob.Status.LastScheduleTime = nil</span><br><span class="line">&#125;</span><br><span class="line">cronJob.Status.Active = nil</span><br><span class="line">for _, activeJob := range activeJobs &#123;</span><br><span class="line">jobRef, err := ref.GetReference(r.Scheme, activeJob)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to make reference to active job&quot;, &quot;job&quot;, activeJob)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">cronJob.Status.Active = append(cronJob.Status.Active, *jobRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.V(1).Info(&quot;job count&quot;, &quot;active jobs&quot;, len(activeJobs), &quot;successful jobs&quot;, len(successfulJobs), &quot;failed jobs&quot;, len(failedJobs))</span><br><span class="line"></span><br><span class="line">if err := r.Status().Update(ctx, &amp;cronJob); err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to update CronJob status&quot;)</span><br><span class="line">return ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if cronJob.Spec.FailedJobsHistoryLimit != nil &#123;</span><br><span class="line">sort.Slice(failedJobs, func(i, j int) bool &#123;</span><br><span class="line">if failedJobs[i].Status.StartTime == nil &#123;</span><br><span class="line">return failedJobs[j].Status.StartTime != nil</span><br><span class="line">&#125;</span><br><span class="line">return failedJobs[i].Status.StartTime.Before(failedJobs[j].Status.StartTime)</span><br><span class="line">&#125;)</span><br><span class="line">for i, job := range failedJobs &#123;</span><br><span class="line">if int32(i) &gt;= int32(len(failedJobs))-*cronJob.Spec.FailedJobsHistoryLimit &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if err := r.Delete(ctx, job, client.PropagationPolicy(metav1.DeletePropagationBackground)); client.IgnoreNotFound(err) != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to delete old failed job&quot;, &quot;job&quot;, job)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.V(0).Info(&quot;deleted old failed job&quot;, &quot;job&quot;, job)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if cronJob.Spec.SuccessfulJobsHistoryLimit != nil &#123;</span><br><span class="line">sort.Slice(successfulJobs, func(i, j int) bool &#123;</span><br><span class="line">if successfulJobs[i].Status.StartTime == nil &#123;</span><br><span class="line">return successfulJobs[j].Status.StartTime != nil</span><br><span class="line">&#125;</span><br><span class="line">return successfulJobs[i].Status.StartTime.Before(successfulJobs[j].Status.StartTime)</span><br><span class="line">&#125;)</span><br><span class="line">for i, job := range successfulJobs &#123;</span><br><span class="line">if int32(i) &gt;= int32(len(successfulJobs))-*cronJob.Spec.SuccessfulJobsHistoryLimit &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if err := r.Delete(ctx, job, client.PropagationPolicy(metav1.DeletePropagationBackground)); client.IgnoreNotFound(err) != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to delete old successful job&quot;, &quot;job&quot;, job)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.V(0).Info(&quot;deleted old successful job&quot;, &quot;job&quot;, job)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if cronJob.Spec.Suspend != nil &amp;&amp; *cronJob.Spec.Suspend &#123;</span><br><span class="line">log.V(1).Info(&quot;cronjob suspended, skipping&quot;)</span><br><span class="line">return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNextSchedule := func(cronJob *batchv1.CronJob, now time.Time) (lastMissed time.Time, next time.Time, err error) &#123;</span><br><span class="line">sched, err := cron.ParseStandard(cronJob.Spec.Schedule)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return time.Time&#123;&#125;, time.Time&#123;&#125;, fmt.Errorf(&quot;Unparseable schedule %q: %v&quot;, cronJob.Spec.Schedule, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for optimization purposes, cheat a bit and start from our last observed run time</span><br><span class="line">// we could reconstitute this here, but there&#x27;s not much point, since we&#x27;ve</span><br><span class="line">// just updated it.</span><br><span class="line">var earliestTime time.Time</span><br><span class="line">if cronJob.Status.LastScheduleTime != nil &#123;</span><br><span class="line">earliestTime = cronJob.Status.LastScheduleTime.Time</span><br><span class="line">&#125; else &#123;</span><br><span class="line">earliestTime = cronJob.ObjectMeta.CreationTimestamp.Time</span><br><span class="line">&#125;</span><br><span class="line">if cronJob.Spec.StartingDeadlineSeconds != nil &#123;</span><br><span class="line">// controller is not going to schedule anything below this point</span><br><span class="line">schedulingDeadline := now.Add(-time.Second * time.Duration(*cronJob.Spec.StartingDeadlineSeconds))</span><br><span class="line"></span><br><span class="line">if schedulingDeadline.After(earliestTime) &#123;</span><br><span class="line">earliestTime = schedulingDeadline</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if earliestTime.After(now) &#123;</span><br><span class="line">return time.Time&#123;&#125;, sched.Next(now), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">starts := 0</span><br><span class="line">for t := sched.Next(earliestTime); !t.After(now); t = sched.Next(t) &#123;</span><br><span class="line">lastMissed = t</span><br><span class="line">// An object might miss several starts. For example, if</span><br><span class="line">// controller gets wedged on Friday at 5:01pm when everyone has</span><br><span class="line">// gone home, and someone comes in on Tuesday AM and discovers</span><br><span class="line">// the problem and restarts the controller, then all the hourly</span><br><span class="line">// jobs, more than 80 of them for one hourly scheduledJob, should</span><br><span class="line">// all start running with no further intervention (if the scheduledJob</span><br><span class="line">// allows concurrency and late starts).</span><br><span class="line">//</span><br><span class="line">// However, if there is a bug somewhere, or incorrect clock</span><br><span class="line">// on controller&#x27;s server or apiservers (for setting creationTimestamp)</span><br><span class="line">// then there could be so many missed start times (it could be off</span><br><span class="line">// by decades or more), that it would eat up all the CPU and memory</span><br><span class="line">// of this controller. In that case, we want to not try to list</span><br><span class="line">// all the missed start times.</span><br><span class="line">starts++</span><br><span class="line">if starts &gt; 100 &#123;</span><br><span class="line">// We can&#x27;t get the most recent times so just return an empty slice</span><br><span class="line">return time.Time&#123;&#125;, time.Time&#123;&#125;, fmt.Errorf(&quot;Too many missed start times (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return lastMissed, sched.Next(now), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">missedRun, nextRun, err := getNextSchedule(&amp;cronJob, r.Now())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to figure out CronJob schedule&quot;)</span><br><span class="line">// we don&#x27;t really care about requeuing until we get an update that</span><br><span class="line">// fixes the schedule, so don&#x27;t return an error</span><br><span class="line">return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduledResult := ctrl.Result&#123;RequeueAfter: nextRun.Sub(r.Now())&#125;</span><br><span class="line">log = log.WithValues(&quot;now&quot;, r.Now(), &quot;next run&quot;, nextRun)</span><br><span class="line"></span><br><span class="line">if missedRun.IsZero() &#123;</span><br><span class="line">log.V(1).Info(&quot;no upcoming scheduled times, sleeping until next&quot;)</span><br><span class="line">return scheduledResult, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// make sure we&#x27;re not too late to start the run</span><br><span class="line">log = log.WithValues(&quot;current run&quot;, missedRun)</span><br><span class="line">tooLate := false</span><br><span class="line">if cronJob.Spec.StartingDeadlineSeconds != nil &#123;</span><br><span class="line">tooLate = missedRun.Add(time.Duration(*cronJob.Spec.StartingDeadlineSeconds) * time.Second).Before(r.Now())</span><br><span class="line">&#125;</span><br><span class="line">if tooLate &#123;</span><br><span class="line">log.V(1).Info(&quot;missed starting deadline for last run, sleeping till next&quot;)</span><br><span class="line">// TODO(directxman12): events</span><br><span class="line">return scheduledResult, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// figure out how to run this job -- concurrency policy might forbid us from running</span><br><span class="line">// multiple at the same time...</span><br><span class="line">if cronJob.Spec.ConcurrencyPolicy == batchv1.ForbidConcurrent &amp;&amp; len(activeJobs) &gt; 0 &#123;</span><br><span class="line">log.V(1).Info(&quot;concurrency policy blocks concurrent runs, skipping&quot;, &quot;num active&quot;, len(activeJobs))</span><br><span class="line">return scheduledResult, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...or instruct us to replace existing ones...</span><br><span class="line">if cronJob.Spec.ConcurrencyPolicy == batchv1.ReplaceConcurrent &#123;</span><br><span class="line">for _, activeJob := range activeJobs &#123;</span><br><span class="line">// we don&#x27;t care if the job was already deleted</span><br><span class="line">if err := r.Delete(ctx, activeJob, client.PropagationPolicy(metav1.DeletePropagationBackground)); client.IgnoreNotFound(err) != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to delete active job&quot;, &quot;job&quot;, activeJob)</span><br><span class="line">return ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructJobForCronJob := func(cronJob *batchv1.CronJob, scheduledTime time.Time) (*kbatch.Job, error) &#123;</span><br><span class="line">// We want job names for a given nominal start time to have a deterministic name to avoid the same job being created twice</span><br><span class="line">name := fmt.Sprintf(&quot;%s-%d&quot;, cronJob.Name, scheduledTime.Unix())</span><br><span class="line"></span><br><span class="line">job := &amp;kbatch.Job&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Labels:      make(map[string]string),</span><br><span class="line">Annotations: make(map[string]string),</span><br><span class="line">Name:        name,</span><br><span class="line">Namespace:   cronJob.Namespace,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: *cronJob.Spec.JobTemplate.Spec.DeepCopy(),</span><br><span class="line">&#125;</span><br><span class="line">for k, v := range cronJob.Spec.JobTemplate.Annotations &#123;</span><br><span class="line">job.Annotations[k] = v</span><br><span class="line">&#125;</span><br><span class="line">job.Annotations[scheduledTimeAnnotation] = scheduledTime.Format(time.RFC3339)</span><br><span class="line">for k, v := range cronJob.Spec.JobTemplate.Labels &#123;</span><br><span class="line">job.Labels[k] = v</span><br><span class="line">&#125;</span><br><span class="line">if err := ctrl.SetControllerReference(cronJob, job, r.Scheme); err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return job, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// actually make the job...</span><br><span class="line">job, err := constructJobForCronJob(&amp;cronJob, missedRun)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to construct job from template&quot;)</span><br><span class="line">// don&#x27;t bother requeuing until we get a change to the spec</span><br><span class="line">return scheduledResult, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...and create it on the cluster</span><br><span class="line">if err := r.Create(ctx, job); err != nil &#123;</span><br><span class="line">log.Error(err, &quot;unable to create Job for CronJob&quot;, &quot;job&quot;, job)</span><br><span class="line">return ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.V(1).Info(&quot;created Job for CronJob run&quot;, &quot;job&quot;, job)</span><br><span class="line"></span><br><span class="line">// we&#x27;ll requeue once we see the running job, and update our status</span><br><span class="line">return scheduledResult, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SetupWithManager sets up the controller with the Manager.</span><br><span class="line">func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error &#123;</span><br><span class="line">if r.Clock == nil &#123;</span><br><span class="line">r.Clock = realClock&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">if err := mgr.GetFieldIndexer().IndexField(context.Background(), &amp;kbatch.Job&#123;&#125;, jobOwnerKey, func(rawObj client.Object) []string &#123;</span><br><span class="line">// grab the job object, extract the owner...</span><br><span class="line">job := rawObj.(*kbatch.Job)</span><br><span class="line">owner := metav1.GetControllerOf(job)</span><br><span class="line">if owner == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">// ...make sure it&#x27;s a CronJob...</span><br><span class="line">if owner.APIVersion != apiGVStr || owner.Kind != &quot;CronJob&quot; &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...and if so, return it</span><br><span class="line">return []string&#123;owner.Name&#125;</span><br><span class="line">&#125;); err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;batchv1.CronJob&#123;&#125;).</span><br><span class="line">Owns(&amp;kbatch.Job&#123;&#125;).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubebuilder 实战演练之deploy-image插件的使用</title>
      <link href="/posts/4a17d0018.html"/>
      <url>/posts/4a17d0018.html</url>
      
        <content type="html"><![CDATA[<h2 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h2><p>我们期望开发一个Operator，能够实现如下效果：</p><ul><li>定义一个名为 Memcached 的 CR<ul><li>编写Controller具有调谐 Memcached 的能力<ul><li>Memcached Spec中有一个Size，Controller 将不允许创建的Memcached实例 超过Size</li><li>Controller 还要负责更新资源的 Status</li></ul></li></ul></li></ul><h2 id="开发项目"><a href="#开发项目" class="headerlink" title="开发项目"></a>开发项目</h2><ul><li><p>创建一个项目Project</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# mkdir $GOPATH/memcached-operator</span><br><span class="line">[root@master memcached-operator]# cd $GOPATH/memcached-operator</span><br><span class="line">[root@master memcached-operator]# kubebuilder init --domain=graham924.com --repo=graham924.com/memcached-operator</span><br><span class="line">INFO Writing kustomize manifests for you to edit...</span><br><span class="line">INFO Writing scaffold for you to edit...</span><br><span class="line">INFO Get controller runtime:</span><br><span class="line">$ go get sigs.k8s.io/controller-runtime@v0.17.0</span><br><span class="line">INFO Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Next: define a resource with:</span><br><span class="line">$ kubebuilder create api</span><br></pre></td></tr></table></figure></li><li><p>创建一个API</p></li><li><p>这里 kubebuilder create api时，使用 deploy-image等 参数，直接就完成了全部代码的生成</p></li></ul><h3 id="deploy-image插件"><a href="#deploy-image插件" class="headerlink" title="deploy-image插件"></a>deploy-image插件</h3><ul><li>这里我们在使用 kubebuilder create api 时，将使用 deploy-image 的 plugin，帮我们自动生成一些代码。完整命令如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create api --group cache --version v1alpha1 --kind Memcached --image=memcached:1.4.36-alpine --image-container-command=&quot;memcached,-m=64,-o,modern,-v&quot; --image-container-port=&quot;11211&quot; --run-as-user=&quot;1001&quot; --plugins=&quot;deploy-image/v1-alpha&quot; --make=false</span><br></pre></td></tr></table></figure>参数解释：</li><li>kubebuilder create api：这是 Kubebuilder 工具的命令，用于创建一个新的 API 资源。</li><li>–group cache：指定新创建的 API 资源所属的 API 组，这里指定为 “cache”。</li><li>–version v1alpha1：指定新创建的 API 资源的版本号，这里指定为 “v1alpha1”。</li><li>–kind Memcached：指定新创建的资源的种类（Kind），这里指定为 “Memcached”，即自定义资源的类型为 Memcached。</li><li>–image&#x3D;memcached:1.4.36-alpine：指定用于部署的镜像名称及版本，这里指定为 “memcached:1.4.36-alpine”。</li><li>–image-container-command&#x3D;”memcached,-m&#x3D;64,-o,modern,-v”：指定容器的启动命令，这里设置为在容器中运行 memcached 服务，并指定了一些参数如内存限制、存储模式等。</li><li>–image-container-port&#x3D;”11211”：指定容器监听的端口号，这里指定为 “11211”，通常是 memcached 服务的默认端口。</li><li>–run-as-user&#x3D;”1001”：指定容器运行时的用户 ID，这里指定为 “1001”。</li><li>–plugins&#x3D;”deploy-image&#x2F;v1-alpha”：指定要使用的插件，这里指定为部署镜像的插件 “deploy-image&#x2F;v1-alpha”，用于将镜像部署到目标环境中。</li><li>–make&#x3D;false：表示不立即构建二进制文件。当设置为 false 时，Kubebuilder 不会自动为你构建 Go 二进制文件，而是生成代码结构以供你自己构建。<br>kubebuilder create api 时，使用 deploy-image plugin，会帮我们额外生成什么？</li><li>controllers&#x2F;*_controller.go (脚手架controller的reconcile调谐逻辑框架)</li><li>controllers&#x2F;*_controller_test.go (scaffold the tests for the controller)</li><li>controllers&#x2F;*_suite_test.go (scaffold&#x2F;update the suite of tests)</li><li>api&#x2F;&#x2F;*_types.go (scaffold the specs for the new api)</li><li>config&#x2F;samples&#x2F;*_.yaml (scaffold default values for its CR)</li><li>main.go (update to add controller setup)</li><li>config&#x2F;manager&#x2F;manager.yaml (update with envvar to store the image)</li></ul><h3 id="创建API实践演示"><a href="#创建API实践演示" class="headerlink" title="创建API实践演示"></a>创建API实践演示</h3><ul><li><p>创建API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# kubebuilder create api --group cache --version v1alpha1 --kind Memcached --image=memcached:1.4.36-alpine --image-container-command=&quot;memcached,-m=64,-o,modern,-v&quot; --image-container-port=&quot;11211&quot; --run-as-user=&quot;1001&quot; --plugins=&quot;deploy-image/v1-alpha&quot; --make=false</span><br><span class="line">INFO updating scaffold with deploy-image/v1alpha1 plugin...</span><br><span class="line">INFO Writing scaffold for you to edit...</span><br><span class="line">INFO Writing scaffold for you to edit...</span><br><span class="line">INFO api/v1alpha1/memcached_types.go</span><br><span class="line">INFO api/v1alpha1/groupversion_info.go</span><br><span class="line">INFO internal/controller/suite_test.go</span><br><span class="line">INFO internal/controller/memcached_controller.go</span><br><span class="line">INFO internal/controller/memcached_controller_test.go</span><br><span class="line">INFO Writing kustomize manifests for you to edit...</span><br><span class="line">INFO api/v1alpha1/memcached_types.go</span><br><span class="line">INFO config/samples/cache_v1alpha1_memcached.yaml</span><br><span class="line">INFO internal/controller/memcached_controller.go</span><br><span class="line">INFO creating import for % graham924.com/memcached-operator/api/v1alpha1</span><br><span class="line">INFO internal/controller/memcached_controller_test.go</span><br><span class="line">INFO creating import for % graham924.com/memcached-operator/api/v1alpha1</span><br><span class="line">INFO Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">INFO Running make:</span><br><span class="line">$ make manifests</span><br><span class="line">mkdir -p /root/zgy/project/share-code-operator-study/memcached-operator/bin</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.14.0</span><br><span class="line">/root/zgy/project/share-code-operator-study/memcached-operator/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">Next: check the implementation of your new API and controller. If you do changes in the API run the manifests with:</span><br><span class="line">$ make manifests</span><br></pre></td></tr></table></figure></li><li><p>生成后的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# tree</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1alpha1</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       └── memcached_types.go</span><br><span class="line">├── bin</span><br><span class="line">│   └── controller-gen-v0.14.0</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── bases</span><br><span class="line">│   │   │   └── cache.graham924.com_memcacheds.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_auth_proxy_patch.yaml</span><br><span class="line">│   │   └── manager_config_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── auth_proxy_client_clusterrole.yaml</span><br><span class="line">│   │   ├── auth_proxy_role_binding.yaml</span><br><span class="line">│   │   ├── auth_proxy_role.yaml</span><br><span class="line">│   │   ├── auth_proxy_service.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── memcached_editor_role.yaml</span><br><span class="line">│   │   ├── memcached_viewer_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   └── samples</span><br><span class="line">│       ├── cache_v1alpha1_memcached.yaml</span><br><span class="line">│       └── kustomization.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── memcached_controller.go</span><br><span class="line">│       ├── memcached_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">18 directories, 41 files</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看CR的-types-go"><a href="#查看CR的-types-go" class="headerlink" title="查看CR的 types.go"></a>查看CR的 types.go</h3><p>因为我们使用了 deploy-image 插件，所以 api&#x2F;v1alpha1&#x2F;memcached_types.go 的 Spec、Status 中，会默认生成几个字段</p><ul><li>Spec 字段<ul><li>Size：使用 +kubebuilder:validation 标记 设置Size的值在1~3之间。</li><li>ContainerPort：容器Port</li></ul></li><li>Status 字段<ul><li>Conditions：描述资源的状态信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">// MemcachedSpec defines the desired state of Memcached</span><br><span class="line">type MemcachedSpec struct &#123;</span><br><span class="line">        // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span><br><span class="line">        // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line"></span><br><span class="line">        // Size defines the number of Memcached instances</span><br><span class="line">        // The following markers will use OpenAPI v3 schema to validate the value</span><br><span class="line">        // More info: https://book.kubebuilder.io/reference/markers/crd-validation.html</span><br><span class="line">        // +kubebuilder:validation:Minimum=1</span><br><span class="line">        // +kubebuilder:validation:Maximum=3</span><br><span class="line">        // +kubebuilder:validation:ExclusiveMaximum=false</span><br><span class="line">        Size int32 `json:&quot;size,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">        // Port defines the port that will be used to init the container with the image</span><br><span class="line">        ContainerPort int32 `json:&quot;containerPort,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MemcachedStatus defines the observed state of Memcached</span><br><span class="line">type MemcachedStatus struct &#123;</span><br><span class="line">        // Represents the observations of a Memcached&#x27;s current state.</span><br><span class="line">        // Memcached.status.conditions.type are: &quot;Available&quot;, &quot;Progressing&quot;, and &quot;Degraded&quot;</span><br><span class="line">        // Memcached.status.conditions.status are one of True, False, Unknown.</span><br><span class="line">        // Memcached.status.conditions.reason the value should be a CamelCase string and producers of specific</span><br><span class="line">        // condition types may define expected values and meanings for this field, and whether the values</span><br><span class="line">        // are considered a guaranteed API.</span><br><span class="line">        // Memcached.status.conditions.Message is a human readable message indicating details about the transition.</span><br><span class="line">        // For further information see: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties</span><br><span class="line"></span><br><span class="line">        Conditions []metav1.Condition `json:&quot;conditions,omitempty&quot; patchStrategy:&quot;merge&quot; patchMergeKey:&quot;type&quot; protobuf:&quot;bytes,1,rep,name=conditions&quot;`</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>kubebuilder的官方文档中，给出了各种用于配置&#x2F;代码生成的标记：<a href="https://book.kubebuilder.io/reference/markers">https://book.kubebuilder.io/reference/markers</a></li></ul></li></ul><h3 id="查看CR的资源定义文件CRD"><a href="#查看CR的资源定义文件CRD" class="headerlink" title="查看CR的资源定义文件CRD"></a>查看CR的资源定义文件CRD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">config/crd/bases/cache.example.com_memcacheds.yaml 文件</span><br><span class="line"></span><br><span class="line">[root@master memcached-operator]# cat config/crd/bases/cache.graham924.com_memcacheds.yaml</span><br><span class="line">---</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    controller-gen.kubebuilder.io/version: v0.14.0</span><br><span class="line">  name: memcacheds.cache.graham924.com</span><br><span class="line">spec:</span><br><span class="line">  group: cache.graham924.com</span><br><span class="line">  names:</span><br><span class="line">    kind: Memcached</span><br><span class="line">    listKind: MemcachedList</span><br><span class="line">    plural: memcacheds</span><br><span class="line">    singular: memcached</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">  - name: v1alpha1</span><br><span class="line">    schema:</span><br><span class="line">      openAPIV3Schema:</span><br><span class="line">        description: Memcached is the Schema for the memcacheds API</span><br><span class="line">        properties:</span><br><span class="line">          apiVersion:</span><br><span class="line">            description: |-</span><br><span class="line">              APIVersion defines the versioned schema of this representation of an object.</span><br><span class="line">              Servers should convert recognized schemas to the latest internal value, and</span><br><span class="line">              may reject unrecognized values.</span><br><span class="line">              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</span><br><span class="line">            type: string</span><br><span class="line">          kind:</span><br><span class="line">            description: |-</span><br><span class="line">              Kind is a string value representing the REST resource this object represents.</span><br><span class="line">              Servers may infer this from the endpoint the client submits requests to.</span><br><span class="line">              Cannot be updated.</span><br><span class="line">              In CamelCase.</span><br><span class="line">              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</span><br><span class="line">            type: string</span><br><span class="line">          metadata:</span><br><span class="line">            type: object</span><br><span class="line">          spec:</span><br><span class="line">            description: MemcachedSpec defines the desired state of Memcached</span><br><span class="line">            properties:</span><br><span class="line">              containerPort:</span><br><span class="line">                description: Port defines the port that will be used to init the container</span><br><span class="line">                  with the image</span><br><span class="line">                format: int32</span><br><span class="line">                type: integer</span><br><span class="line">              size:</span><br><span class="line">                description: |-</span><br><span class="line">                  Size defines the number of Memcached instances</span><br><span class="line">                  The following markers will use OpenAPI v3 schema to validate the value</span><br><span class="line">                  More info: https://book.kubebuilder.io/reference/markers/crd-validation.html</span><br><span class="line">                format: int32</span><br><span class="line">                maximum: 3</span><br><span class="line">                minimum: 1</span><br><span class="line">                type: integer</span><br><span class="line">            type: object</span><br><span class="line">          status:</span><br><span class="line">            description: MemcachedStatus defines the observed state of Memcached</span><br><span class="line">            properties:</span><br><span class="line">              conditions:</span><br><span class="line">                items:</span><br><span class="line">                  description: &quot;Condition contains details for one aspect of the current</span><br><span class="line">                    state of this API Resource.\n---\nThis struct is intended for</span><br><span class="line">                    direct use as an array at the field path .status.conditions.  For</span><br><span class="line">                    example,\n\n\n\ttype FooStatus struct&#123;\n\t    // Represents the</span><br><span class="line">                    observations of a foo&#x27;s current state.\n\t    // Known .status.conditions.type</span><br><span class="line">                    are: \&quot;Available\&quot;, \&quot;Progressing\&quot;, and \&quot;Degraded\&quot;\n\t    //</span><br><span class="line">                    +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    // +listType=map\n\t</span><br><span class="line">                    \   // +listMapKey=type\n\t    Conditions []metav1.Condition `json:\&quot;conditions,omitempty\&quot;</span><br><span class="line">                    patchStrategy:\&quot;merge\&quot; patchMergeKey:\&quot;type\&quot; protobuf:\&quot;bytes,1,rep,name=conditions\&quot;`\n\n\n\t</span><br><span class="line">                    \   // other fields\n\t&#125;&quot;</span><br><span class="line">                  properties:</span><br><span class="line">                    lastTransitionTime:</span><br><span class="line">                      description: |-</span><br><span class="line">                        lastTransitionTime is the last time the condition transitioned from one status to another.</span><br><span class="line">                        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.</span><br><span class="line">                      format: date-time</span><br><span class="line">                      type: string</span><br><span class="line">                    message:</span><br><span class="line">                      description: |-</span><br><span class="line">                        message is a human readable message indicating details about the transition.</span><br><span class="line">                        This may be an empty string.</span><br><span class="line">                      maxLength: 32768</span><br><span class="line">                      type: string</span><br><span class="line">                    observedGeneration:</span><br><span class="line">                      description: |-</span><br><span class="line">                        observedGeneration represents the .metadata.generation that the condition was set based upon.</span><br><span class="line">                        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date</span><br><span class="line">                        with respect to the current state of the instance.</span><br><span class="line">                      format: int64</span><br><span class="line">                      minimum: 0</span><br><span class="line">                      type: integer</span><br><span class="line">                    reason:</span><br><span class="line">                      description: |-</span><br><span class="line">                        reason contains a programmatic identifier indicating the reason for the condition&#x27;s last transition.</span><br><span class="line">                        Producers of specific condition types may define expected values and meanings for this field,</span><br><span class="line">                        and whether the values are considered a guaranteed API.</span><br><span class="line">                        The value should be a CamelCase string.</span><br><span class="line">                        This field may not be empty.</span><br><span class="line">                      maxLength: 1024</span><br><span class="line">                      minLength: 1</span><br><span class="line">                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$</span><br><span class="line">                      type: string</span><br><span class="line">                    status:</span><br><span class="line">                      description: status of the condition, one of True, False, Unknown.</span><br><span class="line">                      enum:</span><br><span class="line">                      - &quot;True&quot;</span><br><span class="line">                      - &quot;False&quot;</span><br><span class="line">                      - Unknown</span><br><span class="line">                      type: string</span><br><span class="line">                    type:</span><br><span class="line">                      description: |-</span><br><span class="line">                        type of condition in CamelCase or in foo.example.com/CamelCase.</span><br><span class="line">                        ---</span><br><span class="line">                        Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be</span><br><span class="line">                        useful (see .node.status.conditions), the ability to deconflict is important.</span><br><span class="line">                        The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)</span><br><span class="line">                      maxLength: 316</span><br><span class="line">                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$</span><br><span class="line">                      type: string</span><br><span class="line">                  required:</span><br><span class="line">                  - lastTransitionTime</span><br><span class="line">                  - message</span><br><span class="line">                  - reason</span><br><span class="line">                  - status</span><br><span class="line">                  - type</span><br><span class="line">                  type: object</span><br><span class="line">                type: array</span><br><span class="line">            type: object</span><br><span class="line">        type: object</span><br><span class="line">    served: true</span><br><span class="line">    storage: true</span><br><span class="line">    subresources:</span><br><span class="line">      status: &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，+kubebuilder 标记的内容，会展示在CRD的定义文件中的，下面以Spec的内容为例，Status的内容也是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  description: MemcachedSpec defines the desired state of Memcached</span><br><span class="line">  properties:</span><br><span class="line">    containerPort:</span><br><span class="line">      description: Port defines the port that will be used to init the container</span><br><span class="line">        with the image</span><br><span class="line">      format: int32</span><br><span class="line">      type: integer</span><br><span class="line">    size:</span><br><span class="line">      description: |-</span><br><span class="line">        Size defines the number of Memcached instances</span><br><span class="line">        The following markers will use OpenAPI v3 schema to validate the value</span><br><span class="line">        More info: https://book.kubebuilder.io/reference/markers/crd-validation.html</span><br><span class="line">      format: int32</span><br><span class="line">      maximum: 3</span><br><span class="line">      minimum: 1</span><br><span class="line">      type: integer</span><br><span class="line">  type: object</span><br></pre></td></tr></table></figure><h3 id="查看CR-yaml示例"><a href="#查看CR-yaml示例" class="headerlink" title="查看CR yaml示例"></a>查看CR yaml示例</h3><ul><li>config&#x2F;crd&#x2F;bases&#x2F;cache.example.com_memcacheds.yaml 文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: cache.graham924.com/v1alpha1</span><br><span class="line">kind: Memcached</span><br><span class="line">metadata:</span><br><span class="line">  name: memcached-sample</span><br><span class="line">spec:</span><br><span class="line">  # TODO(user): edit the following value to ensure the number</span><br><span class="line">  # of Pods/Instances your Operand must have on cluster</span><br><span class="line">  size: 1</span><br><span class="line"></span><br><span class="line">  # TODO(user): edit the following value to ensure the container has the right port to be initialized</span><br><span class="line">  containerPort: 11211</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看CR的-controller-go"><a href="#查看CR的-controller-go" class="headerlink" title="查看CR的 controller.go"></a>查看CR的 controller.go</h3><p>因为我们使用了 deploy-image 插件，所以 internal&#x2F;controller&#x2F;memcached_controller.go 的 Reconcile 已经给生成了很多代码逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Copyright 2024.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;os&quot;</span><br><span class="line">        &quot;strings&quot;</span><br><span class="line">        &quot;time&quot;</span><br><span class="line"></span><br><span class="line">        appsv1 &quot;k8s.io/api/apps/v1&quot;</span><br><span class="line">        corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">        apierrors &quot;k8s.io/apimachinery/pkg/api/errors&quot;</span><br><span class="line">        &quot;k8s.io/apimachinery/pkg/api/meta&quot;</span><br><span class="line">        metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">        &quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">        &quot;k8s.io/apimachinery/pkg/types&quot;</span><br><span class="line">        &quot;k8s.io/client-go/tools/record&quot;</span><br><span class="line">        ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">        &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span><br><span class="line">        &quot;sigs.k8s.io/controller-runtime/pkg/controller/controllerutil&quot;</span><br><span class="line">        &quot;sigs.k8s.io/controller-runtime/pkg/log&quot;</span><br><span class="line"></span><br><span class="line">        cachev1alpha1 &quot;graham924.com/memcached-operator/api/v1alpha1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const memcachedFinalizer = &quot;cache.graham924.com/finalizer&quot;</span><br><span class="line"></span><br><span class="line">// Definitions to manage status conditions</span><br><span class="line">const (</span><br><span class="line">        // typeAvailableMemcached represents the status of the Deployment reconciliation</span><br><span class="line">        typeAvailableMemcached = &quot;Available&quot;</span><br><span class="line">        // typeDegradedMemcached represents the status used when the custom resource is deleted and the finalizer operations are must to occur.</span><br><span class="line">        typeDegradedMemcached = &quot;Degraded&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// MemcachedReconciler reconciles a Memcached object</span><br><span class="line">type MemcachedReconciler struct &#123;</span><br><span class="line">        client.Client</span><br><span class="line">        Scheme   *runtime.Scheme</span><br><span class="line">        Recorder record.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The following markers are used to generate the rules permissions (RBAC) on config/rbac using controller-gen</span><br><span class="line">// when the command &lt;make manifests&gt; is executed.</span><br><span class="line">// To know more about markers see: https://book.kubebuilder.io/reference/markers.html</span><br><span class="line"></span><br><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds/status,verbs=get;update;patch</span><br><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds/finalizers,verbs=update</span><br><span class="line">//+kubebuilder:rbac:groups=core,resources=events,verbs=create;patch</span><br><span class="line">//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch</span><br><span class="line"></span><br><span class="line">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span><br><span class="line">// move the current state of the cluster closer to the desired state.</span><br><span class="line">// It is essential for the controller&#x27;s reconciliation loop to be idempotent. By following the Operator</span><br><span class="line">// pattern you will create Controllers which provide a reconcile function</span><br><span class="line">// responsible for synchronizing resources until the desired state is reached on the cluster.</span><br><span class="line">// Breaking this recommendation goes against the design principles of controller-runtime.</span><br><span class="line">// and may lead to unforeseen consequences such as resources becoming stuck and requiring manual intervention.</span><br><span class="line">// For further info:</span><br><span class="line">// - About Operator Pattern: https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</span><br><span class="line">// - About Controllers: https://kubernetes.io/docs/concepts/architecture/controller/</span><br><span class="line">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.17.0/pkg/reconcile</span><br><span class="line">func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">        log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">        // Fetch the Memcached instance</span><br><span class="line">        // The purpose is check if the Custom Resource for the Kind Memcached</span><br><span class="line">        // is applied on the cluster if not we return nil to stop the reconciliation</span><br><span class="line">        memcached := &amp;cachev1alpha1.Memcached&#123;&#125;</span><br><span class="line">        err := r.Get(ctx, req.NamespacedName, memcached)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                if apierrors.IsNotFound(err) &#123;</span><br><span class="line">                        // If the custom resource is not found then, it usually means that it was deleted or not created</span><br><span class="line">                        // In this way, we will stop the reconciliation</span><br><span class="line">                        log.Info(&quot;memcached resource not found. Ignoring since object must be deleted&quot;)</span><br><span class="line">                        return ctrl.Result&#123;&#125;, nil</span><br><span class="line">                &#125;</span><br><span class="line">                // Error reading the object - requeue the request.</span><br><span class="line">                log.Error(err, &quot;Failed to get memcached&quot;)</span><br><span class="line">                return ctrl.Result&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Let&#x27;s just set the status as Unknown when no status are available</span><br><span class="line">        if memcached.Status.Conditions == nil || len(memcached.Status.Conditions) == 0 &#123;</span><br><span class="line">                meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeAvailableMemcached, Status: metav1.ConditionUnknown, Reason: &quot;Reconciling&quot;, Message: &quot;Starting reconciliation&quot;&#125;)</span><br><span class="line">                if err = r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Let&#x27;s re-fetch the memcached Custom Resource after update the status</span><br><span class="line">                // so that we have the latest state of the resource on the cluster and we will avoid</span><br><span class="line">                // raise the issue &quot;the object has been modified, please apply</span><br><span class="line">                // your changes to the latest version and try again&quot; which would re-trigger the reconciliation</span><br><span class="line">                // if we try to update it again in the following operations</span><br><span class="line">                if err := r.Get(ctx, req.NamespacedName, memcached); err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to re-fetch memcached&quot;)</span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Let&#x27;s add a finalizer. Then, we can define some operations which should</span><br><span class="line">        // occurs before the custom resource to be deleted.</span><br><span class="line">        // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers</span><br><span class="line">        if !controllerutil.ContainsFinalizer(memcached, memcachedFinalizer) &#123;</span><br><span class="line">                log.Info(&quot;Adding Finalizer for Memcached&quot;)</span><br><span class="line">                if ok := controllerutil.AddFinalizer(memcached, memcachedFinalizer); !ok &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to add finalizer into the custom resource&quot;)</span><br><span class="line">                        return ctrl.Result&#123;Requeue: true&#125;, nil</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if err = r.Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to update custom resource to add finalizer&quot;)</span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if the Memcached instance is marked to be deleted, which is</span><br><span class="line">        // indicated by the deletion timestamp being set.</span><br><span class="line">        isMemcachedMarkedToBeDeleted := memcached.GetDeletionTimestamp() != nil</span><br><span class="line">        if isMemcachedMarkedToBeDeleted &#123;</span><br><span class="line">                if controllerutil.ContainsFinalizer(memcached, memcachedFinalizer) &#123;</span><br><span class="line">                        log.Info(&quot;Performing Finalizer Operations for Memcached before delete CR&quot;)</span><br><span class="line"></span><br><span class="line">                        // Let&#x27;s add here an status &quot;Downgrade&quot; to define that this resource begin its process to be terminated.</span><br><span class="line">                        meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeDegradedMemcached,</span><br><span class="line">                                Status: metav1.ConditionUnknown, Reason: &quot;Finalizing&quot;,</span><br><span class="line">                                Message: fmt.Sprintf(&quot;Performing finalizer operations for the custom resource: %s &quot;, memcached.Name)&#125;)</span><br><span class="line"></span><br><span class="line">                        if err := r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // Perform all operations required before remove the finalizer and allow</span><br><span class="line">                        // the Kubernetes API to remove the custom resource.</span><br><span class="line">                        r.doFinalizerOperationsForMemcached(memcached)</span><br><span class="line"></span><br><span class="line">                        // TODO(user): If you add operations to the doFinalizerOperationsForMemcached method</span><br><span class="line">                        // then you need to ensure that all worked fine before deleting and updating the Downgrade status</span><br><span class="line">                        // otherwise, you should requeue here.</span><br><span class="line"></span><br><span class="line">                        // Re-fetch the memcached Custom Resource before update the status</span><br><span class="line">                        // so that we have the latest state of the resource on the cluster and we will avoid</span><br><span class="line">                        // raise the issue &quot;the object has been modified, please apply</span><br><span class="line">                        // your changes to the latest version and try again&quot; which would re-trigger the reconciliation</span><br><span class="line">                        if err := r.Get(ctx, req.NamespacedName, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to re-fetch memcached&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeDegradedMemcached,</span><br><span class="line">                                Status: metav1.ConditionTrue, Reason: &quot;Finalizing&quot;,</span><br><span class="line">                                Message: fmt.Sprintf(&quot;Finalizer operations for custom resource %s name were successfully accomplished&quot;, memcached.Name)&#125;)</span><br><span class="line"></span><br><span class="line">                        if err := r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        log.Info(&quot;Removing Finalizer for Memcached after successfully perform the operations&quot;)</span><br><span class="line">                        if ok := controllerutil.RemoveFinalizer(memcached, memcachedFinalizer); !ok &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to remove finalizer for Memcached&quot;)</span><br><span class="line">                                return ctrl.Result&#123;Requeue: true&#125;, nil</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if err := r.Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to remove finalizer for Memcached&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ctrl.Result&#123;&#125;, nil</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if the deployment already exists, if not create a new one</span><br><span class="line">        found := &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">        err = r.Get(ctx, types.NamespacedName&#123;Name: memcached.Name, Namespace: memcached.Namespace&#125;, found)</span><br><span class="line">        if err != nil &amp;&amp; apierrors.IsNotFound(err) &#123;</span><br><span class="line">                // Define a new deployment</span><br><span class="line">                dep, err := r.deploymentForMemcached(memcached)</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to define new Deployment resource for Memcached&quot;)</span><br><span class="line"></span><br><span class="line">                        // The following implementation will update the status</span><br><span class="line">                        meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeAvailableMemcached,</span><br><span class="line">                                Status: metav1.ConditionFalse, Reason: &quot;Reconciling&quot;,</span><br><span class="line">                                Message: fmt.Sprintf(&quot;Failed to create Deployment for the custom resource (%s): (%s)&quot;, memcached.Name, err)&#125;)</span><br><span class="line"></span><br><span class="line">                        if err := r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                log.Info(&quot;Creating a new Deployment&quot;,</span><br><span class="line">                        &quot;Deployment.Namespace&quot;, dep.Namespace, &quot;Deployment.Name&quot;, dep.Name)</span><br><span class="line">                if err = r.Create(ctx, dep); err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to create new Deployment&quot;,</span><br><span class="line">                                &quot;Deployment.Namespace&quot;, dep.Namespace, &quot;Deployment.Name&quot;, dep.Name)</span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Deployment created successfully</span><br><span class="line">                // We will requeue the reconciliation so that we can ensure the state</span><br><span class="line">                // and move forward for the next operations</span><br><span class="line">                return ctrl.Result&#123;RequeueAfter: time.Minute&#125;, nil</span><br><span class="line">        &#125; else if err != nil &#123;</span><br><span class="line">                log.Error(err, &quot;Failed to get Deployment&quot;)</span><br><span class="line">                // Let&#x27;s return the error for the reconciliation be re-trigged again</span><br><span class="line">                return ctrl.Result&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The CRD API is defining that the Memcached type, have a MemcachedSpec.Size field</span><br><span class="line">        // to set the quantity of Deployment instances is the desired state on the cluster.</span><br><span class="line">        // Therefore, the following code will ensure the Deployment size is the same as defined</span><br><span class="line">        // via the Size spec of the Custom Resource which we are reconciling.</span><br><span class="line">        size := memcached.Spec.Size</span><br><span class="line">        if *found.Spec.Replicas != size &#123;</span><br><span class="line">                found.Spec.Replicas = &amp;size</span><br><span class="line">                if err = r.Update(ctx, found); err != nil &#123;</span><br><span class="line">                        log.Error(err, &quot;Failed to update Deployment&quot;,</span><br><span class="line">                                &quot;Deployment.Namespace&quot;, found.Namespace, &quot;Deployment.Name&quot;, found.Name)</span><br><span class="line"></span><br><span class="line">                        // Re-fetch the memcached Custom Resource before update the status</span><br><span class="line">                        // so that we have the latest state of the resource on the cluster and we will avoid</span><br><span class="line">                        // raise the issue &quot;the object has been modified, please apply</span><br><span class="line">                        // your changes to the latest version and try again&quot; which would re-trigger the reconciliation</span><br><span class="line">                        if err := r.Get(ctx, req.NamespacedName, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to re-fetch memcached&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // The following implementation will update the status</span><br><span class="line">                        meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeAvailableMemcached,</span><br><span class="line">                                Status: metav1.ConditionFalse, Reason: &quot;Resizing&quot;,</span><br><span class="line">                                Message: fmt.Sprintf(&quot;Failed to update the size for the custom resource (%s): (%s)&quot;, memcached.Name, err)&#125;)</span><br><span class="line"></span><br><span class="line">                        if err := r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                                log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                                return ctrl.Result&#123;&#125;, err</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        return ctrl.Result&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Now, that we update the size we want to requeue the reconciliation</span><br><span class="line">                // so that we can ensure that we have the latest state of the resource before</span><br><span class="line">                // update. Also, it will help ensure the desired state on the cluster</span><br><span class="line">                return ctrl.Result&#123;Requeue: true&#125;, nil</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The following implementation will update the status</span><br><span class="line">        meta.SetStatusCondition(&amp;memcached.Status.Conditions, metav1.Condition&#123;Type: typeAvailableMemcached,</span><br><span class="line">                Status: metav1.ConditionTrue, Reason: &quot;Reconciling&quot;,</span><br><span class="line">                Message: fmt.Sprintf(&quot;Deployment for custom resource (%s) with %d replicas created successfully&quot;, memcached.Name, size)&#125;)</span><br><span class="line"></span><br><span class="line">        if err := r.Status().Update(ctx, memcached); err != nil &#123;</span><br><span class="line">                log.Error(err, &quot;Failed to update Memcached status&quot;)</span><br><span class="line">                return ctrl.Result&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// finalizeMemcached will perform the required operations before delete the CR.</span><br><span class="line">func (r *MemcachedReconciler) doFinalizerOperationsForMemcached(cr *cachev1alpha1.Memcached) &#123;</span><br><span class="line">        // TODO(user): Add the cleanup steps that the operator</span><br><span class="line">        // needs to do before the CR can be deleted. Examples</span><br><span class="line">        // of finalizers include performing backups and deleting</span><br><span class="line">        // resources that are not owned by this CR, like a PVC.</span><br><span class="line"></span><br><span class="line">        // Note: It is not recommended to use finalizers with the purpose of delete resources which are</span><br><span class="line">        // created and managed in the reconciliation. These ones, such as the Deployment created on this reconcile,</span><br><span class="line">        // are defined as depended of the custom resource. See that we use the method ctrl.SetControllerReference.</span><br><span class="line">        // to set the ownerRef which means that the Deployment will be deleted by the Kubernetes API.</span><br><span class="line">        // More info: https://kubernetes.io/docs/tasks/administer-cluster/use-cascading-deletion/</span><br><span class="line"></span><br><span class="line">        // The following implementation will raise an event</span><br><span class="line">        r.Recorder.Event(cr, &quot;Warning&quot;, &quot;Deleting&quot;,</span><br><span class="line">                fmt.Sprintf(&quot;Custom Resource %s is being deleted from the namespace %s&quot;,</span><br><span class="line">                        cr.Name,</span><br><span class="line">                        cr.Namespace))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// deploymentForMemcached returns a Memcached Deployment object</span><br><span class="line">func (r *MemcachedReconciler) deploymentForMemcached(</span><br><span class="line">        memcached *cachev1alpha1.Memcached) (*appsv1.Deployment, error) &#123;</span><br><span class="line">        ls := labelsForMemcached(memcached.Name)</span><br><span class="line">        replicas := memcached.Spec.Size</span><br><span class="line"></span><br><span class="line">        // Get the Operand image</span><br><span class="line">        image, err := imageForMemcached()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dep := &amp;appsv1.Deployment&#123;</span><br><span class="line">                ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">                        Name:      memcached.Name,</span><br><span class="line">                        Namespace: memcached.Namespace,</span><br><span class="line">                &#125;,</span><br><span class="line">                Spec: appsv1.DeploymentSpec&#123;</span><br><span class="line">                        Replicas: &amp;replicas,</span><br><span class="line">                        Selector: &amp;metav1.LabelSelector&#123;</span><br><span class="line">                                MatchLabels: ls,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        Template: corev1.PodTemplateSpec&#123;</span><br><span class="line">                                ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">                                        Labels: ls,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                Spec: corev1.PodSpec&#123;</span><br><span class="line">                                        // TODO(user): Uncomment the following code to configure the nodeAffinity expression</span><br><span class="line">                                        // according to the platforms which are supported by your solution. It is considered</span><br><span class="line">                                        // best practice to support multiple architectures. build your manager image using the</span><br><span class="line">                                        // makefile target docker-buildx. Also, you can use docker manifest inspect &lt;image&gt;</span><br><span class="line">                                        // to check what are the platforms supported.</span><br><span class="line">                                        // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity</span><br><span class="line">                                        //Affinity: &amp;corev1.Affinity&#123;</span><br><span class="line">                                        //      NodeAffinity: &amp;corev1.NodeAffinity&#123;</span><br><span class="line">                                        //              RequiredDuringSchedulingIgnoredDuringExecution: &amp;corev1.NodeSelector&#123;</span><br><span class="line">                                        //                      NodeSelectorTerms: []corev1.NodeSelectorTerm&#123;</span><br><span class="line">                                        //                              &#123;</span><br><span class="line">                                        //                                      MatchExpressions: []corev1.NodeSelectorRequirement&#123;</span><br><span class="line">                                        //                                              &#123;</span><br><span class="line">                                        //                                                      Key:      &quot;kubernetes.io/arch&quot;,</span><br><span class="line">                                        //                                                      Operator: &quot;In&quot;,</span><br><span class="line">                                        //                                                      Values:   []string&#123;&quot;amd64&quot;, &quot;arm64&quot;, &quot;ppc64le&quot;, &quot;s390x&quot;&#125;,</span><br><span class="line">                                        //                                              &#125;,</span><br><span class="line">                                        //                                              &#123;</span><br><span class="line">                                        //                                                      Key:      &quot;kubernetes.io/os&quot;,</span><br><span class="line">                                        //                                                      Operator: &quot;In&quot;,</span><br><span class="line">                                        //                                                      Values:   []string&#123;&quot;linux&quot;&#125;,</span><br><span class="line">                                        //                                              &#125;,</span><br><span class="line">                                        //                                      &#125;,</span><br><span class="line">                                        //                              &#125;,</span><br><span class="line">                                        //                      &#125;,</span><br><span class="line">                                        //              &#125;,</span><br><span class="line">                                        //      &#125;,</span><br><span class="line">                                        //&#125;,</span><br><span class="line">                                        SecurityContext: &amp;corev1.PodSecurityContext&#123;</span><br><span class="line">                                                RunAsNonRoot: &amp;[]bool&#123;true&#125;[0],</span><br><span class="line">                                                // IMPORTANT: seccomProfile was introduced with Kubernetes 1.19</span><br><span class="line">                                                // If you are looking for to produce solutions to be supported</span><br><span class="line">                                                // on lower versions you must remove this option.</span><br><span class="line">                                                SeccompProfile: &amp;corev1.SeccompProfile&#123;</span><br><span class="line">                                                        Type: corev1.SeccompProfileTypeRuntimeDefault,</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        Containers: []corev1.Container&#123;&#123;</span><br><span class="line">                                                Image:           image,</span><br><span class="line">                                                Name:            &quot;memcached&quot;,</span><br><span class="line">                                                ImagePullPolicy: corev1.PullIfNotPresent,</span><br><span class="line">                                                // Ensure restrictive context for the container</span><br><span class="line">                                                // More info: https://kubernetes.io/docs/concepts/security/pod-security-standards/#restricted</span><br><span class="line">                                                SecurityContext: &amp;corev1.SecurityContext&#123;</span><br><span class="line">                                                        RunAsNonRoot:             &amp;[]bool&#123;true&#125;[0],</span><br><span class="line">                                                        RunAsUser:                &amp;[]int64&#123;1001&#125;[0],</span><br><span class="line">                                                        AllowPrivilegeEscalation: &amp;[]bool&#123;false&#125;[0],</span><br><span class="line">                                                        Capabilities: &amp;corev1.Capabilities&#123;</span><br><span class="line">                                                                Drop: []corev1.Capability&#123;</span><br><span class="line">                                                                        &quot;ALL&quot;,</span><br><span class="line">                                                                &#125;,</span><br><span class="line">                                                        &#125;,</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                Ports: []corev1.ContainerPort&#123;&#123;</span><br><span class="line">                                                        ContainerPort: memcached.Spec.ContainerPort,</span><br><span class="line">                                                        Name:          &quot;memcached&quot;,</span><br><span class="line">                                                &#125;&#125;,</span><br><span class="line">                                                Command: []string&#123;&quot;memcached&quot;, &quot;-m=64&quot;, &quot;-o&quot;, &quot;modern&quot;, &quot;-v&quot;&#125;,</span><br><span class="line">                                        &#125;&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set the ownerRef for the Deployment</span><br><span class="line">        // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/</span><br><span class="line">        if err := ctrl.SetControllerReference(memcached, dep, r.Scheme); err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        return dep, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// labelsForMemcached returns the labels for selecting the resources</span><br><span class="line">// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/</span><br><span class="line">func labelsForMemcached(name string) map[string]string &#123;</span><br><span class="line">        var imageTag string</span><br><span class="line">        image, err := imageForMemcached()</span><br><span class="line">        if err == nil &#123;</span><br><span class="line">                imageTag = strings.Split(image, &quot;:&quot;)[1]</span><br><span class="line">        &#125;</span><br><span class="line">        return map[string]string&#123;&quot;app.kubernetes.io/name&quot;: &quot;Memcached&quot;,</span><br><span class="line">                &quot;app.kubernetes.io/instance&quot;:   name,</span><br><span class="line">                &quot;app.kubernetes.io/version&quot;:    imageTag,</span><br><span class="line">                &quot;app.kubernetes.io/part-of&quot;:    &quot;memcached-operator&quot;,</span><br><span class="line">                &quot;app.kubernetes.io/created-by&quot;: &quot;controller-manager&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// imageForMemcached gets the Operand image which is managed by this controller</span><br><span class="line">// from the MEMCACHED_IMAGE environment variable defined in the config/manager/manager.yaml</span><br><span class="line">func imageForMemcached() (string, error) &#123;</span><br><span class="line">        var imageEnvVar = &quot;MEMCACHED_IMAGE&quot;</span><br><span class="line">        image, found := os.LookupEnv(imageEnvVar)</span><br><span class="line">        if !found &#123;</span><br><span class="line">                return &quot;&quot;, fmt.Errorf(&quot;Unable to find %s environment variable with the image&quot;, imageEnvVar)</span><br><span class="line">        &#125;</span><br><span class="line">        return image, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SetupWithManager sets up the controller with the Manager.</span><br><span class="line">// Note that the Deployment will be also watched in order to ensure its</span><br><span class="line">// desirable state on the cluster</span><br><span class="line">func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error &#123;</span><br><span class="line">        return ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">                For(&amp;cachev1alpha1.Memcached&#123;&#125;).</span><br><span class="line">                Owns(&amp;appsv1.Deployment&#123;&#125;).</span><br><span class="line">                Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller-go-中-SetupWithManager-方法"><a href="#controller-go-中-SetupWithManager-方法" class="headerlink" title="controller.go 中 SetupWithManager 方法"></a>controller.go 中 SetupWithManager 方法</h3><ul><li>SetupWithManager 方法中，已经为我们的CR创建ListWatch机制了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SetupWithManager sets up the controller with the Manager.</span><br><span class="line">// Note that the Deployment will be also watched in order to ensure its</span><br><span class="line">// desirable state on the cluster</span><br><span class="line">func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error &#123;</span><br><span class="line">        return ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">                For(&amp;cachev1alpha1.Memcached&#123;&#125;).</span><br><span class="line">                Owns(&amp;appsv1.Deployment&#123;&#125;).</span><br><span class="line">                Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Manager 是controller-runtime提供的组件，用于监督和管理 Controller。SetupWithManager 方法就是将 当前Controller注册到 Manager 中</p><h3 id="controller-go-中-设置deployment-的-ownerRef"><a href="#controller-go-中-设置deployment-的-ownerRef" class="headerlink" title="controller.go 中 设置deployment 的 ownerRef"></a>controller.go 中 设置deployment 的 ownerRef</h3><ul><li>deploymentForMemcached 中，创建的deployment，ownerRef 已经给设置成了相应的Memcached资源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// deploymentForMemcached returns a Memcached Deployment object</span><br><span class="line">func (r *MemcachedReconciler) deploymentForMemcached(</span><br><span class="line">        memcached *cachev1alpha1.Memcached) (*appsv1.Deployment, error) &#123;</span><br><span class="line">        ls := labelsForMemcached(memcached.Name)</span><br><span class="line">        replicas := memcached.Spec.Size</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">if err := ctrl.SetControllerReference(memcached, dep, r.Scheme); err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        return dep, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="controller-go-中-rbac-的-kubebuilder-标记"><a href="#controller-go-中-rbac-的-kubebuilder-标记" class="headerlink" title="controller.go 中 rbac 的 kubebuilder 标记"></a>controller.go 中 rbac 的 kubebuilder 标记</h3><ul><li>Reconcile 方法上方，使用 rbac 的 kubebuilder 标记，标记了当前Operator的访问权限</li><li>当你修改 controller.go 里的rbac标记后，需要执行 make manifests 或 make generate 更新 config&#x2F;rbac 目录下的rbac权限文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds/status,verbs=get;update;patch</span><br><span class="line">//+kubebuilder:rbac:groups=cache.graham924.com,resources=memcacheds/finalizers,verbs=update</span><br><span class="line">//+kubebuilder:rbac:groups=core,resources=events,verbs=create;patch</span><br><span class="line">//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">//+kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch</span><br></pre></td></tr></table></figure></li></ul><h2 id="CRD-及-Controller-部署"><a href="#CRD-及-Controller-部署" class="headerlink" title="CRD 及 Controller 部署"></a>CRD 及 Controller 部署</h2><h3 id="安装CRD"><a href="#安装CRD" class="headerlink" title="安装CRD"></a>安装CRD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# make install</span><br><span class="line">/root/zgy/project/share-code-operator-study/memcached-operator/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">Downloading sigs.k8s.io/kustomize/kustomize/v5@v5.3.0</span><br><span class="line">/root/zgy/project/share-code-operator-study/memcached-operator/bin/kustomize-v5.3.0 build config/crd | kubectl apply -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/memcacheds.cache.graham924.com created</span><br></pre></td></tr></table></figure><h3 id="打包Controller并上传镜像"><a href="#打包Controller并上传镜像" class="headerlink" title="打包Controller并上传镜像"></a>打包Controller并上传镜像</h3><ul><li>cd 到 memcached-operator 的所在目录，修改 Dockerfile 文件，加上这么两句<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Build the manager binary</span><br><span class="line">FROM golang:1.21 AS builder</span><br><span class="line">ARG TARGETOS</span><br><span class="line">ARG TARGETARCH</span><br><span class="line"></span><br><span class="line"># 就是加上这两句，设置一下go的国内代理加速</span><br><span class="line">ENV GO111MODULE=on</span><br><span class="line">ENV GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li>然后 修改Makefile 文件，在docker-build命令中，添加 –network host ，这是让我们的机器使用主机网络，能够连接外网<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># If you wish to build the manager image targeting other platforms you can use the --platform flag.</span><br><span class="line"># (i.e. docker build --platform linux/arm64). However, you must enable docker buildKit for it.</span><br><span class="line"># More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span><br><span class="line">.PHONY: docker-build</span><br><span class="line">docker-build: ## Build docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) build --network host -t $&#123;IMG&#125; .</span><br></pre></td></tr></table></figure>执行打包上传命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker-build docker-push IMG=gesang321/memcached-operator:v1alpha1</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署Controller"><a href="#部署Controller" class="headerlink" title="部署Controller"></a>部署Controller</h3><ul><li>部署Controller<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# make deploy IMG=gesang321/memcached-operator:v1alpha1</span><br><span class="line">/root/zgy/project/share-code-operator-study/memcached-operator/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">cd config/manager &amp;&amp; /root/zgy/project/share-code-operator-study/memcached-operator/bin/kustomize-v5.3.0 edit set image controller=gesang321/memcached-operator:v1alpha1</span><br><span class="line">/root/zgy/project/share-code-operator-study/memcached-operator/bin/kustomize-v5.3.0 build config/default | kubectl apply -f -</span><br><span class="line">namespace/memcached-operator-system created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/memcacheds.cache.graham924.com created</span><br><span class="line">serviceaccount/memcached-operator-controller-manager created</span><br><span class="line">role.rbac.authorization.k8s.io/memcached-operator-leader-election-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/memcached-operator-manager-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/memcached-operator-metrics-reader created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/memcached-operator-proxy-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/memcached-operator-leader-election-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/memcached-operator-manager-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/memcached-operator-proxy-rolebinding created</span><br><span class="line">service/memcached-operator-controller-manager-metrics-service created</span><br><span class="line">deployment.apps/memcached-operator-controller-manager created</span><br></pre></td></tr></table></figure></li><li>查看部署结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master memcached-operator]# kubectl get deploy -n memcached-operator-system</span><br><span class="line">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">memcached-operator-controller-manager   1/1     1            1           37m</span><br><span class="line"></span><br><span class="line">[root@master memcached-operator]# kubectl get pods -n memcached-operator-system</span><br><span class="line">NAME                                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">memcached-operator-controller-manager-6fd6c7699b-42rg4   2/2     Running   0          38m</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator开发之webhook篇</title>
      <link href="/posts/4a17d0017.html"/>
      <url>/posts/4a17d0017.html</url>
      
        <content type="html"><![CDATA[<h2 id="kubernetes-Admission-Control-机制"><a href="#kubernetes-Admission-Control-机制" class="headerlink" title="kubernetes Admission Control 机制"></a>kubernetes Admission Control 机制</h2><h3 id="Admission-Control准入控制是什么"><a href="#Admission-Control准入控制是什么" class="headerlink" title="Admission Control准入控制是什么"></a>Admission Control准入控制是什么</h3><ul><li>kubernetes ApiServer 收到一个请求，在将数据持久化到etcd之前，会依次经过：Authentication认证、Authorization鉴权、Admission Control准入控制 。<ul><li>Authentication：验证用户或实体的身份，并确保其声称的身份是有效的</li><li>Authorization：确保当前用户具有对其 访问资源 的访问权限</li><li>Admission Control：对请求本身进行 验证、转换 和 审查</li></ul></li></ul><h3 id="Admission-Control-插件机制"><a href="#Admission-Control-插件机制" class="headerlink" title="Admission Control 插件机制"></a>Admission Control 插件机制</h3><ul><li>Admission Control 是由一系列插件组成的，apiserver的请求，需要通过所有插件，才能最终存储到etcd</li><li>api server 启动时，使用参数控制插件的开启<ul><li>kubernetes 1.10及以上版本，apiserver使用 参数 –enable-admission-plugins 控制插件启动</li><li>kubernetes 1.9及以下版本，apiserver使用 参数 –admission-control 控制插件启动</li></ul></li><li>我们今天要学习的webhook，涉及到 Admission Control 的两个插件：MutatingAdmissionWebhook、ValidatingAdmissionWebhook，这两个插件都是默认开启的，我们无需再去更改apiserver启动参数重启</li></ul><h2 id="Webhook介绍"><a href="#Webhook介绍" class="headerlink" title="Webhook介绍"></a>Webhook介绍</h2><h3 id="webhook是什么"><a href="#webhook是什么" class="headerlink" title="webhook是什么"></a>webhook是什么</h3><p>顾名思义，webhook就是 网络钩子，在特殊条件下自动触发执行。<br>在kubernetes中，通过使用 webhook，用户可以编写自定义的业务逻辑，并将其部署为独立的 HTTP 服务，然后将其注册到 Kubernetes 中。<br>Kubernetes 将根据配置，将到达 apiserver 的请求发送到相应的 webhook 服务，并根据 webhook 返回的结果来决定是否允许请求继续进行，以及是否需要对请求进行修改。</p><h3 id="kubernetes-webhook的三种类型"><a href="#kubernetes-webhook的三种类型" class="headerlink" title="kubernetes webhook的三种类型"></a>kubernetes webhook的三种类型</h3><p>在kubernetes中，webhook共分为三种</p><ul><li>admission webhook<ul><li>属于admission control插件，在请求进入admission control插件链时，依次调用</li></ul></li><li>authorization webhook<ul><li>对 API Server 中的请求进行授权判断</li></ul></li><li>CRD conversion webhook<ul><li>用于对 多版本的crd 资源，进行版本间数据转换<br>其中，controller-runtime 支持 admission webhook 和 CRD conversion webhook 两种<br>我们进行Operator开发，也只要是涉及到这两种webhook</li></ul></li></ul><h3 id="为webhook提供证书"><a href="#为webhook提供证书" class="headerlink" title="为webhook提供证书"></a>为webhook提供证书</h3><p>为什么需要为webhook提供证书<br>admission webhook 和 CRD conversion webhook，api Server 通过 https post 访问 webhook server, 因此 webhook server 必须要监听在 https 协议上.因此 这三种 webhook 都需要做好证书配置，推荐使用 cert-manager 为Webhook提供证书</p><ul><li>安装cert-manager<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml</span><br></pre></td></tr></table></figure></li><li>查看安装结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cert-manager]# kubectl get pod -n cert-manager</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">cert-manager-7fb948f468-r5dj2              1/1     Running   0          142m</span><br><span class="line">cert-manager-cainjector-75c5fc965c-shtx6   1/1     Running   0          142m</span><br><span class="line">cert-manager-webhook-757c9d4bb7-vhgt7      1/1     Running   0          142m</span><br><span class="line"></span><br><span class="line">[root@localhost cert-manager]# kubectl get ValidatingWebhookConfiguration</span><br><span class="line">NAME                   WEBHOOKS   AGE</span><br><span class="line">cert-manager-webhook   1          143m</span><br><span class="line"></span><br><span class="line">[root@localhost cert-manager]# kubectl get MutatingWebhookConfiguration</span><br><span class="line">NAME                   WEBHOOKS   AGE</span><br><span class="line">cert-manager-webhook   1          143m</span><br></pre></td></tr></table></figure></li></ul><h2 id="admission-webhook"><a href="#admission-webhook" class="headerlink" title="admission webhook"></a>admission webhook</h2><ul><li><p>admission webhook 包括两个阶段：</p><ul><li>MutatingAdmissionWebhook：请求修改阶段，可以对 请求资源的元数据 进行修改，比如为一些没有值的字段设置默认值等</li><li>ValidatingAdmissionWebhook：请求验证阶段，不会再修改 资源的数据，而是对资源字段数据进行一些检验，比如 资源metadata.name长度不可超过52个字符等</li></ul></li><li><p>二者调用顺序：MutatingAdmissionWebhook 阶段在前，ValidatingAdmissionWebhook 阶段在后</p></li></ul><h2 id="CRD-conversion-webhook"><a href="#CRD-conversion-webhook" class="headerlink" title="CRD conversion webhook"></a>CRD conversion webhook</h2><ul><li>除了admission webhook，我们开发Operator的时候，还会用到一种webhook，即 CRD conversion webhook</li><li>当创建了一个多版本的 CRD API，要求多个版本之间能够相互转换，相互兼容，就需要额外启动一个服务，暴露转换功能接口，供apiserver调用</li><li>CRD conversion webhook可以在kubernetes集群外启动，也可以在集群内启动，只需要做好证书配置，让apiserver能够正确访问即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubebuilder的基本使用</title>
      <link href="/posts/4a17d0016.html"/>
      <url>/posts/4a17d0016.html</url>
      
        <content type="html"><![CDATA[<h2 id="kubebuilder-init-创建一个Project"><a href="#kubebuilder-init-创建一个Project" class="headerlink" title="kubebuilder init 创建一个Project"></a>kubebuilder init 创建一个Project</h2><h3 id="为什么使用kubebuilder生成Project"><a href="#为什么使用kubebuilder生成Project" class="headerlink" title="为什么使用kubebuilder生成Project"></a>为什么使用kubebuilder生成Project</h3><p>以前开发一个Operator，我们需要自己创建一个golang项目，自己编写go.mod、Makefile、Dockerfile等文件。但是使用 kubebuilder 创建一个脚手架项目，将会把这些文件都给我们生成好，还会使用 Kustomize 生成一些默认配置文件，以便更轻松地管理和部署Operator项目</p><h3 id="kubebuilder-init-初始化-Project"><a href="#kubebuilder-init-初始化-Project" class="headerlink" title="kubebuilder init 初始化 Project"></a>kubebuilder init 初始化 Project</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder init --domain my.domain --repo my.domain/guestbook</span><br></pre></td></tr></table></figure><ul><li><p>–domain：指定自定义资源的 API 组的域名，通常是域名的反向形式，例如 domain.com 反转后为 com.domain</p></li><li><p>–repo：指定项目代码的存储库位置<br>输出如下：</p></li><li><p>先为项目生成了Kustomize清单文件</p></li><li><p>生成各种文件</p></li><li><p>然后 执行了 go get controller-runtime 和 go mod tidy</p></li><li><p>最后提醒我们，如果想要创建API，需要执行 kubebuilder create api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# kubebuilder init --domain my.domain --repo my.domain/guestbook</span><br><span class="line">INFO Writing kustomize manifests for you to edit...</span><br><span class="line">INFO Writing scaffold for you to edit...</span><br><span class="line">INFO Get controller runtime:</span><br><span class="line">$ go get sigs.k8s.io/controller-runtime@v0.17.0</span><br><span class="line">INFO Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Next: define a resource with:</span><br><span class="line">$ kubebuilder create api</span><br></pre></td></tr></table></figure><p>命令执行结束后，生成了哪些文件和目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# tree</span><br><span class="line">.</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_auth_proxy_patch.yaml</span><br><span class="line">│   │   └── manager_config_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   └── rbac</span><br><span class="line">│       ├── auth_proxy_client_clusterrole.yaml</span><br><span class="line">│       ├── auth_proxy_role_binding.yaml</span><br><span class="line">│       ├── auth_proxy_role.yaml</span><br><span class="line">│       ├── auth_proxy_service.yaml</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── leader_election_role_binding.yaml</span><br><span class="line">│       ├── leader_election_role.yaml</span><br><span class="line">│       ├── role_binding.yaml</span><br><span class="line">│       ├── role.yaml</span><br><span class="line">│       └── service_account.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">10 directories, 28 files</span><br></pre></td></tr></table></figure></li><li><p>目录解释</p><ul><li>cmd: 包含主要的应用程序代码，通常是控制器的入口点。</li><li>config: 包含了 Kubernetes 资源的配置文件，包括默认的资源、管理器的资源、监控资源以及角色绑定和服务账户等资源的配置。</li><li>Dockerfile: 用于构建容器镜像的 Dockerfile 文件。</li><li>go.mod 和 go.sum: Go 模块文件，用于管理项目的依赖项。</li><li>hack: 包含一些辅助脚本或模板文件，用于构建或生成代码。</li><li>Makefile: 包含了一些 Make 命令，用于简化项目的构建和部署过程。</li><li>PROJECT: Kubebuilder 项目的配置文件，指定了项目的 API 版本等信息。</li><li>README.md: 项目的说明文档，通常包含了如何构建、运行项目的指南。</li><li>test: 包含测试相关的代码，例如端到端测试和测试工具函数。</li></ul></li></ul><h2 id="kubebuilder-create-创建一个API"><a href="#kubebuilder-create-创建一个API" class="headerlink" title="kubebuilder create 创建一个API"></a>kubebuilder create 创建一个API</h2><h3 id="kubebuilder-create-创建API"><a href="#kubebuilder-create-创建API" class="headerlink" title="kubebuilder create 创建API"></a>kubebuilder create 创建API</h3><p>上面创建了一个Project guestbook，但是从目录上看，还没有创建Operator相关的CRD资源和Controller<br>下面就在 guestbook 项目中，创建一个 GV(Group Version)，然后为该GV创建一个 Kind<br>创建 GVK：webapp&#x2F;v1&#x2F;Guestbook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create api --group webapp --version v1 --kind Guestbook</span><br></pre></td></tr></table></figure><ul><li>输出如下<ul><li>提醒：是否创建Resource，即CRD资源</li><li>提醒：是否创建Controller<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# kubebuilder create api --group webapp --version v1 --kind Guestbook</span><br><span class="line">INFO Create Resource [y/n]</span><br><span class="line">y</span><br><span class="line">INFO Create Controller [y/n]</span><br><span class="line">y</span><br><span class="line">INFO Writing kustomize manifests for you to edit...</span><br><span class="line">INFO Writing scaffold for you to edit...</span><br><span class="line">INFO api/v1/guestbook_types.go</span><br><span class="line">INFO api/v1/groupversion_info.go</span><br><span class="line">INFO internal/controller/suite_test.go</span><br><span class="line">INFO internal/controller/guestbook_controller.go</span><br><span class="line">INFO internal/controller/guestbook_controller_test.go</span><br><span class="line">INFO Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">INFO Running make:</span><br><span class="line">$ make generate</span><br><span class="line">mkdir -p /root/zgy/project/guestbook/bin</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.14.0</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:</span><br><span class="line">$ make manifests</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>命令执行结束后，生成了哪些文件和目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# tree</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       ├── guestbook_types.go</span><br><span class="line">│       └── zz_generated.deepcopy.go</span><br><span class="line">├── bin</span><br><span class="line">│   └── controller-gen-v0.14.0</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_auth_proxy_patch.yaml</span><br><span class="line">│   │   └── manager_config_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── auth_proxy_client_clusterrole.yaml</span><br><span class="line">│   │   ├── auth_proxy_role_binding.yaml</span><br><span class="line">│   │   ├── auth_proxy_role.yaml</span><br><span class="line">│   │   ├── auth_proxy_service.yaml</span><br><span class="line">│   │   ├── guestbook_editor_role.yaml</span><br><span class="line">│   │   ├── guestbook_viewer_role.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   └── samples</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       └── webapp_v1_guestbook.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── guestbook_controller.go</span><br><span class="line">│       ├── guestbook_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">17 directories, 41 files</span><br></pre></td></tr></table></figure><h3 id="更改-CRD-types文件"><a href="#更改-CRD-types文件" class="headerlink" title="更改 CRD types文件"></a>更改 CRD types文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// GuestbookSpec defines the desired state of Guestbook</span><br><span class="line">type GuestbookSpec struct &#123;</span><br><span class="line">    // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span><br><span class="line">    // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line"></span><br><span class="line">    // Quantity of instances</span><br><span class="line">    // +kubebuilder:validation:Minimum=1</span><br><span class="line">    // +kubebuilder:validation:Maximum=10</span><br><span class="line">    Size int32 `json:&quot;size&quot;`</span><br><span class="line"></span><br><span class="line">    // Name of the ConfigMap for GuestbookSpec&#x27;s configuration</span><br><span class="line">    // +kubebuilder:validation:MaxLength=15</span><br><span class="line">    // +kubebuilder:validation:MinLength=1</span><br><span class="line">    ConfigMapName string `json:&quot;configMapName&quot;`</span><br><span class="line"></span><br><span class="line">    // +kubebuilder:validation:Enum=Phone;Address;Name</span><br><span class="line">    Type string `json:&quot;alias,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// GuestbookStatus defines the observed state of Guestbook</span><br><span class="line">type GuestbookStatus struct &#123;</span><br><span class="line">    // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span><br><span class="line">    // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line"></span><br><span class="line">    // PodName of the active Guestbook node.</span><br><span class="line">    Active string `json:&quot;active&quot;`</span><br><span class="line"></span><br><span class="line">    // PodNames of the standby Guestbook nodes.</span><br><span class="line">    Standby []string `json:&quot;standby&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +kubebuilder:object:root=true</span><br><span class="line">// +kubebuilder:subresource:status</span><br><span class="line">// +kubebuilder:resource:scope=Cluster</span><br><span class="line"></span><br><span class="line">// Guestbook is the Schema for the guestbooks API</span><br><span class="line">type Guestbook struct &#123;</span><br><span class="line">    metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">    metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">    Spec   GuestbookSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">    Status GuestbookStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make-manifests生成资源清单"><a href="#make-manifests生成资源清单" class="headerlink" title="make manifests生成资源清单"></a>make manifests生成资源清单</h3><p>从上面的输出目录来看，为gvk生成了types.go，即为：api&#x2F;v1&#x2F;guestbook_types.go<br>但是还没有为该资源生成对应的CRD yaml文件。执行 make manifests 命令就可以生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make manifests</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br></pre></td></tr></table></figure><p>通过运行 make manifests，可以确保生成的 Kubernetes 资源清单文件，与代码中定义的资源规范保持同步。所以以后但凡更改了 api&#x2F;v1&#x2F;guestbook_types.go，就一定要执行一下 make manifests</p><h2 id="安装CRD"><a href="#安装CRD" class="headerlink" title="安装CRD"></a>安装CRD</h2><p>Kind 的 types结构文件编写好，并且 Controller 开发完毕后，再次执行：make manifests，重新生成一下 资源清单</p><p>将CRD安装到当前 kubernetes-cluster 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><pre><code>输出如下：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make install</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">Downloading sigs.k8s.io/kustomize/kustomize/v5@v5.3.0</span><br><span class="line">go: downloading sigs.k8s.io/kustomize/kustomize/v5 v5.3.0</span><br><span class="line">go: downloading sigs.k8s.io/kustomize/api v0.16.0</span><br><span class="line">go: downloading sigs.k8s.io/kustomize/cmd/config v0.13.0</span><br><span class="line">go: downloading sigs.k8s.io/kustomize/kyaml v0.16.0</span><br><span class="line">go: downloading github.com/go-errors/errors v1.4.2</span><br><span class="line">go: downloading golang.org/x/exp v0.0.0-20231006140011-7918f672742d</span><br><span class="line">go: downloading golang.org/x/text v0.13.0</span><br><span class="line">go: downloading k8s.io/kube-openapi v0.0.0-20230601164746-7562a1006961</span><br><span class="line">go: downloading github.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00</span><br><span class="line">go: downloading github.com/xlab/treeprint v1.2.0</span><br><span class="line">go: downloading github.com/imdario/mergo v0.3.13</span><br><span class="line">go: downloading gopkg.in/evanphx/json-patch.v5 v5.6.0</span><br><span class="line">go: downloading google.golang.org/protobuf v1.30.0</span><br><span class="line">go: downloading go.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5</span><br><span class="line">go: downloading github.com/google/go-cmp v0.5.9</span><br><span class="line">go: downloading github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510</span><br><span class="line">/root/zgy/project/guestbook/bin/kustomize-v5.3.0 build config/crd | kubectl apply -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/guestbooks.webapp.my.domain created</span><br></pre></td></tr></table></figure><p>可以看到，最后一句输出：customresourcedefinition.apiextensions.k8s.io&#x2F;guestbooks.webapp.my.domain created。即这个crd被创建</p><p>验证结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# kubectl get crds</span><br><span class="line">NAME                          CREATED AT</span><br><span class="line">guestbooks.webapp.my.domain   2024-03-02T15:23:02Z</span><br></pre></td></tr></table></figure><h2 id="前台运行-Controller"><a href="#前台运行-Controller" class="headerlink" title="前台运行 Controller"></a>前台运行 Controller</h2><p>如果想要快速看一下编写的Controller效果，验证自己的代码，可以先在前台跑一下 Controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure><p>这种方式，终端会一直处于Controller的控制台。如果你想要做其他操作，需要在开启一个终端<br>    输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make run</span><br><span class="line">\/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">api/v1/guestbook_types.go</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./cmd/main.go</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    setup   starting manager</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    controller-runtime.metrics      Starting metrics server</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    controller-runtime.metrics      Serving metrics server  &#123;&quot;bindAddress&quot;: &quot;:8080&quot;, &quot;secure&quot;: false&#125;</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    starting server &#123;&quot;kind&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;guestbook&quot;, &quot;controllerGroup&quot;: &quot;webapp.my.domain&quot;, &quot;controllerKind&quot;: &quot;Guestbook&quot;, &quot;source&quot;: &quot;kind source: *v1.Guestbook&quot;&#125;</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    Starting Controller     &#123;&quot;controller&quot;: &quot;guestbook&quot;, &quot;controllerGroup&quot;: &quot;webapp.my.domain&quot;, &quot;controllerKind&quot;: &quot;Guestbook&quot;&#125;</span><br><span class="line">2024-03-02T23:42:47+08:00       INFO    Starting workers        &#123;&quot;controller&quot;: &quot;guestbook&quot;, &quot;controllerGroup&quot;: &quot;webapp.my.domain&quot;, &quot;controllerKind&quot;: &quot;Guestbook&quot;, &quot;worker count&quot;: 1&#125;</span><br></pre></td></tr></table></figure><p>此时关于 webapp&#x2F;v1&#x2F;guestbook 资源的 Controller 就运行起来了，我们可以去创建资源验证一下</p><h2 id="创建CR资源验证Controller"><a href="#创建CR资源验证Controller" class="headerlink" title="创建CR资源验证Controller"></a>创建CR资源验证Controller</h2><p>注意运行Controller的终端不可关闭<br>再开启一个终端，修改一下config&#x2F;samples&#x2F;webapp_v1_guestbook.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: webapp.my.domain/v1</span><br><span class="line">kind: Guestbook</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: guestbook</span><br><span class="line">    app.kubernetes.io/instance: guestbook-sample</span><br><span class="line">    app.kubernetes.io/part-of: guestbook</span><br><span class="line">    app.kubernetes.io/managed-by: kustomize</span><br><span class="line">    app.kubernetes.io/created-by: guestbook</span><br><span class="line">  name: guestbook-sample</span><br><span class="line">spec:</span><br><span class="line">  size: 1</span><br><span class="line">  configMapName: cm-test</span><br><span class="line">  alias: Phone</span><br></pre></td></tr></table></figure><pre><code>apply一下这个文件</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master samples]# kubectl apply -f config/samples/webapp_v1_guestbook.yaml</span><br><span class="line">guestbook.webapp.my.domain/guestbook-sample created</span><br></pre></td></tr></table></figure><pre><code>查看资源</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master samples]# kubectl get guestbook</span><br><span class="line">NAME               AGE</span><br><span class="line">guestbook-sample   7m5s</span><br></pre></td></tr></table></figure><p>因为我们并没有修改Controller的调谐逻辑，所以在Controller的运行终端里什么都没有输出，我们加上真实业务逻辑后，就可以按需求输出信息了</p><h2 id="打包Controller项目为镜像并上传"><a href="#打包Controller项目为镜像并上传" class="headerlink" title="打包Controller项目为镜像并上传"></a>打包Controller项目为镜像并上传</h2><h3 id="打包和上传的命令"><a href="#打包和上传的命令" class="headerlink" title="打包和上传的命令"></a>打包和上传的命令</h3><p>上面我们是在集群本地运行的Controller，一般用于开发阶段，验证和调试功能<br>当Controller开发完毕后，我们一般希望将它打包后用在其他集群里，此时就可以 将项目 打包成镜像，上传到镜像仓库<br>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令格式</span><br><span class="line">make docker-build docker-push IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure><p>实际演示：</p><ul><li>比如我们这里将guestbook这个项目打包成镜像，上传到我的dockerhub镜像仓库</li><li>我已经事先在dockerhub中创建了一个镜像仓库 gesang321&#x2F;guestbook</li><li>dockerhub的网址：<a href="https://hub.docker.com/explore">https://hub.docker.com/explore</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make docker-build docker-push IMG=gesang321/guestbook:v1</span><br><span class="line">docker build --network host -t gesang321/guestbook:v1 .</span><br><span class="line">Sending build context to Docker daemon  132.6kB</span><br><span class="line">Step 1/18 : FROM golang:1.21 AS builder</span><br><span class="line"> ---&gt; 603d8d7f7de0</span><br><span class="line">Step 2/18 : ARG TARGETOS</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 482316cd42d0</span><br><span class="line">Step 3/18 : ARG TARGETARCH</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; be05abbe45e6</span><br><span class="line">Step 4/18 : ENV GO111MODULE=on</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; aa0c0397e236</span><br><span class="line">Step 5/18 : ENV GOPROXY=https://goproxy.cn</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9d532d2a3eda</span><br><span class="line">Step 6/18 : WORKDIR /workspace</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7bb2c0d4524b</span><br><span class="line">Step 7/18 : COPY go.mod go.mod</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 65d463ab60d2</span><br><span class="line">Step 8/18 : COPY go.sum go.sum</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 97a850a41214</span><br><span class="line">Step 9/18 : RUN go mod download</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 962faccef7ba</span><br><span class="line">Step 10/18 : COPY cmd/main.go cmd/main.go</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; a91aaa2fe247</span><br><span class="line">Step 11/18 : COPY api/ api/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d52a03f7523e</span><br><span class="line">Step 12/18 : COPY internal/controller/ internal/controller/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2daac03cea36</span><br><span class="line">Step 13/18 : RUN CGO_ENABLED=0 GOOS=$&#123;TARGETOS:-linux&#125; GOARCH=$&#123;TARGETARCH&#125; go build -a -o manager cmd/main.go</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 0e03838a9253</span><br><span class="line">Step 14/18 : FROM gcr.io/distroless/static:nonroot</span><br><span class="line"> ---&gt; 51a1a0f285f9</span><br><span class="line">Step 15/18 : WORKDIR /</span><br><span class="line"> ---&gt; Running in 697a5679fbb1</span><br><span class="line">Removing intermediate container 697a5679fbb1</span><br><span class="line"> ---&gt; 4e153340a2ca</span><br><span class="line">Step 16/18 : COPY --from=builder /workspace/manager .</span><br><span class="line"> ---&gt; c08825e79d7e</span><br><span class="line">Step 17/18 : USER 65532:65532</span><br><span class="line"> ---&gt; Running in 29e184d23ba2</span><br><span class="line">Removing intermediate container 29e184d23ba2</span><br><span class="line"> ---&gt; d202f2ddf6c0</span><br><span class="line">Step 18/18 : ENTRYPOINT [&quot;/manager&quot;]</span><br><span class="line"> ---&gt; Running in 2a0ac6725a8c</span><br><span class="line">Removing intermediate container 2a0ac6725a8c</span><br><span class="line"> ---&gt; 7bf4b9ede810</span><br><span class="line">Successfully built 7bf4b9ede810</span><br><span class="line">Successfully tagged gesang321/guestbook:v1</span><br><span class="line">docker push gesang321/guestbook:v1</span><br><span class="line">The push refers to repository [docker.io/gesang321/guestbook]</span><br><span class="line">31ac0a0f7a4f: Pushed</span><br><span class="line">be245a236de8: Mounted from katanomi/distroless-static</span><br><span class="line">00af80914b10: Mounted from katanomi/distroless-static</span><br><span class="line">67c1a9e72017: Mounted from katanomi/distroless-static</span><br><span class="line">v1: digest: sha256:47331b3faf3aee3619454ab6c21a98d1a441c8561613f247a7f52889a769def9 size: 1156</span><br></pre></td></tr></table></figure></li></ul><p>上传成功后，可以在dockerhub中看到我们push的image</p><h3 id="命令执行中可能遇到的问题"><a href="#命令执行中可能遇到的问题" class="headerlink" title="命令执行中可能遇到的问题"></a>命令执行中可能遇到的问题</h3><p>1、卡在：RUN go mod download</p><p>问题描述</p><ul><li><p>可能卡住不动</p></li><li><p>也可能很久后报错：go: github.com&#x2F;beorn7&#x2F;<a href="mailto:&#x70;&#x65;&#114;&#107;&#115;&#x40;&#x76;&#49;&#46;&#x30;&#x2e;&#49;">&#x70;&#x65;&#114;&#107;&#115;&#x40;&#x76;&#49;&#46;&#x30;&#x2e;&#49;</a>: Get “<a href="https://proxy.golang.org/github.com/beorn7/perks/@v/v1.0.1.mod">https://proxy.golang.org/github.com/beorn7/perks/@v/v1.0.1.mod</a>“: dial tcp 142.250.72.145:443: connect: connection refused</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make docker-build docker-push IMG=gesang321/guestbook:v1</span><br><span class="line">docker build -t gesang321/guestbook:v1 .</span><br><span class="line">Sending build context to Docker daemon  132.6kB</span><br><span class="line">Step 1/16 : FROM golang:1.21 AS builder</span><br><span class="line"> ---&gt; 603d8d7f7de0</span><br><span class="line">Step 2/16 : ARG TARGETOS</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 482316cd42d0</span><br><span class="line">Step 3/16 : ARG TARGETARCH</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; be05abbe45e6</span><br><span class="line">Step 4/16 : WORKDIR /workspace</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d9122045a4a3</span><br><span class="line">Step 5/16 : COPY go.mod go.mod</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b9d3a8104258</span><br><span class="line">Step 6/16 : COPY go.sum go.sum</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5464452ac3dc</span><br><span class="line">Step 7/16 : RUN go mod download</span><br><span class="line"> ---&gt; Running in 29475cc7a5bd</span><br></pre></td></tr></table></figure></li><li><p>解决方案</p><ul><li>cd 到guestbook的所在目录，修改 Dockerfile 文件，加上这么两句<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Build the manager binary</span><br><span class="line">FROM golang:1.21 AS builder</span><br><span class="line">ARG TARGETOS</span><br><span class="line">ARG TARGETARCH</span><br><span class="line"></span><br><span class="line"># 就是加上这两句，设置一下go的国内代理加速</span><br><span class="line">ENV GO111MODULE=on</span><br><span class="line">ENV GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">WORKDIR /workspace</span><br><span class="line"># Copy the Go Modules manifests</span><br><span class="line">COPY go.mod go.mod</span><br><span class="line">COPY go.sum go.sum</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul></li><li><p>然后 修改Makefile 文件，在docker-build命令中，添加 –network host ，这是让我们的机器使用主机网络，能够连接外网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># If you wish to build the manager image targeting other platforms you can use the --platform flag.</span><br><span class="line"># (i.e. docker build --platform linux/arm64). However, you must enable docker buildKit for it.</span><br><span class="line"># More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span><br><span class="line">.PHONY: docker-build</span><br><span class="line">docker-build: ## Build docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) build --network host -t $&#123;IMG&#125; .</span><br></pre></td></tr></table></figure></li></ul><p>然后重新执行 make docker-build docker-push IMG&#x3D;gesang321&#x2F;guestbook:v1</p><p>2、卡在 RUN CGO_ENABLED&#x3D;0…</p><ul><li>我先是遇到了3.6.2.1的问题，解决后又卡在了这一句<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step 13/18 : RUN CGO_ENABLED=0 GOOS=$&#123;TARGETOS:-linux&#125; GOARCH=$&#123;TARGETARCH&#125; go build -a -o manager cmd/main.go</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 0e03838a9253</span><br></pre></td></tr></table></figure></li></ul><p>等待很久后，这句也成功了.所以要耐心等待，等一等就能成功的</p><p>33、FROM gcr.io&#x2F;distroless&#x2F;static:nonroot 报错</p><ul><li>gcr.io是google提供的镜像仓库，国内访问不到。如果你的机器无法科学上网，则会在这一步报错，因为压根连不上这个镜像仓库，也就无法获取其中的镜像了</li><li>解决方法：<ul><li>国内有人下载了 gcr.io&#x2F;distroless&#x2F;static:nonroot，改了名称后上传到了dockerhub</li><li>我们只需要下载 dockerhub 上的镜像，再把名称改回 gcr.io&#x2F;distroless&#x2F;static:nonroot</li><li>Dockerfile执行的时候，就可以直接在本地找到 gcr.io&#x2F;distroless&#x2F;static:nonroot，自然就不会报错了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# docker pull katanomi/distroless-static:nonroot</span><br><span class="line">[root@master guestbook]# docker tag  katanomi/distroless-static:nonroot  gcr.io/distroless/static:nonroot</span><br><span class="line">[root@master guestbook]# docker images | grep gcr</span><br><span class="line">gcr.io/distroless/static                                          nonroot                51a1a0f285f9        19 months ago       2.97MB</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>然后重新执行 make docker-build docker-push IMG&#x3D;gesang321&#x2F;guestbook:v1</p><h2 id="部署Controller到kubernetes集群"><a href="#部署Controller到kubernetes集群" class="headerlink" title="部署Controller到kubernetes集群"></a>部署Controller到kubernetes集群</h2><h3 id="部署Controller的命令"><a href="#部署Controller的命令" class="headerlink" title="部署Controller的命令"></a>部署Controller的命令</h3><p>镜像打包并上传完毕，接下来就可以到任何有仓库权限的kubernetes集群中，部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令格式</span><br><span class="line">make deploy IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure><p>实际演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make deploy IMG=gesang321/guestbook:v1</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">cd config/manager &amp;&amp; /root/zgy/project/guestbook/bin/kustomize-v5.3.0 edit set image controller=gesang321/guestbook:v1</span><br><span class="line">/root/zgy/project/guestbook/bin/kustomize-v5.3.0 build config/default | kubectl apply -f -</span><br><span class="line">namespace/guestbook-system created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/guestbooks.webapp.my.domain unchanged</span><br><span class="line">serviceaccount/guestbook-controller-manager created</span><br><span class="line">role.rbac.authorization.k8s.io/guestbook-leader-election-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/guestbook-manager-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/guestbook-metrics-reader created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/guestbook-proxy-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/guestbook-leader-election-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/guestbook-manager-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/guestbook-proxy-rolebinding created</span><br><span class="line">service/guestbook-controller-manager-metrics-service created</span><br><span class="line">deployment.apps/guestbook-controller-manager created</span><br></pre></td></tr></table></figure><p>make deploy 会自动创建一个名称 为 guestbook-system 的namespace。并在该ns下创建一个名称为 guestbook-controller-manager 的 deployment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# kubectl get deploy -n guestbook-system</span><br><span class="line">NAME                           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">guestbook-controller-manager   1/1     1            0           26m</span><br><span class="line"></span><br><span class="line">[root@master guestbook]# kubectl get pods -n guestbook-system</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">guestbook-controller-manager-6475ff77d-kqsfv   2/2     Running   0          28m</span><br></pre></td></tr></table></figure><h3 id="命令执行中可能遇到的问题-1"><a href="#命令执行中可能遇到的问题-1" class="headerlink" title="命令执行中可能遇到的问题"></a>命令执行中可能遇到的问题</h3><p>1、gcr.io&#x2F;kubebuilder&#x2F;kube-rbac-proxy拉取失败</p><p>问题描述</p><ul><li>deploy创建的Pod，并没有Running，而是 ImagePullBackOff</li><li>describe一下，可以看到是 gcr.io&#x2F;kubebuilder&#x2F;kube-rbac-proxy 镜像拉取失败<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# kubectl describe pods -n guestbook-system guestbook-controller-manager-6475ff77d-kqsfv</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">Type     Reason     Age                  From               Message</span><br><span class="line">----     ------     ----                 ----               -------</span><br><span class="line">Normal   Scheduled  &lt;unknown&gt;            default-scheduler  Successfully assigned guestbook-system/guestbook-controller-manager-6475ff77d-kqsfv to master</span><br><span class="line">Normal   Pulled     2m15s                kubelet, master    Container image &quot;gesang321/guestbook:v1&quot; already present on machine</span><br><span class="line">Normal   Created    2m15s                kubelet, master    Created container manager</span><br><span class="line">Normal   Started    2m15s                kubelet, master    Started container manager</span><br><span class="line">Warning  Failed     59s (x3 over 2m15s)  kubelet, master    Failed to pull image &quot;gcr.io/kubebuilder/kube-rbac-proxy:v0.15.0&quot;: rpc error: code = Unknown desc = Error response from daemon: Get https://gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line">Warning  Failed     59s (x3 over 2m15s)  kubelet, master    Error: ErrImagePull</span><br><span class="line">Normal   BackOff    19s (x6 over 2m15s)  kubelet, master    Back-off pulling image &quot;gcr.io/kubebuilder/kube-rbac-proxy:v0.15.0&quot;</span><br><span class="line">Warning  Failed     19s (x6 over 2m15s)  kubelet, master    Error: ImagePullBackOff</span><br><span class="line">Normal   Pulling    5s (x4 over 2m31s)   kubelet, master    Pulling image &quot;gcr.io/kubebuilder/kube-rbac-proxy:v0.15.0&quot;</span><br></pre></td></tr></table></figure><pre><code>  这依旧是grc仓库访问不到导致的问题</code></pre></li></ul><p>解决方案</p><ul><li>第一种方法<ul><li>在3.6打包之前，就先修改了 config&#x2F;default&#x2F;manager_auth_proxy_patch.yaml 文件,把 image: gcr.io&#x2F;kubebuilder&#x2F;kube-rbac-proxy:v0.15.0 改成 image: kubebuilder&#x2F;kube-rbac-proxy:v0.15.0，这是dockerhub上一个国内可访问的镜像，然后重新打包上传，部署</li></ul></li><li>第二种方法<ul><li>和 3.6.2.3 一样，我们先拉取 kubebuilder&#x2F;kube-rbac-proxy:v0.15.0，再把它的名称改成 gcr 的，这样 make deploy 的时候，就会在本地找到镜像，以为是自己需要的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# docker pull kubebuilder/kube-rbac-proxy:v0.15.0</span><br><span class="line">v0.15.0: Pulling from kubebuilder/kube-rbac-proxy</span><br><span class="line">07a64a71e011: Pull complete</span><br><span class="line">fe5ca62666f0: Pull complete</span><br><span class="line">b02a7525f878: Pull complete</span><br><span class="line">fcb6f6d2c998: Pull complete</span><br><span class="line">e8c73c638ae9: Pull complete</span><br><span class="line">1e3d9b7d1452: Pull complete</span><br><span class="line">4aa0ea1413d3: Pull complete</span><br><span class="line">7c881f9ab25e: Pull complete</span><br><span class="line">5627a970d25e: Pull complete</span><br><span class="line">c9c9ec7a3926: Pull complete</span><br><span class="line">Digest: sha256:a3768b8f9d259df714ebbf176798c380f4d929216e656dc30754eafa03a74c41</span><br><span class="line">Status: Downloaded newer image for kubebuilder/kube-rbac-proxy:v0.15.0</span><br><span class="line">[root@master guestbook]# docker tag kubebuilder/kube-rbac-proxy:v0.15.0 gcr.io/kubebuilder/kube-rbac-proxy:v0.15.0</span><br></pre></td></tr></table></figure>然后重新运行 make deploy 命令</li></ul></li></ul><h2 id="从集群中删除CRD资源"><a href="#从集群中删除CRD资源" class="headerlink" title="从集群中删除CRD资源"></a>从集群中删除CRD资源</h2><p>如果我们不需要安装好的那个CRD资源了，则可以使用 make uninstall 命令卸载CRD资源.需要注意，make uninstall 的批处理命令，是guestbook目录下的 Makefile 提供的，必须在guestbook目录下执行<br>实际演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make uninstall</span><br><span class="line">/root/zgy/project/guestbook/bin/controller-gen-v0.14.0 rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/root/zgy/project/guestbook/bin/kustomize-v5.3.0 build config/crd | kubectl delete --ignore-not-found=false -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io &quot;guestbooks.webapp.my.domain&quot; deleted</span><br><span class="line"></span><br><span class="line">[root@master guestbook]# kubectl get crds</span><br><span class="line">No resources found in default namespace.</span><br></pre></td></tr></table></figure><p>该命令会同时把 环境中，所有已经创建的 CR，一并删除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master project]# kubectl get guestbook</span><br><span class="line">Error from server (NotFound): Unable to list &quot;webapp.my.domain/v1, Resource=guestbooks&quot;: the server could not find the requested resource (get guestbooks.webapp.my.domain)</span><br></pre></td></tr></table></figure><h2 id="从集群中删除部署的Controller"><a href="#从集群中删除部署的Controller" class="headerlink" title="从集群中删除部署的Controller"></a>从集群中删除部署的Controller</h2><p>如果我们不需要 该CRD资源 及其Controller 了，则可以使用 make undeploy 命令 卸载CRD资源，并删除controller对应的deploy，需要注意，make undeploy 的批处理命令，是guestbook目录下的 Makefile 提供的，必须在guestbook目录下执行<br>实际演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master guestbook]# make undeploy</span><br><span class="line">/root/zgy/project/guestbook/bin/kustomize-v5.3.0 build config/default | kubectl delete --ignore-not-found=false -f -</span><br><span class="line">namespace &quot;guestbook-system&quot; deleted</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io &quot;guestbooks.webapp.my.domain&quot; deleted</span><br><span class="line">serviceaccount &quot;guestbook-controller-manager&quot; deleted</span><br><span class="line">role.rbac.authorization.k8s.io &quot;guestbook-leader-election-role&quot; deleted</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;guestbook-manager-role&quot; deleted</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;guestbook-metrics-reader&quot; deleted</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;guestbook-proxy-role&quot; deleted</span><br><span class="line">rolebinding.rbac.authorization.k8s.io &quot;guestbook-leader-election-rolebinding&quot; deleted</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;guestbook-manager-rolebinding&quot; deleted</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;guestbook-proxy-rolebinding&quot; deleted</span><br><span class="line">service &quot;guestbook-controller-manager-metrics-service&quot; deleted</span><br><span class="line">deployment.apps &quot;guestbook-controller-manager&quot; deleted</span><br><span class="line"></span><br><span class="line">[root@master guestbook]# kubectl get crds</span><br><span class="line">No resources found in default namespace.</span><br><span class="line"></span><br><span class="line">[root@master guestbook]# kubectl get deploy -A</span><br><span class="line">NAMESPACE     NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">default       nginx              1/1     1            1           27d</span><br><span class="line">kube-system   coredns            2/2     2            2           27d</span><br></pre></td></tr></table></figure><p>该命令会同时把 环境中，所有已经创建的 CR，一并删除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master project]# kubectl get guestbook</span><br><span class="line">Error from server (NotFound): Unable to list &quot;webapp.my.domain/v1, Resource=guestbooks&quot;: the server could not find the requested resource (get guestbooks.webapp.my.domain)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubebuilder 的安装</title>
      <link href="/posts/4a17d0015.html"/>
      <url>/posts/4a17d0015.html</url>
      
        <content type="html"><![CDATA[<h2 id="kubebuilder简介"><a href="#kubebuilder简介" class="headerlink" title="kubebuilder简介"></a>kubebuilder简介</h2><h3 id="kubebuilder的诞生背景"><a href="#kubebuilder的诞生背景" class="headerlink" title="kubebuilder的诞生背景"></a>kubebuilder的诞生背景</h3><p>我们前面学习了使用 client-go 的运作流程，还学习了 code-generator 和controller-tools 等自动生成client、informer、lister和deepcopy的一系列技术，但是这么多工具都要记住使用方式，实在太繁琐了。懒是程序员进步的动力，那么能不能有一个 聚合型的工具，将这些工具汇总起来，我们只需要记住简短的几个命令，就能够实现一系列自动化生成的效果？kubebuilder就是这样一个工具</p><h3 id="kubebuidler详细介绍"><a href="#kubebuidler详细介绍" class="headerlink" title="kubebuidler详细介绍"></a>kubebuidler详细介绍</h3><p>kubebuidler 是 kubernetes-sigs（特定兴趣小组）开发的一款用于Operator程序构建和发布的工具。在kubebuilder github仓库 中，对kubebuilder进行了详细介绍：</p><ul><li>kubebuilder是一个使用自定义资源定义（CRD）构建 Kubernetes API 的框架。如同 Ruby的Rails框架 和 Java的SpringBoot 能够极大地减少Web开发中的重复工作一样，kubebuilder 可以极大的减小 kubernetes API 开发的复杂性，帮助我们开发出最佳实践的 kubernetes API。kubebuilder自动生成的代码并非简单的复制-粘贴，而是提供强大的库和工具来简化从零开始构建和发布 Kubernetes API</li><li>另外重要的点：KubeBuilder 是在 controller-runtime 和 controller-tools 两个库的基础上开发的。Operator-SDK 是使用 Kubebuilder 作为库的进一步开发的项目</li></ul><h3 id="kubebuilder学习推荐"><a href="#kubebuilder学习推荐" class="headerlink" title="kubebuilder学习推荐"></a>kubebuilder学习推荐</h3><ul><li><p>kubebuidler 的 github 仓库</p><ul><li><a href="https://github.com/kubernetes-sigs/kubebuilder">https://github.com/kubernetes-sigs/kubebuilder</a></li></ul></li><li><p>kubebuilder的官方文档</p><ul><li>英文版：<a href="https://book.kubebuilder.io/introduction">https://book.kubebuilder.io/introduction</a></li><li>中文版：<a href="https://cloudnative.to/kubebuilder/introduction.html">https://cloudnative.to/kubebuilder/introduction.html</a></li></ul></li></ul><h2 id="kubebuidler安装"><a href="#kubebuidler安装" class="headerlink" title="kubebuidler安装"></a>kubebuidler安装</h2><h3 id="安装方法一：kubebuilder官方文档中给出的方法"><a href="#安装方法一：kubebuilder官方文档中给出的方法" class="headerlink" title="安装方法一：kubebuilder官方文档中给出的方法"></a>安装方法一：kubebuilder官方文档中给出的方法</h3><ul><li><p>安装最新发行版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># download kubebuilder and install locally.</span><br><span class="line">curl -L -o kubebuilder &quot;https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)&quot;</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>安装github代码仓库中，master分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -o kubebuilder &quot;https://go.kubebuilder.io/dl/master/$(go env GOOS)/$(go env GOARCH)&quot;</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/</span><br></pre></td></tr></table></figure><p>可能遇到的问题：curl下载失败，比如报错：curl: (35) Encountered end of file。此时推荐使用安装方法二</p></li></ul><h3 id="安装方法二：直接下载kubenetes的可执行文件"><a href="#安装方法二：直接下载kubenetes的可执行文件" class="headerlink" title="安装方法二：直接下载kubenetes的可执行文件"></a>安装方法二：直接下载kubenetes的可执行文件</h3><p>先到 github 上找到你需要的发行版本：<a href="https://github.com/kubernetes-sigs/kubebuilder/releases%EF%BC%9B%E6%AF%94%E5%A6%82%E6%88%91%E8%A6%81%E5%AE%89%E8%A3%853.14.0%EF%BC%8C%E5%88%99%E7%82%B9%E5%87%BB%E8%BF%9B%E5%8E%BB">https://github.com/kubernetes-sigs/kubebuilder/releases；比如我要安装3.14.0，则点击进去</a><br>        <a href="https://github.com/kubernetes-sigs/kubebuilder/releases/tag/v3.14.0">https://github.com/kubernetes-sigs/kubebuilder/releases/tag/v3.14.0</a><br>下载完，将下载的可执行包上传到 linux<br>如果你的linux网络ok，也可以直接在你的linux上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/kubernetes-sigs/kubebuilder/releases/download/v3.14.0/kubebuilder_linux_amd64</span><br></pre></td></tr></table></figure><p>然后就可以直接进行安装了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv kubebuilder_linux_amd64 kubebuilder</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/</span><br></pre></td></tr></table></figure><p>验证安装是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master test]# kubebuilder version</span><br><span class="line">Version: main.version&#123;KubeBuilderVersion:&quot;3.14.0&quot;, KubernetesVendor:&quot;1.27.1&quot;, GitCommit:&quot;11053630918ac421cb6eb6f0a3225e2a2ad49535&quot;, BuildDate:&quot;2024-01-30T09:29:27Z&quot;, GoOs:&quot;linux&quot;, GoArch:&quot;amd64&quot;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用client-go开发自定义Controller</title>
      <link href="/posts/4a17d0014.html"/>
      <url>/posts/4a17d0014.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建utils-consts-go"><a href="#创建utils-consts-go" class="headerlink" title="创建utils&#x2F;consts.go"></a>创建utils&#x2F;consts.go</h2><ul><li>在pkg包下，创建一个utils目录，并在里面创建一个 consts.go 的工具文件，记录一些常量，等会编写controller的时候会用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package utils</span><br><span class="line"></span><br><span class="line">const ControllerAgentName = &quot;app-controller&quot;</span><br><span class="line">const WorkNum = 5</span><br><span class="line">const MaxRetry = 10</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">// SuccessSynced is used as part of the Event &#x27;reason&#x27; when a App is synced</span><br><span class="line">SuccessSynced = &quot;Synced&quot;</span><br><span class="line">// ErrResourceExists is used as part of the Event &#x27;reason&#x27; when a App fails</span><br><span class="line">// to sync due to a Deployment of the same name already existing.</span><br><span class="line">ErrResourceExists = &quot;ErrResourceExists&quot;</span><br><span class="line"></span><br><span class="line">// MessageResourceExists is the message used for Events when a resource</span><br><span class="line">// fails to sync due to a Deployment already existing</span><br><span class="line">MessageResourceExists = &quot;Resource %q already exists and is not managed by App&quot;</span><br><span class="line">// MessageResourceSynced is the message used for an Event fired when a App</span><br><span class="line">// is synced successfully</span><br><span class="line">MessageResourceSynced = &quot;App synced successfully&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建控制器pkg-controller-controller-go"><a href="#创建控制器pkg-controller-controller-go" class="headerlink" title="创建控制器pkg&#x2F;controller&#x2F;controller.go"></a>创建控制器pkg&#x2F;controller&#x2F;controller.go</h2><h3 id="先展示完整-controller-go-文件"><a href="#先展示完整-controller-go-文件" class="headerlink" title="先展示完整 controller.go 文件"></a>先展示完整 controller.go 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line">package controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">appcontrollerv1 &quot;crd-controller-demo/pkg/apis/appcontroller/v1&quot;</span><br><span class="line">clientset &quot;crd-controller-demo/pkg/generated/clientset/versioned&quot;</span><br><span class="line">&quot;crd-controller-demo/pkg/generated/clientset/versioned/scheme&quot;</span><br><span class="line">informersv1 &quot;crd-controller-demo/pkg/generated/informers/externalversions/appcontroller/v1&quot;</span><br><span class="line">listerv1 &quot;crd-controller-demo/pkg/generated/listers/appcontroller/v1&quot;</span><br><span class="line">&quot;crd-controller-demo/pkg/utils&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">appsv1 &quot;k8s.io/api/apps/v1&quot;</span><br><span class="line">corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/api/errors&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">utilruntime &quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/util/wait&quot;</span><br><span class="line">appsinformersv1 &quot;k8s.io/client-go/informers/apps/v1&quot;</span><br><span class="line">coreinformersv1 &quot;k8s.io/client-go/informers/core/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">typedcorev1 &quot;k8s.io/client-go/kubernetes/typed/core/v1&quot;</span><br><span class="line">appslisterv1 &quot;k8s.io/client-go/listers/apps/v1&quot;</span><br><span class="line">corelisterv1 &quot;k8s.io/client-go/listers/core/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/cache&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/record&quot;</span><br><span class="line">&quot;k8s.io/client-go/util/workqueue&quot;</span><br><span class="line">&quot;k8s.io/klog/v2&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Controller struct &#123;</span><br><span class="line">// kubeClientset kubernetes 所有内置资源的 clientset，用于操作所有内置资源</span><br><span class="line">kubeClientset kubernetes.Interface</span><br><span class="line">// appClientset 为 apps 资源生成的 clientset，用于操作 apps 资源</span><br><span class="line">appClientset clientset.Interface</span><br><span class="line"></span><br><span class="line">// deploymentsLister 查询本地缓存中的 deployment 资源</span><br><span class="line">deploymentsLister appslisterv1.DeploymentLister</span><br><span class="line">// servicesLister 查询本地缓存中的 service 资源</span><br><span class="line">servicesLister corelisterv1.ServiceLister</span><br><span class="line">// appsLister 查询本地缓存中的 apps 资源</span><br><span class="line">appsLister listerv1.AppLister</span><br><span class="line"></span><br><span class="line">// deploymentsSync 检查 deployments 资源，是否完成同步</span><br><span class="line">deploymentsSync cache.InformerSynced</span><br><span class="line">// servicesSync 检查 services 资源，是否完成同步</span><br><span class="line">servicesSync cache.InformerSynced</span><br><span class="line">// appsSync 检查 apps 资源，是否完成同步</span><br><span class="line">appsSync cache.InformerSynced</span><br><span class="line"></span><br><span class="line">// workqueue 队列，存储 待处理资源的key（一般是 namespace/name）</span><br><span class="line">workqueue workqueue.RateLimitingInterface</span><br><span class="line">// recorder 事件记录器</span><br><span class="line">recorder record.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewController(kubeclientset kubernetes.Interface,</span><br><span class="line">appclientset clientset.Interface,</span><br><span class="line">deploymentInformer appsinformersv1.DeploymentInformer,</span><br><span class="line">serviceInformer coreinformersv1.ServiceInformer,</span><br><span class="line">appInformer informersv1.AppInformer) *Controller &#123;</span><br><span class="line"></span><br><span class="line">// 将 为apps资源生成的clientset的Scheme，添加到全局 Scheme 中</span><br><span class="line">utilruntime.Must(scheme.AddToScheme(scheme.Scheme))</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Creating event broadcaster&quot;)</span><br><span class="line">// 新建一个事件广播器，用于将事件广播到不同的监听器</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">// 将事件以结构化日志的形式输出</span><br><span class="line">eventBroadcaster.StartStructuredLogging(0)</span><br><span class="line">// 将事件广播器配置为将事件记录到指定的 EventSink</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeclientset.CoreV1().Events(&quot;&quot;)&#125;)</span><br><span class="line">// 创建一个事件记录器，用于发送事件到设置好的事件广播</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: utils.ControllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">// 创建一个 Controller 对象</span><br><span class="line">c := &amp;Controller&#123;</span><br><span class="line">kubeClientset:     kubeclientset,</span><br><span class="line">appClientset:      appclientset,</span><br><span class="line">deploymentsLister: deploymentInformer.Lister(),</span><br><span class="line">servicesLister:    serviceInformer.Lister(),</span><br><span class="line">appsLister:        appInformer.Lister(),</span><br><span class="line">deploymentsSync:   deploymentInformer.Informer().HasSynced,</span><br><span class="line">servicesSync:      serviceInformer.Informer().HasSynced,</span><br><span class="line">appsSync:          appInformer.Informer().HasSynced,</span><br><span class="line">workqueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &quot;Apps&quot;),</span><br><span class="line">recorder:          recorder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为AppInformer，设置 ResourceEventHandler</span><br><span class="line">klog.Info(&quot;Setting up event handlers&quot;)</span><br><span class="line">appInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc:    c.AddApp,</span><br><span class="line">UpdateFunc: c.UpdateApp,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为 DeploymentInformer，设置 ResourceEventHandler</span><br><span class="line">deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">DeleteFunc: c.DeleteDeployment,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为 ServiceInformer，设置 ResourceEventHandler</span><br><span class="line">serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">DeleteFunc: c.DeleteService,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将控制器实例返回</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) enqueue(obj interface&#123;&#125;) &#123;</span><br><span class="line">key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.workqueue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) AddApp(obj interface&#123;&#125;) &#123;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) UpdateApp(oldObj, newObj interface&#123;&#125;) &#123;</span><br><span class="line">if reflect.DeepEqual(oldObj, newObj) &#123;</span><br><span class="line">key, _ := cache.MetaNamespaceKeyFunc(oldObj)</span><br><span class="line">klog.V(4).Infof(&quot;UpdateApp %s: %s&quot;, key, &quot;no change&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(newObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) DeleteDeployment(obj interface&#123;&#125;) &#123;</span><br><span class="line">deploy := obj.(*appsv1.Deployment)</span><br><span class="line">ownerReference := metav1.GetControllerOf(deploy)</span><br><span class="line">if ownerReference == nil || ownerReference.Kind != &quot;App&quot; &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) DeleteService(obj interface&#123;&#125;) &#123;</span><br><span class="line">service := obj.(*corev1.Service)</span><br><span class="line">ownerReference := metav1.GetControllerOf(service)</span><br><span class="line">if ownerReference == nil || ownerReference.Kind != &quot;App&quot; &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) Run(workerNum int, stopCh &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">// 用于处理程序崩溃，发生未捕获的异常（panic）时，调用HandleCrash()方法，记录日志并发出报告</span><br><span class="line">defer utilruntime.HandleCrash()</span><br><span class="line">// 控制器程序结束时，清理队列</span><br><span class="line">defer c.workqueue.ShutDown()</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Starting App Controller&quot;)</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Waiting for informer cache to sync&quot;)</span><br><span class="line">if ok := cache.WaitForCacheSync(stopCh, c.appsSync, c.deploymentsSync, c.servicesSync); !ok &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to wait for caches to sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Starting workers&quot;)</span><br><span class="line">for i := 0; i &lt; workerNum; i++ &#123;</span><br><span class="line">go wait.Until(c.worker, time.Minute, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Started workers&quot;)</span><br><span class="line">&lt;-stopCh</span><br><span class="line">klog.V(4).Info(&quot;Shutting down workers&quot;)</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) worker() &#123;</span><br><span class="line">for c.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) processNextWorkItem() bool &#123;</span><br><span class="line">// 从 workqueue 中获取一个item</span><br><span class="line">item, shutdown := c.workqueue.Get()</span><br><span class="line">// 如果队列已经被回收，返回false</span><br><span class="line">if shutdown &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">// 最终将这个item标记为已处理</span><br><span class="line">defer c.workqueue.Done(item)</span><br><span class="line">// 将item转成key</span><br><span class="line">key, ok := item.(string)</span><br><span class="line">if !ok &#123;</span><br><span class="line">klog.Warningf(&quot;failed convert item [%s] to string&quot;, item)</span><br><span class="line">c.workqueue.Forget(item)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">// 对key这个App，进行具体的调谐。这里面是核心的调谐逻辑</span><br><span class="line">if err := c.syncApp(key); err != nil &#123;</span><br><span class="line">klog.Errorf(&quot;failed to syncApp [%s], error: [%s]&quot;, key, err.Error())</span><br><span class="line">c.handleError(key, err)</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) syncApp(key string) error &#123;</span><br><span class="line">// 将key拆分成namespace、name</span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从informer缓存中，获取到key对应的app对象</span><br><span class="line">app, err := c.appsLister.Apps(namespace).Get(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">return fmt.Errorf(&quot;app [%s] in work queue no longer exists&quot;, key)</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出 app 对象 的 deploymentSpec 部分</span><br><span class="line">deploymentTemplate := app.Spec.DeploymentSpec</span><br><span class="line">// 如果 app 的 deploymentTemplate 不为空</span><br><span class="line">if deploymentTemplate.Name != &quot;&quot; &#123;</span><br><span class="line">// 尝试从缓存获取 对应的 deployment</span><br><span class="line">deploy, err := c.deploymentsLister.Deployments(namespace).Get(deploymentTemplate.Name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// 如果没找到</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(4).Info(&quot;starting to create deployment [%s] in namespace [%s]&quot;, deploymentTemplate.Name, namespace)</span><br><span class="line">// 创建一个deployment对象，然后使用 kubeClientset，与apiserver交互，创建deployment</span><br><span class="line">deploy = newDeployment(deploymentTemplate, app)</span><br><span class="line">_, err := c.kubeClientset.AppsV1().Deployments(namespace).Create(context.TODO(), deploy, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to create deployment [%s] in namespace [%s], error: [%v]&quot;, deploymentTemplate.Name, namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">// 创建完成后，从apiserver中，获取最新的deployment，因为下面要使用它的status.【这里不能从informer缓存获取，因为缓存里暂时未同步新创建的deployment】</span><br><span class="line">deploy, _ = c.kubeClientset.AppsV1().Deployments(namespace).Get(context.TODO(), deploymentTemplate.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to get deployment [%s] in namespace [%s], error: [%v]&quot;, deploy.Name, deploy.Namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果获取到的 deployment，并非 app 所控制，报错</span><br><span class="line">if !metav1.IsControlledBy(deploy, app) &#123;</span><br><span class="line">msg := fmt.Sprintf(utils.MessageResourceExists, deploy.Name)</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeWarning, utils.ErrResourceExists, msg)</span><br><span class="line">return fmt.Errorf(&quot;%s&quot;, msg)</span><br><span class="line">&#125;</span><br><span class="line">// update deploy status</span><br><span class="line">app.Status.DeploymentStatus = &amp;deploy.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出 app 对象 的 deploymentSpec 部分</span><br><span class="line">serviceTemplate := app.Spec.ServiceSpec</span><br><span class="line">// 如果 app 的 serviceTemplate 不为空</span><br><span class="line">if serviceTemplate.Name != &quot;&quot; &#123;</span><br><span class="line">// 尝试从缓存获取 对应的 service</span><br><span class="line">service, err := c.servicesLister.Services(namespace).Get(serviceTemplate.Name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// 如果没找到</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(4).Info(&quot;starting to create service [%s] in namespace [%s]&quot;, serviceTemplate.Name, namespace)</span><br><span class="line">// 创建一个service对象，然后使用 kubeClientset，与apiserver交互，创建service</span><br><span class="line">service = newService(serviceTemplate, app)</span><br><span class="line">_, err := c.kubeClientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to create service [%s] in namespace [%s], error: [%v]&quot;, serviceTemplate.Name, namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">// 创建完成后，从apiserver中，获取最新的service，因为下面要使用它的status.【这里不能从informer缓存获取，因为缓存里暂时未同步新创建的service】</span><br><span class="line">service, _ = c.kubeClientset.CoreV1().Services(namespace).Get(context.TODO(), serviceTemplate.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to get service [%s] in namespace [%s], error: [%v]&quot;, service.Name, service.Namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果获取到的 service，并非 app 所控制，报错</span><br><span class="line">if !metav1.IsControlledBy(service, app) &#123;</span><br><span class="line">msg := fmt.Sprintf(utils.MessageResourceExists, service.Name)</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeWarning, utils.ErrResourceExists, msg)</span><br><span class="line">return fmt.Errorf(&quot;%s&quot;, msg)</span><br><span class="line">&#125;</span><br><span class="line">// update service status</span><br><span class="line">app.Status.ServiceStatus = &amp;service.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理完 deploymentSpec、serviceSpec，将设置好的AppStatus更新到环境中去</span><br><span class="line">_, err = c.appClientset.AppcontrollerV1().Apps(namespace).Update(context.TODO(), app, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to update app [%s], error: [%v]&quot;, key, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 记录事件日志</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeNormal, utils.SuccessSynced, utils.MessageResourceSynced)</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// newDeployment 创建一个deployment对象</span><br><span class="line">func newDeployment(template appcontrollerv1.DeploymentTemplate, app *appcontrollerv1.App) *appsv1.Deployment &#123;</span><br><span class="line">d := &amp;appsv1.Deployment&#123;</span><br><span class="line">TypeMeta: metav1.TypeMeta&#123;</span><br><span class="line">Kind:       &quot;Deployment&quot;,</span><br><span class="line">APIVersion: &quot;apps/v1&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name: template.Name,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: appsv1.DeploymentSpec&#123;</span><br><span class="line">// Selector 和 pod 的 Labels 必须一致</span><br><span class="line">Selector: &amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchLabels: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Replicas: &amp;template.Replicas,</span><br><span class="line">Template: corev1.PodTemplateSpec&#123;</span><br><span class="line">// pod 的 labels，没有让用户指定，这里设置成默认的</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Labels: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: corev1.PodSpec&#123;</span><br><span class="line">Containers: []corev1.Container&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name:  &quot;app-deploy-container&quot;,</span><br><span class="line">Image: template.Image,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">// 将 deploy 的 OwnerReferences，设置成app</span><br><span class="line">d.OwnerReferences = []metav1.OwnerReference&#123;</span><br><span class="line">*metav1.NewControllerRef(app, appcontrollerv1.SchemeGroupVersion.WithKind(&quot;App&quot;)),</span><br><span class="line">&#125;</span><br><span class="line">return d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newService(template appcontrollerv1.ServiceTemplate, app *appcontrollerv1.App) *corev1.Service &#123;</span><br><span class="line">s := &amp;corev1.Service&#123;</span><br><span class="line">TypeMeta: metav1.TypeMeta&#123;</span><br><span class="line">Kind:       &quot;Service&quot;,</span><br><span class="line">APIVersion: &quot;v1&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name: template.Name,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: corev1.ServiceSpec&#123;</span><br><span class="line">// Selector 和 pod 的 Labels 必须一致</span><br><span class="line">Selector: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">Ports: []corev1.ServicePort&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: &quot;app-service&quot;,</span><br><span class="line">// Service的端口，默认设置成了8080。这里仅仅是为了学习crd，实际开发中可以设置到AppSpec中去</span><br><span class="line">Port: 8080,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.OwnerReferences = []metav1.OwnerReference&#123;</span><br><span class="line">*metav1.NewControllerRef(app, appcontrollerv1.SchemeGroupVersion.WithKind(&quot;App&quot;)),</span><br><span class="line">&#125;</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) handleError(key string, err error) &#123;</span><br><span class="line">// 如果当前key的处理次数，还不到最大重试次数，则再次加入队列</span><br><span class="line">if c.workqueue.NumRequeues(key) &lt; utils.MaxRetry &#123;</span><br><span class="line">c.workqueue.AddRateLimited(key)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行时统一处理错误</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">// 不再处理这个key</span><br><span class="line">c.workqueue.Forget(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller结构体详解"><a href="#Controller结构体详解" class="headerlink" title="Controller结构体详解"></a>Controller结构体详解</h3><ul><li><p>创建一个Controller结构体，我们的控制器，需要操作的资源有 App、Deployment、Service，因此Controller中需要包括一下几部分：</p><ul><li>kubernetes 的 clientset：用于从apiserver获取最新的deployment、service信息</li><li>app 的 clientset：用于从apiserver获取最新的apps信息，这个clientset是我们使用code-generator自动生成的</li><li>dedployment 的 Lister：用于从informer的缓存中获取deployment的信息，避免与apiserver交互的太频繁</li><li>service 的 Lister：用于从informer的缓存中获取service的信息，避免与apiserver交互的太频繁</li><li>app 的 Lister：用于从informer的缓存中获取app的信息，避免与apiserver交互的太频繁</li><li>dedployment 的 HasSynced：用于检查 deployments 资源，是否完成同步</li><li>service 的 HasSynced：检查 services 资源，是否完成同步</li><li>app 的 HasSynced：检查 apps 资源，是否完成同步</li><li>workqueue：存储 待处理资源的key（一般是 namespace&#x2F;name）的队列</li><li>recorder：事件记录器，用于记录事件，可以被 kubectl get event 获取到</li></ul></li><li><p>Controller结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type Controller struct &#123;</span><br><span class="line">// kubeClientset kubernetes 所有内置资源的 clientset，用于操作所有内置资源</span><br><span class="line">kubeClientset kubernetes.Interface</span><br><span class="line">// appClientset 为 apps 资源生成的 clientset，用于操作 apps 资源</span><br><span class="line">appClientset clientset.Interface</span><br><span class="line"></span><br><span class="line">// deploymentsLister 查询本地缓存中的 deployment 资源</span><br><span class="line">deploymentsLister appslisterv1.DeploymentLister</span><br><span class="line">// servicesLister 查询本地缓存中的 service 资源</span><br><span class="line">servicesLister corelisterv1.ServiceLister</span><br><span class="line">// appsLister 查询本地缓存中的 apps 资源</span><br><span class="line">appsLister listerv1.AppLister</span><br><span class="line"></span><br><span class="line">// deploymentsSync 检查 deployments 资源，是否完成同步</span><br><span class="line">deploymentsSync cache.InformerSynced</span><br><span class="line">// servicesSync 检查 services 资源，是否完成同步</span><br><span class="line">servicesSync cache.InformerSynced</span><br><span class="line">// appsSync 检查 apps 资源，是否完成同步</span><br><span class="line">appsSync cache.InformerSynced</span><br><span class="line"></span><br><span class="line">// workqueue 队列，存储 待处理资源的key（一般是 namespace/name）</span><br><span class="line">workqueue workqueue.RateLimitingInterface</span><br><span class="line">// recorder 事件记录器</span><br><span class="line">recorder record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供一个 NewController 的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func NewController(kubeclientset kubernetes.Interface,</span><br><span class="line">appclientset clientset.Interface,</span><br><span class="line">deploymentInformer appsinformersv1.DeploymentInformer,</span><br><span class="line">serviceInformer coreinformersv1.ServiceInformer,</span><br><span class="line">appInformer informersv1.AppInformer) *Controller &#123;</span><br><span class="line"></span><br><span class="line">// 将 为apps资源生成的clientset的Scheme，添加到全局 Scheme 中</span><br><span class="line">utilruntime.Must(scheme.AddToScheme(scheme.Scheme))</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Creating event broadcaster&quot;)</span><br><span class="line">// 新建一个事件广播器，用于将事件广播到不同的监听器</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">// 将事件以结构化日志的形式输出</span><br><span class="line">eventBroadcaster.StartStructuredLogging(0)</span><br><span class="line">// 将事件广播器配置为将事件记录到指定的 EventSink</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeclientset.CoreV1().Events(&quot;&quot;)&#125;)</span><br><span class="line">// 创建一个事件记录器，用于发送事件到设置好的事件广播</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: utils.ControllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">// 创建一个 Controller 对象</span><br><span class="line">c := &amp;Controller&#123;</span><br><span class="line">kubeClientset:     kubeclientset,</span><br><span class="line">appClientset:      appclientset,</span><br><span class="line">deploymentsLister: deploymentInformer.Lister(),</span><br><span class="line">servicesLister:    serviceInformer.Lister(),</span><br><span class="line">appsLister:        appInformer.Lister(),</span><br><span class="line">deploymentsSync:   deploymentInformer.Informer().HasSynced,</span><br><span class="line">servicesSync:      serviceInformer.Informer().HasSynced,</span><br><span class="line">appsSync:          appInformer.Informer().HasSynced,</span><br><span class="line">workqueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &quot;Apps&quot;),</span><br><span class="line">recorder:          recorder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为AppInformer，设置 ResourceEventHandler</span><br><span class="line">klog.Info(&quot;Setting up event handlers&quot;)</span><br><span class="line">appInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc:    c.AddApp,</span><br><span class="line">UpdateFunc: c.UpdateApp,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为 DeploymentInformer，设置 ResourceEventHandler</span><br><span class="line">deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">DeleteFunc: c.DeleteDeployment,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为 ServiceInformer，设置 ResourceEventHandler</span><br><span class="line">serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">DeleteFunc: c.DeleteService,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将控制器实例返回</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Controller中的ResourceEventHandler处理方法详解"><a href="#Controller中的ResourceEventHandler处理方法详解" class="headerlink" title="Controller中的ResourceEventHandler处理方法详解"></a>Controller中的ResourceEventHandler处理方法详解</h3><ul><li>共有4个 ResourceEventHandler，方法内容如下：<ul><li>这4个 ResourceEventHandler 方法的主要作用，就是将 待调谐的资源key，放入workqueue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func (c *Controller) enqueue(obj interface&#123;&#125;) &#123;</span><br><span class="line">key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.workqueue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) AddApp(obj interface&#123;&#125;) &#123;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) UpdateApp(oldObj, newObj interface&#123;&#125;) &#123;</span><br><span class="line">if reflect.DeepEqual(oldObj, newObj) &#123;</span><br><span class="line">key, _ := cache.MetaNamespaceKeyFunc(oldObj)</span><br><span class="line">klog.V(4).Infof(&quot;UpdateApp %s: %s&quot;, key, &quot;no change&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(newObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) DeleteDeployment(obj interface&#123;&#125;) &#123;</span><br><span class="line">deploy := obj.(*appsv1.Deployment)</span><br><span class="line">ownerReference := metav1.GetControllerOf(deploy)</span><br><span class="line">if ownerReference == nil || ownerReference.Kind != &quot;App&quot; &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) DeleteService(obj interface&#123;&#125;) &#123;</span><br><span class="line">service := obj.(*corev1.Service)</span><br><span class="line">ownerReference := metav1.GetControllerOf(service)</span><br><span class="line">if ownerReference == nil || ownerReference.Kind != &quot;App&quot; &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Controller的启动方法Run-详解"><a href="#Controller的启动方法Run-详解" class="headerlink" title="Controller的启动方法Run()详解"></a>Controller的启动方法Run()详解</h3><ul><li>用于启动Controller，并启动 workerNum 个 worker 进行工作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func (c *Controller) Run(workerNum int, stopCh &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">// 用于处理程序崩溃，发生未捕获的异常（panic）时，调用HandleCrash()方法，记录日志并发出报告</span><br><span class="line">defer utilruntime.HandleCrash()</span><br><span class="line">// 控制器程序结束时，清理队列</span><br><span class="line">defer c.workqueue.ShutDown()</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Starting App Controller&quot;)</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Waiting for informer cache to sync&quot;)</span><br><span class="line">if ok := cache.WaitForCacheSync(stopCh, c.appsSync, c.deploymentsSync, c.servicesSync); !ok &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to wait for caches to sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Starting workers&quot;)</span><br><span class="line">for i := 0; i &lt; workerNum; i++ &#123;</span><br><span class="line">go wait.Until(c.worker, time.Minute, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(4).Info(&quot;Started workers&quot;)</span><br><span class="line">&lt;-stopCh</span><br><span class="line">klog.V(4).Info(&quot;Shutting down workers&quot;)</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="worker详解"><a href="#worker详解" class="headerlink" title="worker详解"></a>worker详解</h3><ul><li>worker是调谐的核心逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">func (c *Controller) worker() &#123;</span><br><span class="line">for c.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Controller) processNextWorkItem() bool &#123;</span><br><span class="line">// 从 workqueue 中获取一个item</span><br><span class="line">item, shutdown := c.workqueue.Get()</span><br><span class="line">// 如果队列已经被回收，返回false</span><br><span class="line">if shutdown &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最终将这个item标记为已处理</span><br><span class="line">defer c.workqueue.Done(item)</span><br><span class="line"></span><br><span class="line">// 将item转成key</span><br><span class="line">key, ok := item.(string)</span><br><span class="line">if !ok &#123;</span><br><span class="line">klog.Warningf(&quot;failed convert item [%s] to string&quot;, item)</span><br><span class="line">c.workqueue.Forget(item)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对key这个App，进行具体的调谐。这里面是核心的调谐逻辑</span><br><span class="line">if err := c.syncApp(key); err != nil &#123;</span><br><span class="line">klog.Errorf(&quot;failed to syncApp [%s], error: [%s]&quot;, key, err.Error())</span><br><span class="line">c.handleError(key, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// syncApp 对App资源的调谐核心逻辑</span><br><span class="line">func (c *Controller) syncApp(key string) error &#123;</span><br><span class="line">// 将key拆分成namespace、name</span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从informer缓存中，获取到key对应的app对象</span><br><span class="line">app, err := c.appsLister.Apps(namespace).Get(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">return fmt.Errorf(&quot;app [%s] in work queue no longer exists&quot;, key)</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出 app 对象 的 deploymentSpec 部分</span><br><span class="line">deploymentTemplate := app.Spec.DeploymentSpec</span><br><span class="line">// 如果 app 的 deploymentTemplate 不为空</span><br><span class="line">if deploymentTemplate.Name != &quot;&quot; &#123;</span><br><span class="line">// 尝试从缓存获取 对应的 deployment</span><br><span class="line">deploy, err := c.deploymentsLister.Deployments(namespace).Get(deploymentTemplate.Name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// 如果没找到</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(4).Info(&quot;starting to create deployment [%s] in namespace [%s]&quot;, deploymentTemplate.Name, namespace)</span><br><span class="line">// 创建一个deployment对象，然后使用 kubeClientset，与apiserver交互，创建deployment</span><br><span class="line">deploy = newDeployment(deploymentTemplate, app)</span><br><span class="line">_, err := c.kubeClientset.AppsV1().Deployments(namespace).Create(context.TODO(), deploy, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to create deployment [%s] in namespace [%s], error: [%v]&quot;, deploymentTemplate.Name, namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">// 创建完成后，从apiserver中，获取最新的deployment，因为下面要使用它的status.【这里不能从informer缓存获取，因为缓存里暂时未同步新创建的deployment】</span><br><span class="line">deploy, _ = c.kubeClientset.AppsV1().Deployments(namespace).Get(context.TODO(), deploymentTemplate.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to get deployment [%s] in namespace [%s], error: [%v]&quot;, deploy.Name, deploy.Namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果获取到的 deployment，并非 app 所控制，报错</span><br><span class="line">if !metav1.IsControlledBy(deploy, app) &#123;</span><br><span class="line">msg := fmt.Sprintf(utils.MessageResourceExists, deploy.Name)</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeWarning, utils.ErrResourceExists, msg)</span><br><span class="line">return fmt.Errorf(&quot;%s&quot;, msg)</span><br><span class="line">&#125;</span><br><span class="line">// update deploy status</span><br><span class="line">app.Status.DeploymentStatus = &amp;deploy.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出 app 对象 的 deploymentSpec 部分</span><br><span class="line">serviceTemplate := app.Spec.ServiceSpec</span><br><span class="line">// 如果 app 的 serviceTemplate 不为空</span><br><span class="line">if serviceTemplate.Name != &quot;&quot; &#123;</span><br><span class="line">// 尝试从缓存获取 对应的 service</span><br><span class="line">service, err := c.servicesLister.Services(namespace).Get(serviceTemplate.Name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// 如果没找到</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(4).Info(&quot;starting to create service [%s] in namespace [%s]&quot;, serviceTemplate.Name, namespace)</span><br><span class="line">// 创建一个service对象，然后使用 kubeClientset，与apiserver交互，创建service</span><br><span class="line">service = newService(serviceTemplate, app)</span><br><span class="line">_, err := c.kubeClientset.CoreV1().Services(namespace).Create(context.TODO(), service, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to create service [%s] in namespace [%s], error: [%v]&quot;, serviceTemplate.Name, namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">// 创建完成后，从apiserver中，获取最新的service，因为下面要使用它的status.【这里不能从informer缓存获取，因为缓存里暂时未同步新创建的service】</span><br><span class="line">service, _ = c.kubeClientset.CoreV1().Services(namespace).Get(context.TODO(), serviceTemplate.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to get service [%s] in namespace [%s], error: [%v]&quot;, service.Name, service.Namespace, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果获取到的 service，并非 app 所控制，报错</span><br><span class="line">if !metav1.IsControlledBy(service, app) &#123;</span><br><span class="line">msg := fmt.Sprintf(utils.MessageResourceExists, service.Name)</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeWarning, utils.ErrResourceExists, msg)</span><br><span class="line">return fmt.Errorf(&quot;%s&quot;, msg)</span><br><span class="line">&#125;</span><br><span class="line">// update service status</span><br><span class="line">app.Status.ServiceStatus = &amp;service.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理完 deploymentSpec、serviceSpec，将设置好的AppStatus更新到环境中去</span><br><span class="line">_, err = c.appClientset.AppcontrollerV1().Apps(namespace).Update(context.TODO(), app, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to update app [%s], error: [%v]&quot;, key, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 记录事件日志</span><br><span class="line">c.recorder.Event(app, corev1.EventTypeNormal, utils.SuccessSynced, utils.MessageResourceSynced)</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建deployemnt、service的方法详解"><a href="#创建deployemnt、service的方法详解" class="headerlink" title="创建deployemnt、service的方法详解"></a>创建deployemnt、service的方法详解</h3><ul><li>根据AppSpec中用户编写的信息，创建对应的deployment和service</li><li>这里只在AppSpec中添加了几个简单的信息，所以很多信息都是写死在代码里的，大家可以根据需要，更新AppSpec，这样创建的时候，就可以有更多的信息由用户指定</li><li>更新完AppSpec后，记得重新执行 第3部分 中的命令，重新生成deepcopy文件、generated、crd文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// newDeployment 创建一个deployment对象</span><br><span class="line">func newDeployment(template appcontrollerv1.DeploymentTemplate, app *appcontrollerv1.App) *appsv1.Deployment &#123;</span><br><span class="line">d := &amp;appsv1.Deployment&#123;</span><br><span class="line">TypeMeta: metav1.TypeMeta&#123;</span><br><span class="line">Kind:       &quot;Deployment&quot;,</span><br><span class="line">APIVersion: &quot;apps/v1&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name: template.Name,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: appsv1.DeploymentSpec&#123;</span><br><span class="line">// Selector 和 pod 的 Labels 必须一致</span><br><span class="line">Selector: &amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchLabels: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Replicas: &amp;template.Replicas,</span><br><span class="line">Template: corev1.PodTemplateSpec&#123;</span><br><span class="line">// pod 的 labels，没有让用户指定，这里设置成默认的</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Labels: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: corev1.PodSpec&#123;</span><br><span class="line">Containers: []corev1.Container&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name:  &quot;app-deploy-container&quot;,</span><br><span class="line">Image: template.Image,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">// 将 deploy 的 OwnerReferences，设置成app</span><br><span class="line">d.OwnerReferences = []metav1.OwnerReference&#123;</span><br><span class="line">*metav1.NewControllerRef(app, appcontrollerv1.SchemeGroupVersion.WithKind(&quot;App&quot;)),</span><br><span class="line">&#125;</span><br><span class="line">return d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newService(template appcontrollerv1.ServiceTemplate, app *appcontrollerv1.App) *corev1.Service &#123;</span><br><span class="line">s := &amp;corev1.Service&#123;</span><br><span class="line">TypeMeta: metav1.TypeMeta&#123;</span><br><span class="line">Kind:       &quot;Service&quot;,</span><br><span class="line">APIVersion: &quot;v1&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name: template.Name,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: corev1.ServiceSpec&#123;</span><br><span class="line">// Selector 和 pod 的 Labels 必须一致</span><br><span class="line">Selector: map[string]string&#123;</span><br><span class="line">&quot;app-key&quot;: &quot;app-value&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">Ports: []corev1.ServicePort&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: &quot;app-service&quot;,</span><br><span class="line">// Service的端口，默认设置成了8080。这里仅仅是为了学习crd，实际开发中可以设置到AppSpec中去</span><br><span class="line">Port: 8080,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.OwnerReferences = []metav1.OwnerReference&#123;</span><br><span class="line">*metav1.NewControllerRef(app, appcontrollerv1.SchemeGroupVersion.WithKind(&quot;App&quot;)),</span><br><span class="line">&#125;</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写main函数，启动控制器"><a href="#编写main函数，启动控制器" class="headerlink" title="编写main函数，启动控制器"></a>编写main函数，启动控制器</h2><h3 id="编写cmd-main-go"><a href="#编写cmd-main-go" class="headerlink" title="编写cmd&#x2F;main.go"></a>编写cmd&#x2F;main.go</h3><ul><li>编写main方法，创建Controller对象，并启动，同时做好优雅停止设计<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;crd-controller-demo/pkg/controller&quot;</span><br><span class="line">clientset &quot;crd-controller-demo/pkg/generated/clientset/versioned&quot;</span><br><span class="line">appinformers &quot;crd-controller-demo/pkg/generated/informers/externalversions&quot;</span><br><span class="line">&quot;crd-controller-demo/pkg/signals&quot;</span><br><span class="line">&quot;crd-controller-demo/pkg/utils&quot;</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">kubeinformers &quot;k8s.io/client-go/informers&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;k8s.io/klog/v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">masterURL  string</span><br><span class="line">kubeConfig string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">klog.InitFlags(nil)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">// set up signals so we handle the first shutdown signal gracefully</span><br><span class="line">stopCh := signals.SetupSignalHandler()</span><br><span class="line"></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(masterURL, kubeConfig)</span><br><span class="line">//config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">klog.Fatalf(&quot;Error building kubeConfig: %s&quot;, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kubeClientSet, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">klog.Fatalf(&quot;Error building kubernetes clientset: %s&quot;, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">appClientSet, err := clientset.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">klog.Fatalf(&quot;Error building app clientset: %s&quot;, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClientSet, time.Second*30)</span><br><span class="line">appInformerFactory := appinformers.NewSharedInformerFactory(appClientSet, time.Second*30)</span><br><span class="line"></span><br><span class="line">controller := controller.NewController(kubeClientSet, appClientSet,</span><br><span class="line">kubeInformerFactory.Apps().V1().Deployments(),</span><br><span class="line">kubeInformerFactory.Core().V1().Services(),</span><br><span class="line">appInformerFactory.Appcontroller().V1().Apps())</span><br><span class="line"></span><br><span class="line">// notice that there is no need to run Start methods in a separate goroutine. (i.e. go kubeInformerFactory.Start(stopCh)</span><br><span class="line">// Start method is non-blocking and runs all registered informers in a dedicated goroutine.</span><br><span class="line">kubeInformerFactory.Start(stopCh)</span><br><span class="line">appInformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">if err = controller.Run(utils.WorkNum, stopCh); err != nil &#123;</span><br><span class="line">klog.Fatalf(&quot;Error running controller: %s&quot;, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">flag.StringVar(&amp;kubeConfig, &quot;kubeConfig&quot;, &quot;&quot;, &quot;Path to a kubeConfig. Only required if out-of-cluster.&quot;)</span><br><span class="line">flag.StringVar(&amp;masterURL, &quot;master&quot;, &quot;&quot;, &quot;The address of the Kubernetes API server. Overrides any value in kubeConfig. Only required if out-of-cluster.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="pkg-signals包"><a href="#pkg-signals包" class="headerlink" title="pkg&#x2F;signals包"></a>pkg&#x2F;signals包</h3><ul><li>在pkg下创建signal包，并创建3个文件，用于实现 程序 的优雅停止</li></ul><h3 id="编写signal-go"><a href="#编写signal-go" class="headerlink" title="编写signal.go"></a>编写signal.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Copyright 2017 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package signals</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;os/signal&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var onlyOneSignalHandler = make(chan struct&#123;&#125;)</span><br><span class="line"></span><br><span class="line">// SetupSignalHandler registered for SIGTERM and SIGINT. A stop channel is returned</span><br><span class="line">// which is closed on one of these signals. If a second signal is caught, the program</span><br><span class="line">// is terminated with exit code 1.</span><br><span class="line">func SetupSignalHandler() (stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">close(onlyOneSignalHandler) // panics when called twice</span><br><span class="line"></span><br><span class="line">stop := make(chan struct&#123;&#125;)</span><br><span class="line">c := make(chan os.Signal, 2)</span><br><span class="line">signal.Notify(c, shutdownSignals...)</span><br><span class="line">go func() &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">close(stop)</span><br><span class="line">&lt;-c</span><br><span class="line">os.Exit(1) // second signal. Exit directly.</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">return stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写signal-posix-go"><a href="#编写signal-posix-go" class="headerlink" title="编写signal_posix.go"></a>编写signal_posix.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//go:build !windows</span><br><span class="line">// +build !windows</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Copyright 2017 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package signals</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var shutdownSignals = []os.Signal&#123;os.Interrupt, syscall.SIGTERM&#125;</span><br></pre></td></tr></table></figure><h3 id="编写signal-windows-go"><a href="#编写signal-windows-go" class="headerlink" title="编写signal_windows.go"></a>编写signal_windows.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Copyright 2017 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package signals</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var shutdownSignals = []os.Signal&#123;os.Interrupt&#125;</span><br></pre></td></tr></table></figure><h2 id="编写测试yaml文件"><a href="#编写测试yaml文件" class="headerlink" title="编写测试yaml文件"></a>编写测试yaml文件</h2><ul><li>在artifacts包下，创建一个example包，里面创建两个测试文件</li><li>test_app.yaml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: appcontroller.k8s.io/v1</span><br><span class="line">kind: App</span><br><span class="line">metadata:</span><br><span class="line">  name: test-app</span><br><span class="line">  namespace: tcs</span><br><span class="line">spec:</span><br><span class="line">  deploymentTemplate:</span><br><span class="line">    name: app-deploy</span><br><span class="line">    image: nginx</span><br><span class="line">    replicas: 2</span><br><span class="line">  serviceTemplate:</span><br><span class="line">    name: app-service</span><br></pre></td></tr></table></figure></li><li>test_app_2.yaml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: appcontroller.k8s.io/v1</span><br><span class="line">kind: App</span><br><span class="line">metadata:</span><br><span class="line">  name: test-app-2</span><br><span class="line">  namespace: tcs</span><br><span class="line">spec:</span><br><span class="line">  deploymentTemplate:</span><br><span class="line">    name: app-deploy-test</span><br><span class="line">    image: tomcat</span><br><span class="line">    replicas: 3</span><br><span class="line">  serviceTemplate:</span><br><span class="line">    name: app-service-test</span><br></pre></td></tr></table></figure></li></ul><h2 id="Create-CRD-Test"><a href="#Create-CRD-Test" class="headerlink" title="Create CRD &amp;&amp; Test"></a>Create CRD &amp;&amp; Test</h2><ul><li><p>在kubernetes集群中，创建CRD资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crd-controller-demo</span><br><span class="line">kubectl apply -f artifacts/crd/appcontroller.k8s.io_apps.yaml</span><br></pre></td></tr></table></figure></li><li><p>启动控制器</p><ul><li>执行 go run main.go</li><li>可以使用命令行参数指定masterIP、configPath</li></ul></li><li><p>然后创建两个App资源，查看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd crd-controller-demo</span><br><span class="line">kubectl apply -f artifacts/example/test_app.yaml</span><br><span class="line">kubectl apply -f artifacts/example/test_app_2.yaml</span><br></pre></td></tr></table></figure></li><li><p>查看deployment和service的创建情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master crd-controller-demo]# kubectl get deploy -n tcs</span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">app-deploy         2/2     2            2           145m</span><br><span class="line">app-deploy-test    3/3     3            3           125m</span><br><span class="line"></span><br><span class="line">[root@master crd-controller-demo]# kubectl get pods -n tcs</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">app-deploy-67677ddc7f-jpggn         1/1     Running   0          145m</span><br><span class="line">app-deploy-67677ddc7f-zqgcl         1/1     Running   0          145m</span><br><span class="line">app-deploy-test-8fb698bf7-84s8p     1/1     Running   0          126m</span><br><span class="line">app-deploy-test-8fb698bf7-dtk4w     1/1     Running   0          126m</span><br><span class="line">app-deploy-test-8fb698bf7-wzfj9     1/1     Running   0          126m</span><br><span class="line"></span><br><span class="line">[root@master crd-controller-demo]# kubectl get svc -n tcs</span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                          AGE</span><br><span class="line">app-service        ClusterIP </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRD控制器 开发实战篇</title>
      <link href="/posts/4a17d0013.html"/>
      <url>/posts/4a17d0013.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>设计一个CRD，名称为 App：在AppSpec中，可以包含一个 Deployment 的 部分属性、一个 Service 的 部分属性</li><li>为App编写一个控制器 AppController：当创建App的时候，控制器AppController会检查AppSpec，如果包含 Deployment 或 Service，就创建对应的 Deployment 或 Service</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><h3 id="初始化项目-1"><a href="#初始化项目-1" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>初始化go项目，并get client-go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd crd-controller-demo</span><br><span class="line">go mod init crd-controller-demo</span><br><span class="line"></span><br><span class="line">go get k8s.io/client-go</span><br><span class="line">go get k8s.io/apimachinery</span><br></pre></td></tr></table></figure><h3 id="编写boilerplate-go-txt"><a href="#编写boilerplate-go-txt" class="headerlink" title="编写boilerplate.go.txt"></a>编写boilerplate.go.txt</h3><p>该文件是文件开头统一的注释，会在使用 code-generator 脚本时，指定 boilerplate.go.txt 文件的所在目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Copyright 2019 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line"></span><br><span class="line">@Time : 2024/2</span><br><span class="line">@Author : grahamzhu</span><br><span class="line">@Software: GoLand</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="编写tools-go"><a href="#编写tools-go" class="headerlink" title="编写tools.go"></a>编写tools.go</h3><p>我们要使用 code-generator，可代码中还没有任何位置 导入过 code-generator 的包，所以我们需要一个类，专门用于将 code-generator 的包导入。一般使用tools.go来做这件事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//go:build tools</span><br><span class="line">// +build tools</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Copyright 2019 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// This package imports things required by build scripts, to force `go mod` to see them as dependencies</span><br><span class="line">package tools</span><br><span class="line"></span><br><span class="line">import _ &quot;k8s.io/code-generator&quot;</span><br></pre></td></tr></table></figure><h3 id="编写appcontroller-v1-register-go"><a href="#编写appcontroller-v1-register-go" class="headerlink" title="编写appcontroller&#x2F;v1&#x2F;register.go"></a>编写appcontroller&#x2F;v1&#x2F;register.go</h3><p>注意，这是appcontroller目录下的register.go，并非某个版本目录下的，版本目录下的，再使用 code-generator 脚本后，再进行编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package appcontroller</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">GroupName = &quot;appcontroller.k8s.io&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编写doc-go"><a href="#编写doc-go" class="headerlink" title="编写doc.go"></a>编写doc.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +k8s:deepcopy-gen=package</span><br><span class="line">// +groupName=appcontroller.k8s.io</span><br><span class="line"></span><br><span class="line">// Package v1 v1版本的api包</span><br><span class="line">package v1</span><br></pre></td></tr></table></figure><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><h3 id="使用type-scaffold工具生成-types-go"><a href="#使用type-scaffold工具生成-types-go" class="headerlink" title="使用type-scaffold工具生成 types.go"></a>使用type-scaffold工具生成 types.go</h3><p>1、生成types.go</p><ul><li>需要注意：<ul><li>type-scaffold并不会生成文件，而是生成types.go的内容，打印到控制台，我们需要手动copy到types.go文件中去</li><li>不过使用kubebuilder的时候，会帮我们生成types.go文件的</li></ul></li><li>执行 type-scaffold –kind&#x3D;App，得到types.go的内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# type-scaffold --kind=App</span><br><span class="line">// AppSpec defines the desired state of App</span><br><span class="line">type AppSpec struct &#123;</span><br><span class="line">// INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppStatus defines the observed state of App.</span><br><span class="line">// It should always be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">type AppStatus struct &#123;</span><br><span class="line">// INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// App is the Schema for the apps API</span><br><span class="line">// +k8s:openapi-gen=true</span><br><span class="line">type App struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   AppSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">Status AppStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// AppList contains a list of App</span><br><span class="line">type AppList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Items           []App `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 v1 目录下创建 types.go 文件，将控制台的内容copy进去，记得导包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line"></span><br><span class="line">// AppSpec defines the desired state of App</span><br><span class="line">type AppSpec struct &#123;</span><br><span class="line">// INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppStatus defines the observed state of App.</span><br><span class="line">// It should always be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">type AppStatus struct &#123;</span><br><span class="line">// INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// App is the Schema for the apps API</span><br><span class="line">// +k8s:openapi-gen=true</span><br><span class="line">type App struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   AppSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">Status AppStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// AppList contains a list of App</span><br><span class="line">type AppList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Items           []App `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2、修改types.go文件，并添加自动生成标签</p><p>修改types.go，并在types.go的struct上面，需要加上一些·client的标签，才能使用code-generator自动生成client<br>修改后，typs.go文件完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">appsv1 &quot;k8s.io/api/apps/v1&quot;</span><br><span class="line">corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// +genclient</span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// App is the Schema for the apps API</span><br><span class="line">type App struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   AppSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">Status AppStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppSpec defines the desired state of App</span><br><span class="line">type AppSpec struct &#123;</span><br><span class="line">DeploymentSpec DeploymentTemplate `json:&quot;deploymentTemplate,omitempty&quot;`</span><br><span class="line">ServiceSpec    ServiceTemplate    `json:&quot;serviceTemplate,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DeploymentTemplate struct &#123;</span><br><span class="line">Name     string `json:&quot;name&quot;`</span><br><span class="line">Image    string `json:&quot;image&quot;`</span><br><span class="line">Replicas int32  `json:&quot;replicas&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ServiceTemplate struct &#123;</span><br><span class="line">Name string `json:&quot;name&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppStatus defines the observed state of App.</span><br><span class="line">// It should always be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">type AppStatus struct &#123;</span><br><span class="line">DeploymentStatus *appsv1.DeploymentStatus `json:&quot;deploymentStatus,omitempty&quot;`</span><br><span class="line">ServiceStatus    *corev1.ServiceStatus    `json:&quot;serviceStatus,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// AppList contains a list of App</span><br><span class="line">type AppList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Items           []App `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用controller-gen生成-deepcopy-文件"><a href="#使用controller-gen生成-deepcopy-文件" class="headerlink" title="使用controller-gen生成 deepcopy 文件"></a>使用controller-gen生成 deepcopy 文件</h3><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crd-controller-demo</span><br><span class="line">controller-gen object paths=pkg/apis/appcontroller/v1/types.go</span><br></pre></td></tr></table></figure><p>命令执行结束后，在v1目录下生成了 zz_generated.deepcopy.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@master crd-controller-demo]# controller-gen object paths=pkg/apis/appcontroller/v1/types.go</span><br><span class="line">[root@master crd-controller-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   ├── boilerplate.go.txt</span><br><span class="line">│   ├── tools.go</span><br><span class="line">│   └── update-codegen.sh</span><br><span class="line">├── pkg</span><br><span class="line">│   └── apis</span><br><span class="line">│       └── appcontroller</span><br><span class="line">│           ├── register.go</span><br><span class="line">│           └── v1</span><br><span class="line">│               ├── docs.go</span><br><span class="line">│               ├── register.go</span><br><span class="line">│               ├── types.go</span><br><span class="line">│               └── zz_generated.deepcopy.go</span><br></pre></td></tr></table></figure><h3 id="使用code-generator生成-client-informer-lister"><a href="#使用code-generator生成-client-informer-lister" class="headerlink" title="使用code-generator生成 client,informer,lister"></a>使用code-generator生成 client,informer,lister</h3><p>1、编写update-codegen.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line"># Copyright 2017 The Kubernetes Authors.</span><br><span class="line">#</span><br><span class="line"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"># you may not use this file except in compliance with the License.</span><br><span class="line"># You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># 设置脚本在执行过程中遇到任何错误时立即退出</span><br><span class="line">set -o errexit</span><br><span class="line"># 设置脚本在使用未定义的变量时立即退出</span><br><span class="line">set -o nounset</span><br><span class="line"># 设置脚本在管道命令中任意一条命令失败时立即退出</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line"># 对generate-groups.sh 脚本的调用</span><br><span class="line">../vendor/k8s.io/code-generator/generate-groups.sh \</span><br><span class="line">  &quot;client,informer,lister&quot; \</span><br><span class="line">  crd-controller-demo/pkg/generated \</span><br><span class="line">  crd-controller-demo/pkg/apis \</span><br><span class="line">  appcontroller:v1 \</span><br><span class="line">  --go-header-file $(pwd)/boilerplate.go.txt \</span><br><span class="line">  --output-base $(pwd)/../../</span><br></pre></td></tr></table></figure><p>2、执行update-codegen.sh</p><p>最终会在pkg目录下，生成generated目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"># 生成vendor文件夹</span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line"># 为vendor中的code-generator赋予权限</span><br><span class="line">chmod -R 777 vendor</span><br><span class="line"></span><br><span class="line"># 为hack中的update-codegen.sh脚本赋予权限</span><br><span class="line">chmod -R 777 hack</span><br><span class="line"></span><br><span class="line"># 调用脚本生成代码</span><br><span class="line">$ cd hack &amp;&amp; ./update-codegen.sh</span><br><span class="line">Generating clientset for appcontroller:v1 at crd-controller-demo/pkg/generated/clientset</span><br><span class="line">Generating listers for appcontroller:v1 at crd-controller-demo/pkg/generated/listers</span><br><span class="line">Generating informers for appcontroller:v1 at crd-controller-demo/pkg/generated/informers</span><br><span class="line"></span><br><span class="line"># 此时目录变为如下情况</span><br><span class="line">$ cd .. &amp;&amp; tree -L 5</span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   ├── boilerplate.go.txt</span><br><span class="line">│   ├── tools.go</span><br><span class="line">│   └── update-codegen.sh</span><br><span class="line">├── pkg</span><br><span class="line">│   ├── apis</span><br><span class="line">│   │   └── appcontroller</span><br><span class="line">│   │       ├── register.go</span><br><span class="line">│   │       └── v1</span><br><span class="line">│   │           ├── docs.go</span><br><span class="line">│   │           ├── register.go</span><br><span class="line">│   │           ├── types.go</span><br><span class="line">│   │           └── zz_generated.deepcopy.go</span><br><span class="line">│   └── generated</span><br><span class="line">│       ├── clientset</span><br><span class="line">│       │   └── versioned</span><br><span class="line">│       │       ├── clientset.go</span><br><span class="line">│       │       ├── fake</span><br><span class="line">│       │       ├── scheme</span><br><span class="line">│       │       └── typed</span><br><span class="line">│       ├── informers</span><br><span class="line">│       │   └── externalversions</span><br><span class="line">│       │       ├── appcontroller</span><br><span class="line">│       │       ├── factory.go</span><br><span class="line">│       │       ├── generic.go</span><br><span class="line">│       │       └── internalinterfaces</span><br><span class="line">│       └── listers</span><br><span class="line">│           └── appcontroller</span><br><span class="line">│               └── v1</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br></pre></td></tr></table></figure><h3 id="使用controller-gen生成crd"><a href="#使用controller-gen生成crd" class="headerlink" title="使用controller-gen生成crd"></a>使用controller-gen生成crd</h3><p>生成crd文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crd-controller-demo</span><br><span class="line">controller-gen crd paths=./... output:crd:dir=artifacts/crd</span><br></pre></td></tr></table></figure><p>crd文件完整内容：记得在 annotations 中加入一个：api-approved.kubernetes.io: “<a href="https://github.com/kubernetes/kubernetes/pull/78458%22%EF%BC%8C%E5%90%A6%E5%89%87kubernetes%E4%B8%8D%E8%AE%A9%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E8%BF%99%E4%B8%AACRD">https://github.com/kubernetes/kubernetes/pull/78458&quot;，否則kubernetes不让我们创建这个CRD</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    controller-gen.kubebuilder.io/version: (devel)</span><br><span class="line">    api-approved.kubernetes.io: &quot;https://github.com/kubernetes/kubernetes/pull/78458&quot;</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: apps.appcontroller.k8s.io</span><br><span class="line">spec:</span><br><span class="line">  group: appcontroller.k8s.io</span><br><span class="line">  names:</span><br><span class="line">    kind: App</span><br><span class="line">    listKind: AppList</span><br><span class="line">    plural: apps</span><br><span class="line">    singular: app</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1</span><br><span class="line">      schema:</span><br><span class="line">        openAPIV3Schema:</span><br><span class="line">          description: App is the Schema for the apps API</span><br><span class="line">          properties:</span><br><span class="line">            apiVersion:</span><br><span class="line">              description: &#x27;APIVersion defines the versioned schema of this representation</span><br><span class="line">              of an object. Servers should convert recognized schemas to the latest</span><br><span class="line">              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources&#x27;</span><br><span class="line">              type: string</span><br><span class="line">            kind:</span><br><span class="line">              description: &#x27;Kind is a string value representing the REST resource this</span><br><span class="line">              object represents. Servers may infer this from the endpoint the client</span><br><span class="line">              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds&#x27;</span><br><span class="line">              type: string</span><br><span class="line">            metadata:</span><br><span class="line">              type: object</span><br><span class="line">            spec:</span><br><span class="line">              description: AppSpec defines the desired state of App</span><br><span class="line">              properties:</span><br><span class="line">                deploymentTemplate:</span><br><span class="line">                  properties:</span><br><span class="line">                    image:</span><br><span class="line">                      type: string</span><br><span class="line">                    name:</span><br><span class="line">                      type: string</span><br><span class="line">                    replicas:</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                  required:</span><br><span class="line">                    - image</span><br><span class="line">                    - name</span><br><span class="line">                    - replicas</span><br><span class="line">                  type: object</span><br><span class="line">                serviceTemplate:</span><br><span class="line">                  properties:</span><br><span class="line">                    name:</span><br><span class="line">                      type: string</span><br><span class="line">                  required:</span><br><span class="line">                    - name</span><br><span class="line">                  type: object</span><br><span class="line">              type: object</span><br><span class="line">            status:</span><br><span class="line">              description: AppStatus defines the observed state of App. It should always</span><br><span class="line">                be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">              properties:</span><br><span class="line">                deploymentStatus:</span><br><span class="line">                  description: DeploymentStatus is the most recently observed status</span><br><span class="line">                    of the Deployment.</span><br><span class="line">                  properties:</span><br><span class="line">                    availableReplicas:</span><br><span class="line">                      description: Total number of available pods (ready for at least</span><br><span class="line">                        minReadySeconds) targeted by this deployment.</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                    collisionCount:</span><br><span class="line">                      description: Count of hash collisions for the Deployment. The</span><br><span class="line">                        Deployment controller uses this field as a collision avoidance</span><br><span class="line">                        mechanism when it needs to create the name for the newest ReplicaSet.</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                    conditions:</span><br><span class="line">                      description: Represents the latest available observations of a</span><br><span class="line">                        deployment&#x27;s current state.</span><br><span class="line">                      items:</span><br><span class="line">                        description: DeploymentCondition describes the state of a deployment</span><br><span class="line">                          at a certain point.</span><br><span class="line">                        properties:</span><br><span class="line">                          lastTransitionTime:</span><br><span class="line">                            description: Last time the condition transitioned from one</span><br><span class="line">                              status to another.</span><br><span class="line">                            format: date-time</span><br><span class="line">                            type: string</span><br><span class="line">                          lastUpdateTime:</span><br><span class="line">                            description: The last time this condition was updated.</span><br><span class="line">                            format: date-time</span><br><span class="line">                            type: string</span><br><span class="line">                          message:</span><br><span class="line">                            description: A human readable message indicating details</span><br><span class="line">                              about the transition.</span><br><span class="line">                            type: string</span><br><span class="line">                          reason:</span><br><span class="line">                            description: The reason for the condition&#x27;s last transition.</span><br><span class="line">                            type: string</span><br><span class="line">                          status:</span><br><span class="line">                            description: Status of the condition, one of True, False,</span><br><span class="line">                              Unknown.</span><br><span class="line">                            type: string</span><br><span class="line">                          type:</span><br><span class="line">                            description: Type of deployment condition.</span><br><span class="line">                            type: string</span><br><span class="line">                        required:</span><br><span class="line">                          - status</span><br><span class="line">                          - type</span><br><span class="line">                        type: object</span><br><span class="line">                      type: array</span><br><span class="line">                    observedGeneration:</span><br><span class="line">                      description: The generation observed by the deployment controller.</span><br><span class="line">                      format: int64</span><br><span class="line">                      type: integer</span><br><span class="line">                    readyReplicas:</span><br><span class="line">                      description: readyReplicas is the number of pods targeted by this</span><br><span class="line">                        Deployment with a Ready Condition.</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                    replicas:</span><br><span class="line">                      description: Total number of non-terminated pods targeted by this</span><br><span class="line">                        deployment (their labels match the selector).</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                    unavailableReplicas:</span><br><span class="line">                      description: Total number of unavailable pods targeted by this</span><br><span class="line">                        deployment. This is the total number of pods that are still</span><br><span class="line">                        required for the deployment to have 100% available capacity.</span><br><span class="line">                        They may either be pods that are running but not yet available</span><br><span class="line">                        or pods that still have not been created.</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                    updatedReplicas:</span><br><span class="line">                      description: Total number of non-terminated pods targeted by this</span><br><span class="line">                        deployment that have the desired template spec.</span><br><span class="line">                      format: int32</span><br><span class="line">                      type: integer</span><br><span class="line">                  type: object</span><br><span class="line">                serviceStatus:</span><br><span class="line">                  description: ServiceStatus represents the current status of a service.</span><br><span class="line">                  properties:</span><br><span class="line">                    conditions:</span><br><span class="line">                      description: Current service state</span><br><span class="line">                      items:</span><br><span class="line">                        description: &quot;Condition contains details for one aspect of the</span><br><span class="line">                        current state of this API Resource. --- This struct is intended</span><br><span class="line">                        for direct use as an array at the field path .status.conditions.</span><br><span class="line">                        \ For example, \n type FooStatus struct&#123; // Represents the</span><br><span class="line">                        observations of a foo&#x27;s current state. // Known .status.conditions.type</span><br><span class="line">                        are: \&quot;Available\&quot;, \&quot;Progressing\&quot;, and \&quot;Degraded\&quot; // +patchMergeKey=type</span><br><span class="line">                        // +patchStrategy=merge // +listType=map // +listMapKey=type</span><br><span class="line">                        Conditions []metav1.Condition `json:\&quot;conditions,omitempty\&quot;</span><br><span class="line">                        patchStrategy:\&quot;merge\&quot; patchMergeKey:\&quot;type\&quot; protobuf:\&quot;bytes,1,rep,name=conditions\&quot;`</span><br><span class="line">                        \n // other fields &#125;&quot;</span><br><span class="line">                        properties:</span><br><span class="line">                          lastTransitionTime:</span><br><span class="line">                            description: lastTransitionTime is the last time the condition</span><br><span class="line">                              transitioned from one status to another. This should be</span><br><span class="line">                              when the underlying condition changed.  If that is not</span><br><span class="line">                              known, then using the time when the API field changed</span><br><span class="line">                              is acceptable.</span><br><span class="line">                            format: date-time</span><br><span class="line">                            type: string</span><br><span class="line">                          message:</span><br><span class="line">                            description: message is a human readable message indicating</span><br><span class="line">                              details about the transition. This may be an empty string.</span><br><span class="line">                            maxLength: 32768</span><br><span class="line">                            type: string</span><br><span class="line">                          observedGeneration:</span><br><span class="line">                            description: observedGeneration represents the .metadata.generation</span><br><span class="line">                              that the condition was set based upon. For instance, if</span><br><span class="line">                              .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration</span><br><span class="line">                              is 9, the condition is out of date with respect to the</span><br><span class="line">                              current state of the instance.</span><br><span class="line">                            format: int64</span><br><span class="line">                            minimum: 0</span><br><span class="line">                            type: integer</span><br><span class="line">                          reason:</span><br><span class="line">                            description: reason contains a programmatic identifier indicating</span><br><span class="line">                              the reason for the condition&#x27;s last transition. Producers</span><br><span class="line">                              of specific condition types may define expected values</span><br><span class="line">                              and meanings for this field, and whether the values are</span><br><span class="line">                              considered a guaranteed API. The value should be a CamelCase</span><br><span class="line">                              string. This field may not be empty.</span><br><span class="line">                            maxLength: 1024</span><br><span class="line">                            minLength: 1</span><br><span class="line">                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$</span><br><span class="line">                            type: string</span><br><span class="line">                          status:</span><br><span class="line">                            description: status of the condition, one of True, False,</span><br><span class="line">                              Unknown.</span><br><span class="line">                            enum:</span><br><span class="line">                              - &quot;True&quot;</span><br><span class="line">                              - &quot;False&quot;</span><br><span class="line">                              - Unknown</span><br><span class="line">                            type: string</span><br><span class="line">                          type:</span><br><span class="line">                            description: type of condition in CamelCase or in foo.example.com/CamelCase.</span><br><span class="line">                              --- Many .condition.type values are consistent across</span><br><span class="line">                              resources like Available, but because arbitrary conditions</span><br><span class="line">                              can be useful (see .node.status.conditions), the ability</span><br><span class="line">                              to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)</span><br><span class="line">                            maxLength: 316</span><br><span class="line">                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$</span><br><span class="line">                            type: string</span><br><span class="line">                        required:</span><br><span class="line">                          - lastTransitionTime</span><br><span class="line">                          - message</span><br><span class="line">                          - reason</span><br><span class="line">                          - status</span><br><span class="line">                          - type</span><br><span class="line">                        type: object</span><br><span class="line">                      type: array</span><br><span class="line">                      x-kubernetes-list-map-keys:</span><br><span class="line">                        - type</span><br><span class="line">                      x-kubernetes-list-type: map</span><br><span class="line">                    loadBalancer:</span><br><span class="line">                      description: LoadBalancer contains the current status of the load-balancer,</span><br><span class="line">                        if one is present.</span><br><span class="line">                      properties:</span><br><span class="line">                        ingress:</span><br><span class="line">                          description: Ingress is a list containing ingress points for</span><br><span class="line">                            the load-balancer. Traffic intended for the service should</span><br><span class="line">                            be sent to these ingress points.</span><br><span class="line">                          items:</span><br><span class="line">                            description: &#x27;LoadBalancerIngress represents the status</span><br><span class="line">                            of a load-balancer ingress point: traffic intended for</span><br><span class="line">                            the service should be sent to an ingress point.&#x27;</span><br><span class="line">                            properties:</span><br><span class="line">                              hostname:</span><br><span class="line">                                description: Hostname is set for load-balancer ingress</span><br><span class="line">                                  points that are DNS based (typically AWS load-balancers)</span><br><span class="line">                                type: string</span><br><span class="line">                              ip:</span><br><span class="line">                                description: IP is set for load-balancer ingress points</span><br><span class="line">                                  that are IP based (typically GCE or OpenStack load-balancers)</span><br><span class="line">                                type: string</span><br><span class="line">                              ipMode:</span><br><span class="line">                                description: IPMode specifies how the load-balancer</span><br><span class="line">                                  IP behaves, and may only be specified when the ip</span><br><span class="line">                                  field is specified. Setting this to &quot;VIP&quot; indicates</span><br><span class="line">                                  that traffic is delivered to the node with the destination</span><br><span class="line">                                  set to the load-balancer&#x27;s IP and port. Setting this</span><br><span class="line">                                  to &quot;Proxy&quot; indicates that traffic is delivered to</span><br><span class="line">                                  the node or pod with the destination set to the node&#x27;s</span><br><span class="line">                                  IP and node port or the pod&#x27;s IP and port. Service</span><br><span class="line">                                  implementations may use this information to adjust</span><br><span class="line">                                  traffic routing.</span><br><span class="line">                                type: string</span><br><span class="line">                              ports:</span><br><span class="line">                                description: Ports is a list of records of service ports</span><br><span class="line">                                  If used, every port defined in the service should</span><br><span class="line">                                  have an entry in it</span><br><span class="line">                                items:</span><br><span class="line">                                  properties:</span><br><span class="line">                                    error:</span><br><span class="line">                                      description: &#x27;Error is to record the problem with</span><br><span class="line">                                      the service port The format of the error shall</span><br><span class="line">                                      comply with the following rules: - built-in</span><br><span class="line">                                      error values shall be specified in this file</span><br><span class="line">                                      and those shall use CamelCase names - cloud</span><br><span class="line">                                      provider specific error values must have names</span><br><span class="line">                                      that comply with the format foo.example.com/CamelCase.</span><br><span class="line">                                      --- The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)&#x27;</span><br><span class="line">                                      maxLength: 316</span><br><span class="line">                                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$</span><br><span class="line">                                      type: string</span><br><span class="line">                                    port:</span><br><span class="line">                                      description: Port is the port number of the service</span><br><span class="line">                                        port of which status is recorded here</span><br><span class="line">                                      format: int32</span><br><span class="line">                                      type: integer</span><br><span class="line">                                    protocol:</span><br><span class="line">                                      default: TCP</span><br><span class="line">                                      description: &#x27;Protocol is the protocol of the</span><br><span class="line">                                      service port of which status is recorded here</span><br><span class="line">                                      The supported values are: &quot;TCP&quot;, &quot;UDP&quot;, &quot;SCTP&quot;&#x27;</span><br><span class="line">                                      type: string</span><br><span class="line">                                  required:</span><br><span class="line">                                    - port</span><br><span class="line">                                    - protocol</span><br><span class="line">                                  type: object</span><br><span class="line">                                type: array</span><br><span class="line">                                x-kubernetes-list-type: atomic</span><br><span class="line">                            type: object</span><br><span class="line">                          type: array</span><br><span class="line">                      type: object</span><br><span class="line">                  type: object</span><br><span class="line">              type: object</span><br><span class="line">          type: object</span><br><span class="line">      served: true</span><br><span class="line">      storage: true</span><br></pre></td></tr></table></figure><h2 id="手动注册版本v1的-CRD-资源"><a href="#手动注册版本v1的-CRD-资源" class="headerlink" title="手动注册版本v1的 CRD 资源"></a>手动注册版本v1的 CRD 资源</h2><ul><li>在生成了客户端代码后，我们还需要手动注册版本v1的CRD资源，才能真正使用这个client，不然在编译时会出现 undefined: v1alpha1.AddToScheme 错误、undefined: v1alpha1.Resource 错误。</li><li>v1alpha1.AddToScheme、v1alpha1.Resource 这两个是用于 client 注册的</li></ul><p>编写 v1&#x2F;register.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;crd-controller-demo/pkg/apis/appcontroller&quot;</span><br><span class="line"></span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// SchemeGroupVersion is group version used to register these objects</span><br><span class="line">var SchemeGroupVersion = schema.GroupVersion&#123;Group: appcontroller.GroupName, Version: &quot;v1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Kind takes an unqualified kind and returns back a Group qualified GroupKind</span><br><span class="line">func Kind(kind string) schema.GroupKind &#123;</span><br><span class="line">return SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span><br><span class="line">func Resource(resource string) schema.GroupResource &#123;</span><br><span class="line">return SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// SchemeBuilder initializes a scheme builder</span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Adds the list of known types to Scheme.</span><br><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;App&#123;&#125;,</span><br><span class="line">&amp;AppList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator开发之api和apimachinery篇</title>
      <link href="/posts/4a17d0012.html"/>
      <url>/posts/4a17d0012.html</url>
      
        <content type="html"><![CDATA[<h2 id="k8s-io-api-项目"><a href="#k8s-io-api-项目" class="headerlink" title="k8s.io&#x2F;api 项目"></a>k8s.io&#x2F;api 项目</h2><h3 id="k8s-io-api-项目是什么"><a href="#k8s-io-api-项目是什么" class="headerlink" title="k8s.io&#x2F;api 项目是什么"></a>k8s.io&#x2F;api 项目是什么</h3><p>一开始，kubernetes的 内建资源 还不太多，内建资源的 结构定义，都是放在项目里维护的。后来为了方便资源的管理和扩展，将 所有内建资源 的结构定义文件、scheme注册文件、deepcopy等文件，放入了 staging&#x2F;src 目录下，作为一个单独的项目维护。该项目的名称就是 k8s.io&#x2F;api。因此，简单来说，k8s.io&#x2F;api 项目，维护着 Kubernetes 所有内建资源 的 struct定义。</p><h3 id="k8s-io-api-的源码分析"><a href="#k8s-io-api-的源码分析" class="headerlink" title="k8s.io&#x2F;api 的源码分析"></a>k8s.io&#x2F;api 的源码分析</h3><p>每一个目录，都代表一个group；一个 Group 下，可能会存在多个 Version。每个version下，都会包含三个文件：doc.go、register.go、types.go。</p><ul><li>doc.go：声明了按照 package 维度，为所有 structs 提供生成的声明</li><li>types.go：编写资源的详细结构，一般包括：资源、资源List、资源Spec、资源Status 的详细定义</li><li>register.go：提供注册到 runtime.Scheme 的函数<br>因此，我们操作内建资源的时候，所有 GVK 内建资源的结构，都是由 k8s.io&#x2F;api 这个项目提供的。</li></ul><h2 id="k8s-io-apimachinery-项目"><a href="#k8s-io-apimachinery-项目" class="headerlink" title="k8s.io&#x2F;apimachinery 项目"></a>k8s.io&#x2F;apimachinery 项目</h2><h3 id="k8s-io-apimachinery-项目是什么"><a href="#k8s-io-apimachinery-项目是什么" class="headerlink" title="k8s.io&#x2F;apimachinery 项目是什么"></a>k8s.io&#x2F;apimachinery 项目是什么</h3><p>k8s.io&#x2F;apimachinery 项目是一个关于Kubernetes API资源的工具集，为 k8s.io&#x2F;api 项目所有的资源，提供下列能力。</p><ul><li>ObjectMeta与TypeMeta</li><li>Scheme</li><li>RESTMapper</li><li>编码与解码</li><li>版本转换<br>有了 k8s.io&#x2F;apimachinery，就可以很方便的操作 kubernetes API。</li></ul><h3 id="k8s-io-apimachinery-提供-TypeMeta-与-ObjectMeta"><a href="#k8s-io-apimachinery-提供-TypeMeta-与-ObjectMeta" class="headerlink" title="k8s.io&#x2F;apimachinery 提供 TypeMeta 与 ObjectMeta"></a>k8s.io&#x2F;apimachinery 提供 TypeMeta 与 ObjectMeta</h3><p>TypeMeta 与 ObjectMeta 是特别常用的两个数据结构。kubernetes 的每一个资源，都会包含一个 TypeMeta、一个ObjectMeta。</p><ul><li>TypeMeta是内嵌的，转json的时候不会有嵌套结构</li><li>ObjectMeta，json标签就是 metadata<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Pod struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br><span class="line">Spec PodSpec `json:&quot;spec,omitempty&quot; protobuf:&quot;bytes,2,opt,name=spec&quot;`</span><br><span class="line">Status PodStatus `json:&quot;status,omitempty&quot; protobuf:&quot;bytes,3,opt,name=status&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>TypeMeta：位于 apimachinery&#x2F;pkg&#x2F;runtime&#x2F;types.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type TypeMeta struct &#123;</span><br><span class="line">// +optional</span><br><span class="line">APIVersion string `json:&quot;apiVersion,omitempty&quot; yaml:&quot;apiVersion,omitempty&quot; protobuf:&quot;bytes,1,opt,name=apiVersion&quot;`</span><br><span class="line">// +optional</span><br><span class="line">Kind string `json:&quot;kind,omitempty&quot; yaml:&quot;kind,omitempty&quot; protobuf:&quot;bytes,2,opt,name=kind&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectMeta：位于 apimachinery&#x2F;pkg&#x2F;apis&#x2F;meta&#x2F;v1&#x2F;types.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type ObjectMeta struct &#123;</span><br><span class="line">Name string `json:&quot;name,omitempty&quot; protobuf:&quot;bytes,1,opt,name=name&quot;`</span><br><span class="line">GenerateName string `json:&quot;generateName,omitempty&quot; protobuf:&quot;bytes,2,opt,name=generateName&quot;`</span><br><span class="line">Namespace string `json:&quot;namespace,omitempty&quot; protobuf:&quot;bytes,3,opt,name=namespace&quot;`</span><br><span class="line">SelfLink string `json:&quot;selfLink,omitempty&quot; protobuf:&quot;bytes,4,opt,name=selfLink&quot;`</span><br><span class="line">UID types.UID `json:&quot;uid,omitempty&quot; protobuf:&quot;bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID&quot;`</span><br><span class="line">ResourceVersion string `json:&quot;resourceVersion,omitempty&quot; protobuf:&quot;bytes,6,opt,name=resourceVersion&quot;`</span><br><span class="line">Generation int64 `json:&quot;generation,omitempty&quot; protobuf:&quot;varint,7,opt,name=generation&quot;`</span><br><span class="line">CreationTimestamp Time `json:&quot;creationTimestamp,omitempty&quot; protobuf:&quot;bytes,8,opt,name=creationTimestamp&quot;`</span><br><span class="line">DeletionTimestamp *Time `json:&quot;deletionTimestamp,omitempty&quot; protobuf:&quot;bytes,9,opt,name=deletionTimestamp&quot;`</span><br><span class="line">DeletionGracePeriodSeconds *int64 `json:&quot;deletionGracePeriodSeconds,omitempty&quot; protobuf:&quot;varint,10,opt,name=deletionGracePeriodSeconds&quot;`</span><br><span class="line">Labels map[string]string `json:&quot;labels,omitempty&quot; protobuf:&quot;bytes,11,rep,name=labels&quot;`</span><br><span class="line">Annotations map[string]string `json:&quot;annotations,omitempty&quot; protobuf:&quot;bytes,12,rep,name=annotations&quot;`</span><br><span class="line">OwnerReferences []OwnerReference `json:&quot;ownerReferences,omitempty&quot; patchStrategy:&quot;merge&quot; patchMergeKey:&quot;uid&quot; protobuf:&quot;bytes,13,rep,name=ownerReferences&quot;`</span><br><span class="line">Finalizers []string `json:&quot;finalizers,omitempty&quot; patchStrategy:&quot;merge&quot; protobuf:&quot;bytes,14,rep,name=finalizers&quot;`</span><br><span class="line">ZZZ_DeprecatedClusterName string `json:&quot;clusterName,omitempty&quot; protobuf:&quot;bytes,15,opt,name=clusterName&quot;`</span><br><span class="line">ManagedFields []ManagedFieldsEntry `json:&quot;managedFields,omitempty&quot; protobuf:&quot;bytes,17,rep,name=managedFields&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k8s-io-apimachinery-的rumetime-schema包提供-GVRK-各种数据结构"><a href="#k8s-io-apimachinery-的rumetime-schema包提供-GVRK-各种数据结构" class="headerlink" title="k8s.io&#x2F;apimachinery 的rumetime&#x2F;schema包提供 GVRK 各种数据结构"></a>k8s.io&#x2F;apimachinery 的rumetime&#x2F;schema包提供 GVRK 各种数据结构</h3><p>在kubernetes中，为了方便描述资源，或描述REST 的URL，提出了5个概念：</p><ul><li>GV：GroupVersion</li><li>GR：GroupResource</li><li>GVR：GroupVersionResource</li><li>GK：GroupKind</li><li>GVK：GroupVersionKind<br>其中，GR、GVR都是用来描述 RESTFUL API 的，GK、GVK都是用来描述资源类型的.这 5种数据结构的 struct 定义，都是写在 k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;schema&#x2F;group_version.go 文件中;该文件中还提供了这5种数据结构相互转换的方法.其中，APIVersion Kind，就是我们平时写yaml看到的apiVersion：Group&#x2F;Version Kind</li></ul><h3 id="k8s-io-apimachinery-提供-scheme-数据结构"><a href="#k8s-io-apimachinery-提供-scheme-数据结构" class="headerlink" title="k8s.io&#x2F;apimachinery 提供 scheme 数据结构"></a>k8s.io&#x2F;apimachinery 提供 scheme 数据结构</h3><p>1、资源的internal版本、external版本<br>资源的internal版本、external版本是什么？</p><p>kubernetes的资源，并非一下就确定好的，是有一个发展过程的，因此一个资源Kind，可能在多个 GroupVersion 下同时存在。比如 Deployment，在apps&#x2F;v1下存在，在apps&#x2F;v1beta1下也存在。那么，在kubernetes的开发者想要处理Deployment的时候，到底应该按照哪个版本写程序呢？按理说，每一种GVK都要有相应的处理方法。但是这样实在是太繁琐了，维护起来不方便，还会有大量重复代码。因此，为每一种GK，维护了一个internal版本，作为中转节点。apps&#x2F;v1&#x2F;Deployment 和 apps&#x2F;v1beta1&#x2F;Deployment 的相互转换，均是先转成internal的Deployment，再转成对外的版本。kubernetes的作者们，只需要对 internal版本 的资源编写逻辑，就可以处理所有version的资源。这种设计方式，将GVK之间的 拓扑结构，变成了星型结构，非常巧妙。</p><p>2、internal版本 和 external版本 相互转换的源码位置</p><p>kubernetes&#x2F;pkg&#x2F;apis 中，每个目录都是一个group，每个group都有一个 internal 的 资源 types.go 文件</p><p>3、scheme的作用</p><ul><li>kubernetes的资源版本太多了，没有谁专门有时间去维护，还是让资源自己来注册比较方便。</li><li>scheme就是为资源注册信息设计的一个数据结构，每个GVK，将自己的信息封装成一个scheme对象，并将这个scheme对象交给APIServer统一管理，API Server就能够认识这种 GVK 了<br>在k8s.io&#x2F;api 项目中，每一个GV下都有一个register.go文件，里面就是将当前GV下的所有Kind，注册到 APIServer 的统一scheme中去。比如 staging&#x2F;src&#x2F;k8s.io&#x2F;api&#x2F;apps&#x2F;v1&#x2F;register.go 文件，<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// GroupName is the group name use in this package</span><br><span class="line">const GroupName = &quot;apps&quot;</span><br><span class="line"></span><br><span class="line">// SchemeGroupVersion is group version used to register these objects</span><br><span class="line">var SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: &quot;v1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span><br><span class="line">func Resource(resource string) schema.GroupResource &#123;</span><br><span class="line">return SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// TODO: move SchemeBuilder with zz_generated.deepcopy.go to k8s.io/api.</span><br><span class="line">// localSchemeBuilder and AddToScheme will stay in k8s.io/kubernetes.</span><br><span class="line">SchemeBuilder      = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">localSchemeBuilder = &amp;SchemeBuilder</span><br><span class="line">AddToScheme        = localSchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Adds the list of known types to the given scheme.</span><br><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Deployment&#123;&#125;,</span><br><span class="line">&amp;DeploymentList&#123;&#125;,</span><br><span class="line">&amp;StatefulSet&#123;&#125;,</span><br><span class="line">&amp;StatefulSetList&#123;&#125;,</span><br><span class="line">&amp;DaemonSet&#123;&#125;,</span><br><span class="line">&amp;DaemonSetList&#123;&#125;,</span><br><span class="line">&amp;ReplicaSet&#123;&#125;,</span><br><span class="line">&amp;ReplicaSetList&#123;&#125;,</span><br><span class="line">&amp;ControllerRevision&#123;&#125;,</span><br><span class="line">&amp;ControllerRevisionList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3、k8s.io&#x2F;apimachinery 提供 scheme 数据结构</p><p>根据前面的描述，我们知道scheme是一个数据结构，它的struct其实就是 k8s.io&#x2F;apimachinery 提供的。在 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;scheme.go 文件中，有 Scheme 结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">type Scheme struct &#123;</span><br><span class="line">    // map，记录 gvk--&gt;type。其中type是通过反射的方式记录的</span><br><span class="line">  gvkToType map[schema.GroupVersionKind]reflect.Type</span><br><span class="line">  </span><br><span class="line">  // map，记录 type--&gt;gvk</span><br><span class="line">  typeToGVK map[reflect.Type][]schema.GroupVersionKind</span><br><span class="line">  </span><br><span class="line">  // map，记录 type--&gt;gvk。像pod这种，只有一个version的，就记录在这里。</span><br><span class="line">  unversionedTypes map[reflect.Type]schema.GroupVersionKind</span><br><span class="line">  </span><br><span class="line">  // map，记录 gvk--&gt;type。像pod这种，只有一个version的，就记录在这里。</span><br><span class="line">  unversionedKinds map[string]reflect.Type</span><br><span class="line">  </span><br><span class="line">  // Map from version and resource to the corresponding func to convert</span><br><span class="line">  // resource field labels in that version to internal version.</span><br><span class="line">  fieldLabelConversionFuncs map[schema.GroupVersionKind]FieldLabelConversionFunc</span><br><span class="line">  </span><br><span class="line">  // map，记录默认方法。为某一个具体的type，设置默认值</span><br><span class="line">  defaulterFuncs map[reflect.Type]func(interface&#123;&#125;)</span><br><span class="line">  </span><br><span class="line">  // 转换器</span><br><span class="line">  converter *conversion.Converter</span><br><span class="line">  </span><br><span class="line">  // 记录version的优先级。当没有选择version的时候，优先使用谁</span><br><span class="line">  versionPriority map[string][]string</span><br><span class="line">  </span><br><span class="line">  // observedVersions keeps track of the order we&#x27;ve seen versions during type registration</span><br><span class="line">  observedVersions []schema.GroupVersion</span><br><span class="line">  </span><br><span class="line">  // schemeName is the name of this scheme.  If you don&#x27;t specify a name, the stack of the NewScheme caller will be used.</span><br><span class="line">  // This is useful for error reporting to indicate the origin of the scheme.</span><br><span class="line">  schemeName string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scheme结构中，所有的字段首字母都是小写的，即非导出的，外界无法访问。为此，staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;scheme.go 文件中还提供了一个方法 NewScheme()，用于初始化一个空的Scheme对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func NewScheme() *Scheme &#123;</span><br><span class="line">s := &amp;Scheme&#123;</span><br><span class="line">gvkToType:                 map[schema.GroupVersionKind]reflect.Type&#123;&#125;,</span><br><span class="line">typeToGVK:                 map[reflect.Type][]schema.GroupVersionKind&#123;&#125;,</span><br><span class="line">unversionedTypes:          map[reflect.Type]schema.GroupVersionKind&#123;&#125;,</span><br><span class="line">unversionedKinds:          map[string]reflect.Type&#123;&#125;,</span><br><span class="line">fieldLabelConversionFuncs: map[schema.GroupVersionKind]FieldLabelConversionFunc&#123;&#125;,</span><br><span class="line">defaulterFuncs:            map[reflect.Type]func(interface&#123;&#125;)&#123;&#125;,</span><br><span class="line">versionPriority:           map[string][]string&#123;&#125;,</span><br><span class="line">schemeName:                naming.GetNameFromCallsite(internalPackages...),</span><br><span class="line">&#125;</span><br><span class="line">s.converter = conversion.NewConverter(nil)</span><br><span class="line"></span><br><span class="line">// Enable couple default conversions by default.</span><br><span class="line">utilruntime.Must(RegisterEmbeddedConversions(s))</span><br><span class="line">utilruntime.Must(RegisterStringConversions(s))</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;scheme.go 文件还提供了很多方法，用于将GVK注册到Scheme对象中。用的比较多的是AddKnownTypes()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types ...Object) &#123;</span><br><span class="line">s.addObservedVersion(gv)</span><br><span class="line">for _, obj := range types &#123;</span><br><span class="line">t := reflect.TypeOf(obj)</span><br><span class="line">if t.Kind() != reflect.Ptr &#123;</span><br><span class="line">panic(&quot;All types must be pointers to structs.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t = t.Elem()</span><br><span class="line">s.AddKnownTypeWithName(gv.WithKind(t.Name()), obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、Scheme结构提供的常用方法</p><ul><li><p>AddKnownTypes</p><ul><li>方法签名：func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types …Object)</li><li>方法功能：向 scheme 中注册GVK，参数1 gv 表示 GroupVersion，参数2 types 是具体的 Kind 类型</li><li>举例：staging&#x2F;src&#x2F;k8s.io&#x2F;api&#x2F;apps&#x2F;v1&#x2F;register.go 文件中，使用 AddKnownTypes 方法，将apps&#x2F;v1下的所有Kind，都注册到scheme中去</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Deployment&#123;&#125;,</span><br><span class="line">&amp;DeploymentList&#123;&#125;,</span><br><span class="line">&amp;StatefulSet&#123;&#125;,</span><br><span class="line">&amp;StatefulSetList&#123;&#125;,</span><br><span class="line">&amp;DaemonSet&#123;&#125;,</span><br><span class="line">&amp;DaemonSetList&#123;&#125;,</span><br><span class="line">&amp;ReplicaSet&#123;&#125;,</span><br><span class="line">&amp;ReplicaSetList&#123;&#125;,</span><br><span class="line">&amp;ControllerRevision&#123;&#125;,</span><br><span class="line">&amp;ControllerRevisionList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>KnownTypes</p><ul><li>方法签名：func (s *Scheme) KnownTypes(gv schema.GroupVersion) map[string]reflect.Type</li><li>方法功能：获取指定GV下所有Kind的Type类型</li><li>举例</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">types := Scheme.KnownTypes(schema.GroupVersion&#123;</span><br><span class="line">    Group:   &quot;apps&quot;,</span><br><span class="line">    Version: &quot;v1&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>VersionsForGroupKind</p><ul><li>方法签名：func (s *Scheme) VersionsForGroupKind(gk schema.GroupKind) []schema.GroupVersion</li><li>方法功能：获取指定GK的所有Versions，并以GV列表的形式返回</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupVersions := Scheme.VersionsForGroupKind(</span><br><span class="line">schema.GroupKind&#123;</span><br><span class="line">        Group: &quot;apps&quot;,</span><br><span class="line">        Kind:  &quot;Deployment&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">// 输出</span><br><span class="line">[&quot;apps/v1&quot; &quot;apps/v1beta1&quot; &quot;apps/v1beta2&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>ObjectKinds</p><ul><li>方法签名：func (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error)</li><li>方法功能：获取指定object 的 所有可能的 group、version、kind 值，并以 GVK 列表的形式返回</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gvks, notVersioned, err := Scheme.ObjectKinds(&amp;appsv1.Deployment&#123;&#125;)</span><br><span class="line">// 输出</span><br><span class="line">[&quot;apps/v1 Deployment&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>New</p><ul><li>方法签名：func (s *Scheme) New(kind schema.GroupVersionKind) (Object, error)</li><li>方法功能：根据指定的GVK，创建该资源的一个对象</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deployment, err := Scheme.New(schema.GroupVersionKind&#123;</span><br><span class="line">    Group:   &quot;apps&quot;,</span><br><span class="line">    Version: &quot;v1&quot;,</span><br><span class="line">    Kind:    &quot;Deployment&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>AddConversionFunc<ul><li>方法源码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s *Scheme) AddConversionFunc(a, b interface&#123;&#125;, fn conversion.ConversionFunc) error &#123;</span><br><span class="line">return s.converter.RegisterUntypedConversionFunc(a, b, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>该方法，用于向scheme中注册 不同资源 的自定义转换器。</p><h3 id="k8s-io-apimachinery-提供-RESTMapper-结构"><a href="#k8s-io-apimachinery-提供-RESTMapper-结构" class="headerlink" title="k8s.io&#x2F;apimachinery 提供 RESTMapper 结构"></a>k8s.io&#x2F;apimachinery 提供 RESTMapper 结构</h3><p>1、理解GVR和GVK的用途</p><p>在 上面中提到，k8s.io&#x2F;apimachinery 提供了 GR&#x2F;GVR、GK&#x2F;GVK 等数据结构。GR和GVR 负责对接 RESTful 风格的url路径，GK和GVK 负责确定一个具体的kubernetes资源</p><ul><li>GVR举例：<br>用户想要获取 apps组下、v1版本的 deployments，如何编写url地址？–&gt; GET &#x2F;apis&#x2F;apps&#x2F;v1&#x2F;deployments.这个url中，就可以使用 GVR 描述，group为apps，version为v1，Resource为deployments</li><li>GVK举例：<br>当kubernetes的代码中，想要操作一个资源的时候，如何找到资源的struct 结构？通过GVK去找。比如 apps&#x2F;v1&#x2F;Deployment，就可以确定 group为apps，version为v1，kind为Deployment，就可以找到这个资源的struct</li></ul><p>2、RESTMapper是什么</p><p>当用户使用 REST风格 的 url 访问资源时，kubernetes如何确定需要操作哪一个GVK呢？REST风格 的 url，可以从中得到 GVR，只需要完成 GVR 到 GVK 的转换就可以了。因此，apimachinery维护了一个数据结构 RESTMapper，记录 GVR 和 GVK 的映射关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type RESTMapping struct &#123;</span><br><span class="line">// Resource is the GroupVersionResource (location) for this endpoint</span><br><span class="line">Resource schema.GroupVersionResource</span><br><span class="line"></span><br><span class="line">// GroupVersionKind is the GroupVersionKind (data format) to submit to this endpoint</span><br><span class="line">GroupVersionKind schema.GroupVersionKind</span><br><span class="line"></span><br><span class="line">// Scope contains the information needed to deal with REST Resources that are in a resource hierarchy</span><br><span class="line">Scope RESTScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，apimachinery还提供了一个接口 RESTMapper，接口中提供了 将 GVR 转成 GVK 的方法。其中，KindFor 和 KindsFor 就是将 GVR 转成 GVK 的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type RESTMapper interface &#123;</span><br><span class="line">// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span><br><span class="line">KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line">// KindsFor takes a partial resource and returns the list of potential kinds in priority order</span><br><span class="line">KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line">// ResourceFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span><br><span class="line">ResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line">// ResourcesFor takes a partial resource and returns the list of potential resource in priority order</span><br><span class="line">ResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line">// RESTMapping identifies a preferred resource mapping for the provided group kind.</span><br><span class="line">RESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error)</span><br><span class="line">// RESTMappings returns all resource mappings for the provided group kind if no</span><br><span class="line">// version search is provided. Otherwise identifies a preferred resource mapping for</span><br><span class="line">// the provided version(s).</span><br><span class="line">RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error)</span><br><span class="line"></span><br><span class="line">ResourceSingularizer(resource string) (singular string, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、DefaultRESTMapper</p><p>RESTMapper接口，有一个默认的实现 DefaultRESTMapper.位于 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;api&#x2F;meta&#x2F;restmapper.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type DefaultRESTMapper struct &#123;</span><br><span class="line">defaultGroupVersions []schema.GroupVersion</span><br><span class="line"></span><br><span class="line">resourceToKind       map[schema.GroupVersionResource]schema.GroupVersionKind</span><br><span class="line">kindToPluralResource map[schema.GroupVersionKind]schema.GroupVersionResource</span><br><span class="line">kindToScope          map[schema.GroupVersionKind]RESTScope</span><br><span class="line">singularToPlural     map[schema.GroupVersionResource]schema.GroupVersionResource</span><br><span class="line">pluralToSingular     map[schema.GroupVersionResource]schema.GroupVersionResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;api&#x2F;meta&#x2F;restmapper.go 中还提供了一个 NewDefaultRESTMapper 方法，用于新建一个DefaultRESTMapper</p><h3 id="k8s-io-apimachinery-提供序列化、编解码能力"><a href="#k8s-io-apimachinery-提供序列化、编解码能力" class="headerlink" title="k8s.io&#x2F;apimachinery 提供序列化、编解码能力"></a>k8s.io&#x2F;apimachinery 提供序列化、编解码能力</h3><p>1、k8s.io&#x2F;apimachinery 的 runtime.serializer 包</p><p>k8s.io&#x2F;apimachinery 中，关于 序列化 和 编解码 的代码，大都在 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;serializer 包下。<br>    json、protobuf、yaml包，分别提供了对应格式的序列化器，共3种序列化器</p><p>2、k8s.io&#x2F;apimachinery 提供了序列化的通用接口</p><ul><li><p>staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;interfaces.go 文件中，提供了序列化的通用接口 Serializer。Serializer接口提供了编解码能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Serializer interface &#123;</span><br><span class="line">Encoder</span><br><span class="line">Decoder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Encoder是编码器接口，还是在 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;interfaces.go 文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Encoder interface &#123;</span><br><span class="line">Encode(obj Object, w io.Writer) error</span><br><span class="line">Identifier() Identifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Decoder是解码器接口，还是在 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;interfaces.go 文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Decoder interface &#123;</span><br><span class="line">Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、json 序列化器</p></li><li><p>staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;serializer&#x2F;json&#x2F;json.go 文件中，提供了json序列化器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Serializer struct &#123;</span><br><span class="line">meta    MetaFactory</span><br><span class="line">options SerializerOptions</span><br><span class="line">creater runtime.ObjectCreater</span><br><span class="line">typer   runtime.ObjectTyper</span><br><span class="line"></span><br><span class="line">identifier runtime.Identifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  json序列化器 实现了 runtime.interface.go 中的Serializer接口，实现了 Encode、Decode方法<br>  创建一个json序列化器，有多个方法<br>  NewSerializer、NewSerializerWithOptions</p></li></ul><p>4、yaml 序列化器</p><ul><li>staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;serializer&#x2F;yaml&#x2F;yaml.go 文件中，提供了yaml序列化器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type yamlSerializer struct &#123;</span><br><span class="line">// the nested serializer</span><br><span class="line">runtime.Serializer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>yaml序列化器 实现了 runtime.interface.go 中的Serializer接口</li></ul><p>5、protobuf 序列化器</p><ul><li>staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;serializer&#x2F;protobuf&#x2F;protobuf.go 文件中，提供了protobuf序列化器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Serializer struct &#123;</span><br><span class="line">prefix  []byte</span><br><span class="line">creater runtime.ObjectCreater</span><br><span class="line">typer   runtime.ObjectTyper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>protobuf序列化器 实现了 runtime.interface.go 中的Serializer接口</li></ul><h3 id="k8s-io-apimachinery-提供-不同资源-相互转换能力"><a href="#k8s-io-apimachinery-提供-不同资源-相互转换能力" class="headerlink" title="k8s.io&#x2F;apimachinery 提供 不同资源 相互转换能力"></a>k8s.io&#x2F;apimachinery 提供 不同资源 相互转换能力</h3><ul><li>scheme提供了AddConversionFunc方法，用于向scheme中注册 不同资源 的自定义转换器。<br>举例：创建了一个Scheme对象，名为scheme。我们就可以通过下面的方法，注册 appsv1.Deployment 与 appsv1beta1.Deployment 的相互转换方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scheme.AddConversionFunc(</span><br><span class="line">    (*appsv1.Deployment)(nil),</span><br><span class="line">    (*appsv1beta1.Deployment)(nil),</span><br><span class="line">    func(a, b interface&#123;&#125;, scope conversion.Scope) error&#123;</span><br><span class="line">        v1deploy := a.(*appsv1.Deployment)</span><br><span class="line">        v1beta1deploy := b.(*appsv1beta1.Deployment)</span><br><span class="line">        // make conversion here</span><br><span class="line">        return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>controller-tools实战：自动生成代码</title>
      <link href="/posts/4a17d0011.html"/>
      <url>/posts/4a17d0011.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><ul><li>初始化go项目，并get client-go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">go mod init controller-tools-demo</span><br><span class="line"></span><br><span class="line">go get k8s.io/client-go</span><br><span class="line">go get k8s.io/apimachinery</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用type-scaffold工具生成types-go"><a href="#使用type-scaffold工具生成types-go" class="headerlink" title="使用type-scaffold工具生成types.go"></a>使用type-scaffold工具生成types.go</h2><ul><li>需要注意：<ul><li>type-scaffold并不会生成文件，而是生成types.go的内容，打印到控制台，我们需要手动copy到types.go文件中去</li><li>不过使用kubebuilder的时候，会帮我们生成types.go文件的</li></ul></li><li>执行 type-scaffold –kind&#x3D;Application，得到types.go的内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# type-scaffold --kind=Application</span><br><span class="line">// ApplicationSpec defines the desired state of Application</span><br><span class="line">type ApplicationSpec struct &#123;</span><br><span class="line">        // INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ApplicationStatus defines the observed state of Application.</span><br><span class="line">// It should always be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">type ApplicationStatus struct &#123;</span><br><span class="line">        // INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// Application is the Schema for the applications API</span><br><span class="line">// +k8s:openapi-gen=true</span><br><span class="line">type Application struct &#123;</span><br><span class="line">        metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">        metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">        Spec   ApplicationSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">        Status ApplicationStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// ApplicationList contains a list of Application</span><br><span class="line">type ApplicationList struct &#123;</span><br><span class="line">        metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">        metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">        Items           []Application `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在 v1alpha1 目录下创建 types.go 文件，将控制台的内容copy进去，记得导包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line"></span><br><span class="line">// ApplicationSpec defines the desired state of Application</span><br><span class="line">type ApplicationSpec struct &#123;</span><br><span class="line">// INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ApplicationStatus defines the observed state of Application.</span><br><span class="line">// It should always be reconstructable from the state of the cluster and/or outside world.</span><br><span class="line">type ApplicationStatus struct &#123;</span><br><span class="line">// INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// Application is the Schema for the applications API</span><br><span class="line">// +k8s:openapi-gen=true</span><br><span class="line">type Application struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   ApplicationSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">Status ApplicationStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">// ApplicationList contains a list of Application</span><br><span class="line">type ApplicationList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Items           []Application `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用controller-gen生成deepcopy和crd文件"><a href="#使用controller-gen生成deepcopy和crd文件" class="headerlink" title="使用controller-gen生成deepcopy和crd文件"></a>使用controller-gen生成deepcopy和crd文件</h2><h3 id="controller-gen-–help-查看帮助文档"><a href="#controller-gen-–help-查看帮助文档" class="headerlink" title="controller-gen –help 查看帮助文档"></a>controller-gen –help 查看帮助文档</h3><ul><li>帮助文档给出了很多 examples<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@master v1alpha1]# controller-gen --help</span><br><span class="line">Generate Kubernetes API extension resources and code.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  controller-gen [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">        # Generate RBAC manifests and crds for all types under apis/,</span><br><span class="line">        # outputting crds to /tmp/crds and everything else to stdout</span><br><span class="line">        controller-gen rbac:roleName=&lt;role name&gt; crd paths=./apis/... output:crd:dir=/tmp/crds output:stdout</span><br><span class="line"></span><br><span class="line">        # Generate deepcopy/runtime.Object implementations for a particular file</span><br><span class="line">        controller-gen object paths=./apis/v1beta1/some_types.go</span><br><span class="line"></span><br><span class="line">        # Generate OpenAPI v3 schemas for API packages and merge them into existing CRD manifests</span><br><span class="line">        controller-gen schemapatch:manifests=./manifests output:dir=./manifests paths=./pkg/apis/...</span><br><span class="line"></span><br><span class="line">        # Run all the generators for a given project</span><br><span class="line">        controller-gen paths=./apis/...</span><br><span class="line"></span><br><span class="line">        # Explain the markers for generating CRDs, and their arguments</span><br><span class="line">        controller-gen crd -ww</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --detailed-help count   print out more detailed help</span><br><span class="line">                              (up to -hhh for the most detailed output, or -hhhh for json output)</span><br><span class="line">      --help                  print out usage and a summary of options</span><br><span class="line">      --version               show version</span><br><span class="line">  -w, --which-markers count   print out all markers available with the requested generators</span><br><span class="line">                              (up to -www for the most detailed output, or -wwww for json output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">generators</span><br><span class="line"></span><br><span class="line">+webhook                                                                                                                                           package  generates (partial) &#123;Mutating,Validating&#125;WebhookConfiguration objects.</span><br><span class="line">+schemapatch[:generateEmbeddedObjectMeta=&lt;bool&gt;],manifests=&lt;string&gt;[,maxDescLen=&lt;int&gt;]                                                             package  patches existing CRDs with new schemata.</span><br><span class="line">+rbac:roleName=&lt;string&gt;                                                                                                                            package  generates ClusterRole objects.</span><br><span class="line">+object[:headerFile=&lt;string&gt;][,year=&lt;string&gt;]                                                                                                      package  generates code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations.</span><br><span class="line">+crd[:allowDangerousTypes=&lt;bool&gt;][,crdVersions=&lt;[]string&gt;][,generateEmbeddedObjectMeta=&lt;bool&gt;][,ignoreUnexportedFields=&lt;bool&gt;][,maxDescLen=&lt;int&gt;]  package  generates CustomResourceDefinition objects.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">generic</span><br><span class="line"></span><br><span class="line">+paths=&lt;[]string&gt;  package  represents paths and go-style path patterns to use as package roots.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output rules (optionally as output:&lt;generator&gt;:...)</span><br><span class="line"></span><br><span class="line">+output:artifacts[:code=&lt;string&gt;],config=&lt;string&gt;  package  outputs artifacts to different locations, depending on whether they&#x27;re package-associated or not.</span><br><span class="line">+output:dir=&lt;string&gt;                               package  outputs each artifact to the given directory, regardless of if it&#x27;s package-associated or not.</span><br><span class="line">+output:none                                       package  skips outputting anything.                                             </span><br><span class="line">+output:stdout                                     package  outputs everything to standard-out, with no separation. </span><br></pre></td></tr></table></figure></li></ul><h3 id="使用controller-gen生成deepcopy"><a href="#使用controller-gen生成deepcopy" class="headerlink" title="使用controller-gen生成deepcopy"></a>使用controller-gen生成deepcopy</h3><ul><li><p>先刷新一下包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">controller-gen object paths=pkg/apis/appcontroller/v1alpha1/types.go</span><br></pre></td></tr></table></figure></li><li><p>执行后，查看目录文件，发现生成了一个 zz_generated.deepcopy.go 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── appcontroller</span><br><span class="line">            └── v1alpha1</span><br><span class="line">                ├── types.go</span><br><span class="line">                └── zz_generated.deepcopy.go</span><br></pre></td></tr></table></figure></li><li><p>查看 zz_generated.deepcopy.go 文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//go:build !ignore_autogenerated</span><br><span class="line">// +build !ignore_autogenerated</span><br><span class="line"></span><br><span class="line">// Code generated by controller-gen. DO NOT EDIT.</span><br><span class="line"></span><br><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">runtime &quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *Application) DeepCopyInto(out *Application) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">out.TypeMeta = in.TypeMeta</span><br><span class="line">in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)</span><br><span class="line">out.Spec = in.Spec</span><br><span class="line">out.Status = in.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Application.</span><br><span class="line">func (in *Application) DeepCopy() *Application &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(Application)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.</span><br><span class="line">func (in *Application) DeepCopyObject() runtime.Object &#123;</span><br><span class="line">if c := in.DeepCopy(); c != nil &#123;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.</span><br><span class="line">func (in *ApplicationList) DeepCopyInto(out *ApplicationList) &#123;</span><br><span class="line">*out = *in</span><br><span class="line">out.TypeMeta = in.TypeMeta</span><br><span class="line">in.ListMeta.DeepCopyInto(&amp;out.ListMeta)</span><br><span class="line">if in.Items != nil &#123;</span><br><span class="line">in, out := &amp;in.Items, &amp;out.Items</span><br><span class="line">*out = make([]Application, len(*in))</span><br><span class="line">for i := range *in &#123;</span><br><span class="line">(*in)[i].DeepCopyInto(&amp;(*out)[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApplicationList.</span><br><span class="line">func (in *ApplicationList) DeepCopy() *ApplicationList &#123;</span><br><span class="line">if in == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">out := new(ApplicationList)</span><br><span class="line">in.DeepCopyInto(out)</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.</span><br><span class="line">func (in *ApplicationList) DeepCopyObject() runtime.Object &#123;</span><br><span class="line">if c := in.DeepCopy(); c != nil &#123;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用controller-gen生成crd"><a href="#使用controller-gen生成crd" class="headerlink" title="使用controller-gen生成crd"></a>使用controller-gen生成crd</h3><ul><li><p>先刷新一下包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">controller-gen crd paths=./... output:crd:dir=config/crd</span><br></pre></td></tr></table></figure></li><li><p>paths&#x3D;.&#x2F;… 表示将当前目录下的所有子目录都包括在生成过程中</p></li><li><p>output:crd:dir&#x3D;config&#x2F;crd 指定了输出目录为 config&#x2F;crd</p></li><li><p>执行后，生成目录 config 和 文件 _.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   └── crd</span><br><span class="line">│       └── _.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── appcontroller</span><br><span class="line">            └── v1alpha1</span><br><span class="line">                ├── types.go</span><br><span class="line">                └── zz_generated.deepcopy.go</span><br></pre></td></tr></table></figure></li><li><p>文件 _.yaml 没有名字？指定groupName后重新生成 crd 文件</p><ul><li>因为我们没有给它指定 groupName，所以生成的yaml文件默认没有名字</li><li>我们在 pkg&#x2F;apis&#x2F;appcontroller&#x2F;v1alpha1 下创建一个 doc.go 文件，并在里面写上如下内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// +groupName=appcontroller.k8s.io</span><br><span class="line">package v1alpha1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>然后删除原config后，重新生成crd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">rm -rf config</span><br><span class="line">controller-gen crd paths=./... output:crd:dir=config/crd</span><br></pre></td></tr></table></figure></li><li><p>生成完成后，目录如下</p><ul><li>crd文件名称为：appcontroller.k8s.io_applications.yaml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   └── crd</span><br><span class="line">│       └── appcontroller.k8s.io_applications.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── appcontroller</span><br><span class="line">            └── v1alpha1</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── types.go</span><br><span class="line">                └── zz_generated.deepcopy.go</span><br><span class="line"></span><br><span class="line">6 directories, 6 files</span><br></pre></td></tr></table></figure></li></ul></li><li><p>appcontroller.k8s.io_applications.yaml 内容如下</p><ul><li>可以看到，openAPIV3Schema.properties.spec 下面，没有 properties 项，因为我们的ApplicationSpec 为空，内部一个属性都没有。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    controller-gen.kubebuilder.io/version: (devel)</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: applications.appcontroller.k8s.io</span><br><span class="line">spec:</span><br><span class="line">  group: appcontroller.k8s.io</span><br><span class="line">  names:</span><br><span class="line">    kind: Application</span><br><span class="line">    listKind: ApplicationList</span><br><span class="line">    plural: applications</span><br><span class="line">    singular: application</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">  - name: v1alpha1</span><br><span class="line">    schema:</span><br><span class="line">      openAPIV3Schema:</span><br><span class="line">        description: Application is the Schema for the applications API</span><br><span class="line">        properties:</span><br><span class="line">          apiVersion:</span><br><span class="line">            description: &#x27;APIVersion defines the versioned schema of this representation</span><br><span class="line">              of an object. Servers should convert recognized schemas to the latest</span><br><span class="line">              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          kind:</span><br><span class="line">            description: &#x27;Kind is a string value representing the REST resource this</span><br><span class="line">              object represents. Servers may infer this from the endpoint the client</span><br><span class="line">              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          metadata:</span><br><span class="line">            type: object</span><br><span class="line">          spec:</span><br><span class="line">            description: ApplicationSpec defines the desired state of Application</span><br><span class="line">            type: object</span><br><span class="line">          status:</span><br><span class="line">            description: ApplicationStatus defines the observed state of Application.</span><br><span class="line">              It should always be reconstructable from the state of the cluster and/or</span><br><span class="line">              outside world.</span><br><span class="line">            type: object</span><br><span class="line">        type: object</span><br><span class="line">    served: true</span><br><span class="line">    storage: true</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="为ApplicationSpec添加内容，并重新生成crd文件"><a href="#为ApplicationSpec添加内容，并重新生成crd文件" class="headerlink" title="为ApplicationSpec添加内容，并重新生成crd文件"></a>为ApplicationSpec添加内容，并重新生成crd文件</h2><ul><li><p>修改types.go，在 ApplicationSpec 中添加两个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type ApplicationSpec struct &#123;</span><br><span class="line">// INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">Name     string `json:&quot;name&quot;`</span><br><span class="line">Replicas int32  `json:&quot;replicas&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除原config后，重新生成crd文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">rm -rf config</span><br><span class="line">controller-gen crd paths=./... output:crd:dir=config/crd</span><br></pre></td></tr></table></figure></li><li><p>新的crd文件内容如下：</p><ul><li>可以看到，openAPIV3Schema.properties.spec 下面，出现了 properties 项，因为我们为ApplicationSpec 添加了Name、Replicas两个值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    controller-gen.kubebuilder.io/version: (devel)</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: applications.appcontroller.k8s.io</span><br><span class="line">spec:</span><br><span class="line">  group: appcontroller.k8s.io</span><br><span class="line">  names:</span><br><span class="line">    kind: Application</span><br><span class="line">    listKind: ApplicationList</span><br><span class="line">    plural: applications</span><br><span class="line">    singular: application</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">  - name: v1alpha1</span><br><span class="line">    schema:</span><br><span class="line">      openAPIV3Schema:</span><br><span class="line">        description: Application is the Schema for the applications API</span><br><span class="line">        properties:</span><br><span class="line">          apiVersion:</span><br><span class="line">            description: &#x27;APIVersion defines the versioned schema of this representation</span><br><span class="line">              of an object. Servers should convert recognized schemas to the latest</span><br><span class="line">              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          kind:</span><br><span class="line">            description: &#x27;Kind is a string value representing the REST resource this</span><br><span class="line">              object represents. Servers may infer this from the endpoint the client</span><br><span class="line">              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          metadata:</span><br><span class="line">            type: object</span><br><span class="line">          spec:</span><br><span class="line">            description: ApplicationSpec defines the desired state of Application</span><br><span class="line">            properties:</span><br><span class="line">              name:</span><br><span class="line">                description: INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">                type: string</span><br><span class="line">              replicas:</span><br><span class="line">                format: int32</span><br><span class="line">                type: integer</span><br><span class="line">            required:</span><br><span class="line">            - name</span><br><span class="line">            - replicas</span><br><span class="line">            type: object</span><br><span class="line">          status:</span><br><span class="line">            description: ApplicationStatus defines the observed state of Application.</span><br><span class="line">              It should always be reconstructable from the state of the cluster and/or</span><br><span class="line">              outside world.</span><br><span class="line">            type: object</span><br><span class="line">        type: object</span><br><span class="line">    served: true</span><br><span class="line">    storage: true</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="手动注册版本v1alpha1的CRD资源"><a href="#手动注册版本v1alpha1的CRD资源" class="headerlink" title="手动注册版本v1alpha1的CRD资源"></a>手动注册版本v1alpha1的CRD资源</h2><ul><li>在生成了客户端代码后，我们还需要手动注册版本v1alpha1的CRD资源，才能真正使用这个client，不然在编译时会出现 undefined: v1alpha1.AddToScheme 错误、undefined: v1alpha1.Resource 错误。</li><li>v1alpha1.AddToScheme、v1alpha1.Resource 这两个是用于 client 注册的</li><li>编写 v1alpha1&#x2F;register.go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;controller-tools-demo/pkg/apis/appcontroller&quot;</span><br><span class="line"></span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// SchemeGroupVersion is group version used to register these objects</span><br><span class="line">var SchemeGroupVersion = schema.GroupVersion&#123;Group: appcontroller.GroupName, Version: &quot;v1alpha1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Kind takes an unqualified kind and returns back a Group qualified GroupKind</span><br><span class="line">func Kind(kind string) schema.GroupKind &#123;</span><br><span class="line">return SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span><br><span class="line">func Resource(resource string) schema.GroupResource &#123;</span><br><span class="line">return SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// SchemeBuilder initializes a scheme builder</span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Adds the list of known types to Scheme.</span><br><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Application&#123;&#125;,</span><br><span class="line">&amp;ApplicationList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在kubernetes集群中应用CRD"><a href="#在kubernetes集群中应用CRD" class="headerlink" title="在kubernetes集群中应用CRD"></a>在kubernetes集群中应用CRD</h2><h3 id="kubectl-apply-crd-资源"><a href="#kubectl-apply-crd-资源" class="headerlink" title="kubectl apply crd 资源"></a>kubectl apply crd 资源</h3><ul><li><p>上面我们已经使用 controller-gen 自动生成了 CRD 文件，名称为 appcontroller.k8s.io_applications.yaml，再 config&#x2F;crd 目录下</p></li><li><p>我们需要使用 kubectl apply 命令创建CR资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">kubectl apply -f config/crd/appcontroller.k8s.io_applications.yaml</span><br></pre></td></tr></table></figure></li><li><p>有可能报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The CustomResourceDefinition &quot;applications.appcontroller.k8s.io&quot; is invalid: metadata.annotations[api-approved.kubernetes.io]: Required value: protected groups must have approval annotation &quot;api-approved.kubernetes.io&quot;, see https://github.com/kubernetes/enhancements/pull/1111</span><br></pre></td></tr></table></figure></li><li><p>解决方法</p><ul><li>这是kubernetes的保护机制，防止外部随意创建crd，破坏环境</li><li>报错中已经给了提示，查看github：<a href="https://github.com/kubernetes/enhancements/pull/1111">https://github.com/kubernetes/enhancements/pull/1111</a></li><li>只需要在crd中，添加一条 annotation，然后再执行 kubectl apply -f 命令就可以了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    api-approved.kubernetes.io: &quot;https://github.com/kubernetes/kubernetes/pull/78458&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加之后，完整的 crd 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    controller-gen.kubebuilder.io/version: (devel)</span><br><span class="line">    api-approved.kubernetes.io: &quot;https://github.com/kubernetes/kubernetes/pull/78458&quot;</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: applications.appcontroller.k8s.io</span><br><span class="line">spec:</span><br><span class="line">  group: appcontroller.k8s.io</span><br><span class="line">  names:</span><br><span class="line">    kind: Application</span><br><span class="line">    listKind: ApplicationList</span><br><span class="line">    plural: applications</span><br><span class="line">    singular: application</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">  - name: v1alpha1</span><br><span class="line">    schema:</span><br><span class="line">      openAPIV3Schema:</span><br><span class="line">        description: Application is the Schema for the applications API</span><br><span class="line">        properties:</span><br><span class="line">          apiVersion:</span><br><span class="line">            description: &#x27;APIVersion defines the versioned schema of this representation</span><br><span class="line">              of an object. Servers should convert recognized schemas to the latest</span><br><span class="line">              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          kind:</span><br><span class="line">            description: &#x27;Kind is a string value representing the REST resource this</span><br><span class="line">              object represents. Servers may infer this from the endpoint the client</span><br><span class="line">              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds&#x27;</span><br><span class="line">            type: string</span><br><span class="line">          metadata:</span><br><span class="line">            type: object</span><br><span class="line">          spec:</span><br><span class="line">            description: ApplicationSpec defines the desired state of Application</span><br><span class="line">            properties:</span><br><span class="line">              name:</span><br><span class="line">                description: INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster</span><br><span class="line">                type: string</span><br><span class="line">              replicas:</span><br><span class="line">                format: int32</span><br><span class="line">                type: integer</span><br><span class="line">            required:</span><br><span class="line">            - name</span><br><span class="line">            - replicas</span><br><span class="line">            type: object</span><br><span class="line">          status:</span><br><span class="line">            description: ApplicationStatus defines the observed state of Application.</span><br><span class="line">              It should always be reconstructable from the state of the cluster and/or</span><br><span class="line">              outside world.</span><br><span class="line">            type: object</span><br><span class="line">        type: object</span><br><span class="line">    served: true</span><br><span class="line">    storage: true</span><br></pre></td></tr></table></figure></li></ul><h3 id="编写-crd-资源的-example"><a href="#编写-crd-资源的-example" class="headerlink" title="编写 crd 资源的 example"></a>编写 crd 资源的 example</h3><ul><li><p>在 config 目录下，创建一个example目录，内部可以编写一些 application资源的yaml，用于测试Application资源的创建是否可以成功</p></li><li><p>在config&#x2F;example目录下，编写一个test_app.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: appcontroller.k8s.io/v1alpha1</span><br><span class="line">kind: Application</span><br><span class="line">metadata:</span><br><span class="line">  name: testapp</span><br><span class="line">  namespace: tcs</span><br><span class="line">spec:</span><br><span class="line">  name: testapp1</span><br><span class="line">  replicas: 2</span><br></pre></td></tr></table></figure></li><li><p>创建Application资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools-demo</span><br><span class="line">kubectl apply -f ./config/example/test_app.yaml</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试Application资源的获取"><a href="#测试Application资源的获取" class="headerlink" title="测试Application资源的获取"></a>测试Application资源的获取</h2><ul><li><p>在项目根目录下，创建一个cmd目录，里面创建一个main.go文件</p></li><li><p>下面我们演示如何使用 code-generator 为 Application 的 v1alpha1 生成的客户端 AppcontrollerV1alpha1Client</p></li><li><p>编写main.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;controller-tools-demo/pkg/apis/appcontroller/v1alpha1&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line"></span><br><span class="line">&quot;k8s.io/client-go/kubernetes/scheme&quot;</span><br><span class="line"></span><br><span class="line">&quot;k8s.io/client-go/rest&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config.APIPath = &quot;/apis/&quot;</span><br><span class="line">config.GroupVersion = &amp;v1alpha1.SchemeGroupVersion</span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs</span><br><span class="line"></span><br><span class="line">client, err := rest.RESTClientFor(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app := v1alpha1.Application&#123;&#125;</span><br><span class="line">err = client.Get().Namespace(&quot;tcs&quot;).Resource(&quot;applications&quot;).Name(&quot;testapp&quot;).Do(context.TODO()).Into(&amp;app)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newObj := app.DeepCopy()</span><br><span class="line">newObj.Spec.Name = &quot;testapp2&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(app.Spec.Name)</span><br><span class="line">fmt.Println(app.Spec.Replicas)</span><br><span class="line"></span><br><span class="line">fmt.Println(newObj.Spec.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master controller-tools-demo]# go run cmd/main.go</span><br><span class="line">testapp1</span><br><span class="line">2</span><br><span class="line">testapp2</span><br></pre></td></tr></table></figure><p>  如果没有在kubernetes集群中 应用 CRD资源，直接执行上面的代码，会报错：找不到这个资源。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run cmd/main.go</span><br><span class="line">2024/01/31 16:01:17 the server could not find the requested resource (get applications.appcontroller.k8s.io test_app)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator开发之controller-tools篇</title>
      <link href="/posts/4a17d0010.html"/>
      <url>/posts/4a17d0010.html</url>
      
        <content type="html"><![CDATA[<h2 id="controller-tools-简介"><a href="#controller-tools-简介" class="headerlink" title="controller-tools 简介"></a>controller-tools 简介</h2><h3 id="code-generator自动生成代码存在的问题"><a href="#code-generator自动生成代码存在的问题" class="headerlink" title="code-generator自动生成代码存在的问题"></a>code-generator自动生成代码存在的问题</h3><p>在operator之code-generator 篇中，code-generator编写CRD控制器有两个问题：</p><ul><li>问题一：需要手动编写CRD的yaml，无法自动生成</li><li>问题二：types.go文件全部内容都需要我们手写，无法自动生成框架<br>这部分工作量其实也是挺大的，kubernetes提供了一个工具 controller-tools，可以对这部分内容也进行代码自动生成</li></ul><h3 id="controller-tools是什么"><a href="#controller-tools是什么" class="headerlink" title="controller-tools是什么"></a>controller-tools是什么</h3><p>1、kubernetes-sigs 项目是什么</p><ul><li>kubernetes-sigs 是一个由 Kubernetes 社区维护的 GitHub 组织，其中包含了许多与 Kubernetes 相关的项目，这些项目通常是为 Kubernetes 生态系统开发的，用于提供各种功能和工具。</li><li>一些 kubernetes-sigs 组织中的流行项目包括：<ul><li>kustomize：一种用于 Kubernetes 部署的配置管理工具，可以通过 YAML 声明文件对 Kubernetes 对象进行自定义，并且支持多环境部署（例如 dev、stage、prod）。</li><li>kubebuilder：一种用于构建 Kubernetes API 的 SDK 工具，可以帮助开发者快速构建和测试 Kubernetes 的自定义控制器。</li><li>cluster-api：一种 Kubernetes 的 API 扩展，用于管理 Kubernetes 集群的生命周期，包括创建、扩容和删除。它允许开发者使用 Kubernetes 的声明性 API 来管理整个集群的生命周期。</li><li>kubefed：用于跨 Kubernetes 集群联邦的控制平面。它提供了一种将多个 Kubernetes 集群组合成一个统一的逻辑实体的方法，同时保持每个集群的独立性。</li><li>controller-tools：用于简化 Kubernetes 控制器的开发，提供了一组工具来生成和更新 Kubernetes API 对象的代码，以及构建自定义控制器所需的代码框架。</li></ul></li></ul><p>2、controller-tools是什么</p><p>controller-tools其实是一个由 Kubernetes 社区维护的项目，用于简化 Kubernetes 控制器的开发。其中提供了一组工具来生成和更新 Kubernetes API 对象的代码，以及构建自定义控制器所需的代码框架。<br>controller-tools 的github地址：<a href="https://github.com/kubernetes-sigs/controller-tools">https://github.com/kubernetes-sigs/controller-tools</a></p><p>3、controller-tools 包含哪些工具</p><p>在controller-tools源码的cmd目录下，可以看到包含三个工具</p><ul><li>controller-gen：用于生成 zz_xxx.deepcopy.go 文件以及 crd 文件【kubebuilder也是通过这个工具生成crd的相关框架的】</li><li>type-scaffold：用于生成所需的 types.go 文件</li><li>helpgen：用于生成针对 Kubernetes API 对象的代码文档，可以包括 API 对象的字段、标签和注释等信息</li></ul><h2 id="controller-tools-使用过程"><a href="#controller-tools-使用过程" class="headerlink" title="controller-tools 使用过程"></a>controller-tools 使用过程</h2><h3 id="controller-tools-的-安装"><a href="#controller-tools-的-安装" class="headerlink" title="controller-tools 的 安装"></a>controller-tools 的 安装</h3><ul><li><p>controller-tools 的 github 地址：<a href="https://github.com/kubernetes-sigs/controller-tools.git%EF%BC%8C%E5%85%8B%E9%9A%86%E4%BB%A3%E7%A0%81">https://github.com/kubernetes-sigs/controller-tools.git，克隆代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes-sigs/controller-tools.git</span><br></pre></td></tr></table></figure></li><li><p>将分支切换到 v0.9.0 的tag上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v0.9.0</span><br></pre></td></tr></table></figure></li><li><p>编译项目，安装代码生成工具，这里我们只安装需要的2个工具</p><ul><li>controller-gen工具：生成 deepcopy方法 文件 + crd 文件</li><li>type-scaffold工具：生成 types.go 文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd controller-tools</span><br><span class="line"># linux下安装，执行这一条即可</span><br><span class="line">go install ./cmd/&#123;controller-gen,type-scaffold&#125;</span><br><span class="line"></span><br><span class="line"># windows下安装，需要执行两条命令</span><br><span class="line">go install ./cmd/controller-gen</span><br><span class="line">go install ./cmd/type-scaffold</span><br></pre></td></tr></table></figure></li></ul></li><li><p>打开终端，执行 type-scaffold –help，如果报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master zgy]# type-scaffold --help</span><br><span class="line">-bash: type-scaffold: 未找到命令</span><br></pre></td></tr></table></figure></li><li><p>说明环境变量没有设置成功，需要将 gopath&#x2F;bin 加入PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"># 在~/.bashrc文件的末尾，加上这么一句</span><br><span class="line">export PATH=&quot;$PATH:$GOPATH/bin&quot;</span><br><span class="line"># 然后，source一下</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>再执行 type-scaffold –help，就成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@master zgy]# type-scaffold --help</span><br><span class="line">Quickly scaffold out the structure of a type for a Kubernetes kind and associated types.</span><br><span class="line">Produces:</span><br><span class="line"></span><br><span class="line">- a root type with appropriate metadata fields</span><br><span class="line">- Spec and Status types</span><br><span class="line">- a list type</span><br><span class="line"></span><br><span class="line">Also applies the appropriate comments to generate the code required to conform to runtime.Object.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  type-scaffold [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">        # Generate types for a Kind called Foo with a resource called foos</span><br><span class="line">                type-scaffold --kind Foo</span><br><span class="line"></span><br><span class="line">        # Generate types for a Kind called Bar with a resource of foobars</span><br><span class="line">        type-scaffold --kind Bar --resource foobars</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help              help for type-scaffold</span><br><span class="line">      --kind string       The kind of the typescaffold being scaffolded.</span><br><span class="line">      --namespaced        Whether or not the given resource is namespaced. (default true)</span><br><span class="line">      --resource string   The resource of the typescaffold being scaffolded (defaults to a lower-case, plural version of kind).</span><br></pre></td></tr></table></figure></li></ul><h3 id="type-scaffold-的使用方法"><a href="#type-scaffold-的使用方法" class="headerlink" title="type-scaffold 的使用方法"></a>type-scaffold 的使用方法</h3><ul><li><p>type-scaffold 常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type-scaffold --kind &lt;Kind&gt; [flags]</span><br><span class="line">type-scaffold --help</span><br></pre></td></tr></table></figure></li><li><p>–kind：参数用于指定要创建的资源类型（例如 Application）</p></li></ul><h3 id="controller-gen-的使用方法"><a href="#controller-gen-的使用方法" class="headerlink" title="controller-gen 的使用方法"></a>controller-gen 的使用方法</h3><ul><li>controller-gen 常用命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成 CRD 文件，并将生成的文件输出到 config/crds 目录中</span><br><span class="line">controller-gen crd paths=./... output:crd:dir=config/crds</span><br><span class="line"># 生成与对象相关的代码，通常是指生成控制器相关的代码模板</span><br><span class="line">controller-gen object paths=./...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code-generator实战：为CRD生成代码</title>
      <link href="/posts/4a17d0009.html"/>
      <url>/posts/4a17d0009.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化go项目"><a href="#初始化go项目" class="headerlink" title="初始化go项目"></a>初始化go项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建并进入项目目录</span><br><span class="line">mkdir code-generator-demo &amp;&amp; cd code-generator-demo</span><br><span class="line"></span><br><span class="line"># 初始化项目</span><br><span class="line">go mod init code-generator-demo</span><br><span class="line"></span><br><span class="line"># 获取依赖</span><br><span class="line">go get k8s.io/apimachinery@v0.0.0-20190425132440-17f84483f500</span><br><span class="line">go get k8s.io/client-go@v0.0.0-20190425172711-65184652c889</span><br><span class="line">go get k8s.io/code-generator@v0.0.0-20190419212335-ff26e7842f9d</span><br></pre></td></tr></table></figure><h2 id="编写doc-go"><a href="#编写doc-go" class="headerlink" title="编写doc.go"></a>编写doc.go</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +k8s:deepcopy-gen=package</span><br><span class="line">// +groupName=appcontroller.k8s.io</span><br><span class="line"></span><br><span class="line">// Package v1alpha1 v1alpha1版本的api包</span><br><span class="line">package v1alpha1</span><br></pre></td></tr></table></figure><h2 id="编写types-go"><a href="#编写types-go" class="headerlink" title="编写types.go"></a>编写types.go</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line"></span><br><span class="line">// +genclient</span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">type Application struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">Spec   ApplicationSpec   `json:&quot;spec&quot;`</span><br><span class="line">Status ApplicationStatus `json:&quot;status&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ApplicationSpec struct &#123;</span><br><span class="line">DeploymentName string `json:&quot;deploymentName&quot;`</span><br><span class="line">Replicas       *int32 `json:&quot;replicas&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ApplicationStatus struct &#123;</span><br><span class="line">AvailableReplicas int32 `json:&quot;availableReplicas&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">type ApplicationList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata&quot;`</span><br><span class="line"></span><br><span class="line">Items []Application `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写register-go"><a href="#编写register-go" class="headerlink" title="编写register.go"></a>编写register.go</h2><ul><li>注意，这是appcontroller目录下的register.go，并非某个版本目录下的，版本目录下的，再使用 code-generator 脚本后，再进行编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package appcontroller</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">GroupName = &quot;appcontroller.k8s.io&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写boilerplate-go-txt"><a href="#编写boilerplate-go-txt" class="headerlink" title="编写boilerplate.go.txt"></a>编写boilerplate.go.txt</h2><ul><li>该文件是文件开头统一的注释，会在使用 code-generator 脚本时，指定 boilerplate.go.txt 文件的所在目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Copyright 2019 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line"></span><br><span class="line">@Time : 2024/1</span><br><span class="line">@Author : grahamzhu</span><br><span class="line">@Software: GoLand</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写tools-go"><a href="#编写tools-go" class="headerlink" title="编写tools.go"></a>编写tools.go</h2><ul><li>我们要使用 code-generator，可代码中还没有任何位置 导入过 code-generator 的包，所以我们需要一个类，专门用于将 code-generator 的包导入。一般使用tools.go来做这件事<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//go:build tools</span><br><span class="line">// +build tools</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Copyright 2019 The Kubernetes Authors.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// This package imports things required by build scripts, to force `go mod` to see them as dependencies</span><br><span class="line">package tools</span><br><span class="line"></span><br><span class="line">import _ &quot;k8s.io/code-generator&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写使用code-generator的脚本update-codegen-sh"><a href="#编写使用code-generator的脚本update-codegen-sh" class="headerlink" title="编写使用code-generator的脚本update-codegen.sh"></a>编写使用code-generator的脚本update-codegen.sh</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line"># Copyright 2017 The Kubernetes Authors.</span><br><span class="line">#</span><br><span class="line"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"># you may not use this file except in compliance with the License.</span><br><span class="line"># You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># 设置脚本在执行过程中遇到任何错误时立即退出</span><br><span class="line">set -o errexit</span><br><span class="line"># 设置脚本在使用未定义的变量时立即退出</span><br><span class="line">set -o nounset</span><br><span class="line"># 设置脚本在管道命令中任意一条命令失败时立即退出</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line"># 对generate-groups.sh 脚本的调用</span><br><span class="line">../vendor/k8s.io/code-generator/generate-groups.sh \</span><br><span class="line">  &quot;deepcopy,client,informer,lister&quot; \</span><br><span class="line">  code-generator-demo/pkg/generated \</span><br><span class="line">  code-generator-demo/pkg/apis \</span><br><span class="line">  appcontroller:v1alpha1 \</span><br><span class="line">  --go-header-file $(pwd)/boilerplate.go.txt \</span><br><span class="line">  --output-base $(pwd)/../../</span><br></pre></td></tr></table></figure><p>解释每个参数和选项的含义：</p><ul><li>“deepcopy,client,informer,lister”：指定要生成的代码类型，这里包括深拷贝方法、客户端、informer 和 lister。</li><li>code-generator-demo&#x2F;pkg&#x2F;generated：指定生成的代码的输出目录。</li><li>code-generator-demo&#x2F;pkg&#x2F;apis：指定包含 API 定义的目录。</li><li>appcontroller:v1alpha1：指定要生成的 API 版本和组。</li><li>–go-header-file $(pwd)&#x2F;boilerplate.go.txt：指定用于生成的代码文件头部的文本文件，这里使用了当前目录下的 boilerplate.go.txt 文件。</li><li>–output-base $(pwd)&#x2F;..&#x2F;..&#x2F;：指定生成的代码的基础目录，即输出目录的上一级目录。</li></ul><p>总结起来，该命令的作用是调用 Kubernetes 代码生成器脚本，根据指定的 API 定义和选项生成深拷贝方法、客户端、informer 和 lister 等代码，并将生成的代码输出到指定的目录中。</p><h2 id="执行脚本生成代码"><a href="#执行脚本生成代码" class="headerlink" title="执行脚本生成代码"></a>执行脚本生成代码</h2><ul><li>将代码上传至linux环境下，依次执行如下命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"># 生成vendor文件夹</span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line"># 为vendor中的code-generator赋予权限</span><br><span class="line">chmod -R 777 vendor</span><br><span class="line"></span><br><span class="line"># 为hack中的update-codegen.sh脚本赋予权限</span><br><span class="line">chmod -R 777 hack</span><br><span class="line"></span><br><span class="line"># 调用脚本生成代码</span><br><span class="line">$ cd hack &amp;&amp; ./update-codegen.sh</span><br><span class="line">Generating deepcopy funcs</span><br><span class="line">Generating clientset for appcontroller:v1alpha1 at code-generator-demo/pkg/generated/clientset</span><br><span class="line">Generating listers for appcontroller:v1alpha1 at code-generator-demo/pkg/generated/listers</span><br><span class="line">Generating informers for appcontroller:v1alpha1 at code-generator-demo/pkg/generated/informers</span><br><span class="line"></span><br><span class="line">#此时目录变为如下情况</span><br><span class="line">$ cd ../ &amp;&amp; tree -L 5</span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   ├── boilerplate.go.txt</span><br><span class="line">│   ├── tools.go</span><br><span class="line">│   └── update-codegen.sh</span><br><span class="line">├── pkg</span><br><span class="line">│   ├── apis</span><br><span class="line">│   │   └── appcontroller</span><br><span class="line">│   │       ├── register.go</span><br><span class="line">│   │       └── v1alpha1</span><br><span class="line">│   │           ├── doc.go</span><br><span class="line">│   │           ├── types.go</span><br><span class="line">│   │           └── zz_generated.deepcopy.go</span><br><span class="line">│   └── generated</span><br><span class="line">│       ├── clientset</span><br><span class="line">│       │   └── versioned</span><br><span class="line">│       │       ├── clientset.go</span><br><span class="line">│       │       ├── doc.go</span><br><span class="line">│       │       ├── fake</span><br><span class="line">│       │       ├── scheme</span><br><span class="line">│       │       └── typed</span><br><span class="line">│       ├── informers</span><br><span class="line">│       │   └── externalversions</span><br><span class="line">│       │       ├── appcontroller</span><br><span class="line">│       │       ├── factory.go</span><br><span class="line">│       │       ├── generic.go</span><br><span class="line">│       │       └── internalinterfaces</span><br><span class="line">│       └── listers</span><br><span class="line">│           └── appcontroller</span><br><span class="line">│               └── v1alpha1</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="手动注册版本v1alpha1的CRD资源"><a href="#手动注册版本v1alpha1的CRD资源" class="headerlink" title="手动注册版本v1alpha1的CRD资源"></a>手动注册版本v1alpha1的CRD资源</h2><ul><li>在生成了客户端代码后，我们还需要手动注册版本v1alpha1的CRD资源，才能真正使用这个client，不然在编译时会出现 undefined: v1alpha1.AddToScheme 错误、undefined: v1alpha1.Resource 错误。</li><li>v1alpha1.AddToScheme、v1alpha1.Resource 这两个是用于 client 注册的</li><li>编写 v1alpha1&#x2F;register.go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;code-generator-demo/pkg/apis/appcontroller&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// SchemeGroupVersion is group version used to register these objects</span><br><span class="line">var SchemeGroupVersion = schema.GroupVersion&#123;Group: appcontroller.GroupName, Version: &quot;v1alpha1&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Kind takes an unqualified kind and returns back a Group qualified GroupKind</span><br><span class="line">func Kind(kind string) schema.GroupKind &#123;</span><br><span class="line">return SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span><br><span class="line">func Resource(resource string) schema.GroupResource &#123;</span><br><span class="line">return SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// SchemeBuilder initializes a scheme builder</span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Adds the list of known types to Scheme.</span><br><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Application&#123;&#125;,</span><br><span class="line">&amp;ApplicationList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试CRD资源的使用"><a href="#测试CRD资源的使用" class="headerlink" title="测试CRD资源的使用"></a>测试CRD资源的使用</h2><ul><li>在项目根目录下，创建一个cmd目录，里面创建一个main.go文件</li><li>下面我们演示如何使用 code-generator 为 Application 的 v1alpha1 生成的客户端 AppcontrollerV1alpha1Client</li><li>编写main.go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;code-generator-demo/pkg/generated/clientset/versioned/typed/appcontroller/v1alpha1&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 pkg/generated/clientset/versioned/typed/appcontroller/v1alpha1/appcontroller_client.go 中</span><br><span class="line">// 自动生成的 AppcontrollerV1alpha1Client，用于操作这种GVR</span><br><span class="line">appClient, err := v1alpha1.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取default命名空间下的所有Application</span><br><span class="line">appList, err := appClient.Applications(&quot;default&quot;).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, app := range appList.Items &#123;</span><br><span class="line">fmt.Println(app.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operator开发之code-generator篇</title>
      <link href="/posts/4a17d0008.html"/>
      <url>/posts/4a17d0008.html</url>
      
        <content type="html"><![CDATA[<h2 id="code-generator-简介"><a href="#code-generator-简介" class="headerlink" title="code-generator 简介"></a>code-generator 简介</h2><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li>在 client-go篇 文章中，我们详细讲述了 如何使用 RESTClient、ClientSet 操作kubernetes的内建资源。然而，对于CRD资源，我们只能使用 DynamicClient 这种通用的Client去操作。</li><li>DynamicClient 是为操作所有资源而编写的通用Client，自然没有 某种资源 对应的Informer、Lister代码，所以使用DynamicClient，就无法像 使用ClientSet 那样，操作某一个特定资源的Informer、Lister等。</li><li>为此我们想，能否为 CRD资源 生成和内建资源一样的Informer、Lister代码，这样的话，开发控制器的时候，我们就可以像使用内建资源一样，为CRD的informer注册事件方法，并使用Lister从缓存中获取数据。</li></ul><h3 id="code-generator是什么"><a href="#code-generator是什么" class="headerlink" title="code-generator是什么"></a>code-generator是什么</h3><ul><li><p>kubernetes的开发中，有很多代码是相似而重复的，开发起来耗时耗力，因此就希望制作成了自动化工具，提高代码的可维护性和一致性。code-generator应运而生。</p></li><li><p>code-generator 是一个 代码生成工具集合，内部包含很多gen工具，用于自动生成与 Kubernetes 相关的客户端库、API 服务器（API server）和其他与 Kubernetes 相关的代码。</p></li><li><p>code-generator 位于 Kubernetes 代码库中的 staging&#x2F;src&#x2F;k8s.io&#x2F;code-generator 包中，github地址为：<a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a></p></li><li><p>code-generator 的主要功能包括：</p><ul><li>自动生成客户端库clientset：通过定义自定义资源的 API 规范，code-generator 可以自动生成用于访问和操作这些自定义资源的客户端库。</li><li>自动生成 API 服务器代码：code-generator 可以根据自定义资源的 API 规范，自动生成与之对应的 API 服务器代码。这使得开发者可以快速构建自己的自定义资源的 API 服务器，并将其部署到 Kubernetes 集群中。</li><li>自动生成 DeepCopy 方法：对于 Kubernetes 对象，深拷贝是一种常见的操作，用于创建对象的副本。</li><li>自动生成其他辅助代码：除了上述功能外，code-generator 还可以生成其他与 Kubernetes 相关的辅助代码，如列表（List）、转换器（Converter）等。</li></ul></li></ul><h3 id="code-generator的常见应用场景"><a href="#code-generator的常见应用场景" class="headerlink" title="code-generator的常见应用场景"></a>code-generator的常见应用场景</h3><ul><li>为CRD编写自定义controller时，可以使用它来生成我们需要的versioned client、informer、lister以及其他工具方法</li><li>编写自定义API Server时，可以用它来生成 internal 和 versioned类型的转换defaulters、internal 和 versioned的clients和informers</li></ul><h2 id="code-generator-的使用方法"><a href="#code-generator-的使用方法" class="headerlink" title="code-generator 的使用方法"></a>code-generator 的使用方法</h2><ul><li>code-generator是使用注释标记工作的，不同的gen工具，有不同的注释标记</li></ul><h3 id="code-generator-常用的gen工具"><a href="#code-generator-常用的gen工具" class="headerlink" title="code-generator 常用的gen工具"></a>code-generator 常用的gen工具</h3><ul><li>deepcopy-gen：为每个 T 类型生成 func (t* T) DeepCopy() *T 方法，API 类型都需要实现深拷贝</li><li>client-gen：生成类型化客户端集合(typed client sets)，即与 Kubernetes API 服务器通信的客户端代码。</li><li>informer-gen：用于生成基于 Kubernetes API 资源的 Informer，提供事件机制来响应资源的事件，方便开发者执行资源监视操作。</li><li>lister-gen：用于生成 Kubernetes API 资源的 Lister，为 get 和 list 请求提供只读缓存层（通过 indexer 获取），可以实现高效的资源列表查询。</li><li>register-gen：自动生成 API 资源类型的注册表代码</li><li>conversion-gen：用于生成 Kubernetes 对象之间的转换器（Converter），方便在不同版本之间进行对象转换。</li><li>openapi-gen：用于生成 Kubernetes API 的 OpenAPI 规范，以便进行文档化和验证。</li></ul><h3 id="code-generator标记Tag"><a href="#code-generator标记Tag" class="headerlink" title="code-generator标记Tag"></a>code-generator标记Tag</h3><p>1、tag分类</p><ul><li>code-generator 将 tag 分为了两种：<ul><li>Global tags: 全局的tag，放在具体版本的doc.go文件中</li><li>Local tags: 本地的tag，放在types.go文件中的具体的struct上</li></ul></li></ul><p>2、tag使用语法</p><ul><li>使用语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// +tag-name </span><br><span class="line">或</span><br><span class="line">// +tag-name=value</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="deepcopy-gen的常用标记"><a href="#deepcopy-gen的常用标记" class="headerlink" title="deepcopy-gen的常用标记"></a>deepcopy-gen的常用标记</h3><ul><li><p>在要生成 client 代码的类型type上方使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">告诉代码生成器不生成该对象的深拷贝方法</span><br><span class="line">// +k8s:deepcopy-gen=false</span><br><span class="line"></span><br><span class="line">告诉代码生成器生成该对象的深拷贝方法</span><br><span class="line">// +k8s:deepcopy-gen=true</span><br><span class="line"></span><br><span class="line">指定生成的代码中实现的接口，这里指定了实现 k8s.io/apimachinery/pkg/runtime.Object 接口的代码</span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br></pre></td></tr></table></figure></li><li><p>在doc.go文件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">告诉代码生成器生成整个包的对象深拷贝方法。这意味着生成的代码将包含用于深拷贝包中所有对象的相关代码</span><br><span class="line">// +k8s:deepcopy-gen=package</span><br><span class="line"></span><br><span class="line">指定自定义 API 组的名称。这个注释用于定义自定义 API 资源的 API 组，使其能够与其他资源进行区分</span><br><span class="line">// +groupName=foo.example.com</span><br><span class="line"></span><br><span class="line">package v1</span><br></pre></td></tr></table></figure></li></ul><h3 id="client-gen的常用标记"><a href="#client-gen的常用标记" class="headerlink" title="client-gen的常用标记"></a>client-gen的常用标记</h3><ul><li>在要生成 client 代码的类型type上方使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">指示代码生成器生成用于客户端库的代码</span><br><span class="line">// +genclient</span><br><span class="line"></span><br><span class="line">不要为自定义资源生成状态字段相关的代码</span><br><span class="line">// +genclient:noStatus</span><br><span class="line"> </span><br><span class="line">表示这是一个集群级别的资源</span><br><span class="line">// +genclient:nonNamespaced</span><br><span class="line"></span><br><span class="line">不要生成默认的 HTTP 动词（verbs）相关的代码，这可能是因为该资源的操作方式与常规的 RESTful 操作并不完全相同</span><br><span class="line">// +genclient:noVerbs</span><br><span class="line"></span><br><span class="line">指示代码生成器只生成用于创建和删除操作的代码</span><br><span class="line">// +genclient:onlyVerbs=create,delete</span><br><span class="line"></span><br><span class="line">告诉代码生成器跳过指定的动词相关的代码生成，这表明生成的客户端库将不包含与这些操作相关的代码</span><br><span class="line">// +genclient:skipVerbs=get,list,create,update,patch,delete,deleteCollection,watch</span><br><span class="line"></span><br><span class="line">为特定的方法指定生成代码的细节，这里指定了当执行创建操作时所使用的方法以及其返回结果</span><br><span class="line">// +genclient:method=Create,verb=create,result=k8s.io/apimachinery/pkg/apis/meta/v1.Status</span><br></pre></td></tr></table></figure></li></ul><h3 id="informer-gen的常用标记"><a href="#informer-gen的常用标记" class="headerlink" title="informer-gen的常用标记"></a>informer-gen的常用标记</h3><ul><li>在要生成 client 代码的类型type上方使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用informer-gen必须要写这一行</span><br><span class="line">// +k8s:informers</span><br><span class="line"></span><br><span class="line">指定生成的 Informer 代码对应的 API 组和版本</span><br><span class="line">// +k8s:informers:groupVersion=$&#123;group&#125;/$&#123;version&#125;</span><br><span class="line"></span><br><span class="line">指定生成的 Informer 代码对应的内部 API 版本</span><br><span class="line">// +k8s:informers:internalVersion=internal/version</span><br><span class="line"></span><br><span class="line">指定生成的 Informer 代码是否需要为版本化的客户端集（Versioned ClientSet）生成代码</span><br><span class="line">// +k8s:informers:versionedClientSet=false</span><br><span class="line"></span><br><span class="line">指定生成的 Informer 代码是否需要使用缓存</span><br><span class="line">// +k8s:informers:cache</span><br></pre></td></tr></table></figure></li></ul><h3 id="code-generator的运行脚本"><a href="#code-generator的运行脚本" class="headerlink" title="code-generator的运行脚本"></a>code-generator的运行脚本</h3><ul><li>手动使用code-generator中某个gen工具，存在很多重复参数，也比较繁琐</li><li>因此 code-generator 为我们提供了 两个脚本：generate-groups.sh 和 generate-internal-groups.sh</li><li>在kubernetes 1.28 alpha 之后。提供了表述更清晰更好维护的脚本 kube_codegen.sh</li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operator开发之CRD篇</title>
      <link href="/posts/4a17d0007.html"/>
      <url>/posts/4a17d0007.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在K8S系统扩展点中，开发者可以通过CRD（CustomResourceDefinition）来扩展K8S API，其功能主要由APIExtensionServer负责。使用CRD扩展资源分为三步：</p><ul><li>注册自定义资源：开发者需要通过K8S提供的方式注册自定义资源，即通过CRD进行注册，注册之后，K8S就知道我们自定义资源的存在了，然后我们就可以像使用K8S内置资源一样使用自定义资源（CR）</li><li>使用自定义资源：像内置资源比如Pod一样声明资源，使用CR声明我们的资源信息</li><li>删除自定义资源：当我们不再需要时，可以删除自定义资源</li></ul><h2 id="如何注册自定义资源"><a href="#如何注册自定义资源" class="headerlink" title="如何注册自定义资源"></a>如何注册自定义资源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  # 强制规定：名字必须与下面的 spec 字段匹配，并且格式为 &#x27;&lt;名称的复数形式&gt;.&lt;组名&gt;&#x27;</span><br><span class="line">  name: demos.example.com</span><br><span class="line">spec:</span><br><span class="line">  # 组名称，用于 REST API: /apis/&lt;组&gt;/&lt;版本&gt;</span><br><span class="line">  group: example.com</span><br><span class="line">  names:</span><br><span class="line">    # 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;</span><br><span class="line">    plural: demos</span><br><span class="line">    # 名称的单数形式，作为命令行使用时和显示时的别名</span><br><span class="line">    singular: demo</span><br><span class="line">    # kind 通常是单数形式的帕斯卡编码（PascalCased）形式。你的资源清单会使用这一形式。</span><br><span class="line">    kind: Demo</span><br><span class="line">    # shortNames 允许你在命令行使用较短的字符串来匹配资源</span><br><span class="line">    shortNames:</span><br><span class="line">    - dm</span><br><span class="line">  # 可以是 Namespaced命名空间范围内使用 或 Cluster集群范围内使用</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  # 列举此 CustomResourceDefinition 所支持的版本，可以在不破坏现有客户端的情况下，对CRD定义的资源进行演进和升级</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1</span><br><span class="line">      # 每个版本都可以通过 served 标志来独立启用或禁止，指示该版本的资源是否应该由API服务器提供服务</span><br><span class="line">      served: true</span><br><span class="line">      # 其中一个且只有一个版本必需被标记为存储版本（指示该版本的资源是否应该存储在etcd中）</span><br><span class="line">      storage: true</span><br><span class="line">      # 一个OpenAPI v3模式对象，用于定义该版本的资源的结构。该模式对象描述了该版本的资源的属性、类型和验证规则等信息</span><br><span class="line">      schema:</span><br><span class="line">        openAPIV3Schema:</span><br><span class="line">          type: object</span><br><span class="line">          properties:</span><br><span class="line">            spec:</span><br><span class="line">              type: object</span><br><span class="line">              properties:</span><br><span class="line">                name:</span><br><span class="line">                  type: string</span><br></pre></td></tr></table></figure><h2 id="使用自定义资源"><a href="#使用自定义资源" class="headerlink" title="使用自定义资源"></a>使用自定义资源</h2><ul><li><p>待CRD创建完成之后，我们就可以使用它来创建我们的自定义资源了</p></li><li><p>其创建方式跟内置的资源如Pod这些是一样的，只是需要将kind、apiVersion指定为我们CRD中声明的值</p></li><li><p>比如使用上面例子中的CRD定义资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: &quot;demos.example.com/v1&quot;</span><br><span class="line">kind: Demo</span><br><span class="line">metadata:</span><br><span class="line">  name: crd-demo</span><br><span class="line">spec:</span><br><span class="line">  name: test</span><br></pre></td></tr></table></figure></li></ul><h2 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h2><ul><li><p>Finalizer 能够让控制器实现 异步 的删除前（Pre-delete）回调，优雅的删除 资源</p><ul><li>我们创建的自定义资源对象，finalizers不为空，那么在资源对象被删除之前，会阻塞住，同时往这个资源中添加一个字段：</li><li>我们的自定义Controller检测到deletionTimestamp后，就知道资源即将被删除，进行一些回收操作，结束后清空资源的finalizers值，删除操作就会被唤醒，自定义资源对象才会被删除</li></ul></li><li><p>与内置对象类似，定制对象也支持 Finalizer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: &quot;example.com/v1&quot;</span><br><span class="line">kind: Demo</span><br><span class="line">metadata:</span><br><span class="line">  finalizers:</span><br><span class="line">  - example.com/finalizer</span><br></pre></td></tr></table></figure></li></ul><h2 id="合法性验证"><a href="#合法性验证" class="headerlink" title="合法性验证"></a>合法性验证</h2><ul><li>比如：我们指定 自定义资源CR的 name，必须以test开头</li><li>那么如果创建一个name不以test开头的CR，就会报错</li></ul><h2 id="附加字段"><a href="#附加字段" class="headerlink" title="附加字段"></a>附加字段</h2><ul><li><p>在kubectl get cr的时候，打印的字段值。默认只打印：.metadata.name、age</p></li><li><p>其实还可以添加额外字段，打印别的信息，设置的是 spec.versions.additionalPrinterColumns</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">versions:</span><br><span class="line">  additionalPrinterColumns:</span><br><span class="line">  - name: Name</span><br><span class="line">    type: string</span><br><span class="line">    description: The name of resource</span><br><span class="line">    jsonPath: .spec.name</span><br></pre></td></tr></table></figure></li><li><p>如：我想把.spec.name打印出来，就添加一个additionalPrinterColumns项</p></li></ul><h2 id="子资源"><a href="#子资源" class="headerlink" title="子资源"></a>子资源</h2><ul><li>默认情况下，自定义资源，输出yaml的时候，没有status，不可以被kubectl scale 命令操作，也无法被HPA等控制器自动伸缩</li><li>kubernetes 的 CRD，提供了对status和scale子资源的支持<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  versions:</span><br><span class="line">    subresources:</span><br><span class="line">      # status 加上这句，就是启用了 status 子资源，获取的yaml中就会输出status了。而且url访问也可以使用/.../status</span><br><span class="line">      status: &#123;&#125;</span><br><span class="line">      # scale 启用 scale 子资源，可以使用kubectl scale 命令伸缩，也可以被HPA等控制器自动伸缩</span><br><span class="line">      scale:</span><br><span class="line">        # specReplicasPath 定义定制资源中对应 scale.spec.replicas 的 JSON 路径</span><br><span class="line">        specReplicasPath: .spec.replicas</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><ul><li>使用default，可以给某些字段，设置默认值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">versions:</span><br><span class="line">- schema:</span><br><span class="line">    openAPIV3Schema:</span><br><span class="line">      type: Object</span><br><span class="line">      properties:</span><br><span class="line">        spec:</span><br><span class="line">          type: Object</span><br><span class="line">          properties:</span><br><span class="line">            name:</span><br><span class="line">      type: string</span><br><span class="line">      default: &quot;demo&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><ul><li>version是一个数组，可以定义多个<ul><li>一般我们会先有一个alpha版本，然后一个beta版本，然后再是v1…</li><li>Webhook实现不同版本之间的值的转换<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  versions:</span><br><span class="line">  ...</span><br><span class="line">  conversion:</span><br><span class="line">    strategy: Webhook</span><br><span class="line">    webhook:</span><br><span class="line">      conversionReviewVersions: [&quot;v1&quot;,&quot;v1beta1&quot;]</span><br><span class="line">      clientConfig:</span><br><span class="line">        service:</span><br><span class="line">          namespace: default</span><br><span class="line">          name: example-conversion-webhook-server</span><br><span class="line">          path: /crdconvert</span><br><span class="line">        caBundle: &quot;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="删除自定义资源"><a href="#删除自定义资源" class="headerlink" title="删除自定义资源"></a>删除自定义资源</h2><p>当我们不再需要时，可以像删除其他资源一样，删除我们的自定义资源。</p>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>client-go开发自定义控制器</title>
      <link href="/posts/4a17d0006.html"/>
      <url>/posts/4a17d0006.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><ul><li>我们希望实现这个效果：<ul><li>创建或更新Service的时候，如果这个Service的Annotations中，包含了”ingress&#x2F;http:true”，那么在创建或更新这个Service的时候，会自动为它创建一个Ingress。</li><li>删除Service的时候，如果这个Service的Annotations中，包含了”ingress&#x2F;http:true”，那么同时也要删除它的 Ingress。</li></ul></li></ul><h2 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a>需求分析：</h2><p>这个效果需要编写三个事件处理方法，addService、updateService、deleteIngress</p><ul><li>addService&#x2F;updateService：用户创建或更新service的时候，kubernetes的ServiceController已经完成service的创建或更新了。我们要做的是拿到已存在的service对象，看是否包含 “ingress&#x2F;http:true”。如果包含，则保证有一个对应的ingress；如果不包含，则保证不能有对应的ingress</li><li>deleteIngress：用于删除ingress的时候，也触发addService&#x2F;updateService一样的逻辑，保证service和ingress的对应关系是正确的。</li><li>可能会疑问，为什么没有 deleteService？<ul><li>因为我们会使用 OwnerReferences 将service+ingress关联起来。因此删除service，会由kubernetes的ControllerManager中的特殊Controller，自动完成ingress的gc，所以删除service时我们无需特殊处理。</li></ul></li></ul><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>main.go 代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;k8s.io/client-go/informers&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">&quot;k8s.io/client-go/rest&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;share-code-operator-study/addingress/pkg&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个 集群客户端配置</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">inClusterConfig, err := rest.InClusterConfig()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(&quot;can&#x27;t get config&quot;)</span><br><span class="line">&#125;</span><br><span class="line">config = inClusterConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个 clientset 客户端，用于创建 informerFactory</span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个 informerFactory</span><br><span class="line">factory := informers.NewSharedInformerFactory(clientset, 0)</span><br><span class="line">// 使用 informerFactory 创建Services资源的 informer对象</span><br><span class="line">serviceInformer := factory.Core().V1().Services()</span><br><span class="line">// 使用 informerFactory 创建Ingresses资源的 informer对象</span><br><span class="line">ingressInformer := factory.Networking().V1().Ingresses()</span><br><span class="line"></span><br><span class="line">// 创建一个自定义控制器</span><br><span class="line">controller := pkg.NewController(clientset, serviceInformer, ingressInformer)</span><br><span class="line"></span><br><span class="line">// 创建 停止channel信号</span><br><span class="line">stopCh := make(chan struct&#123;&#125;)</span><br><span class="line">// 启动 informerFactory，会启动已经创建的 serviceInformer、ingressInformer</span><br><span class="line">factory.Start(stopCh)</span><br><span class="line">// 等待 所有informer 从 etcd 实现全量同步</span><br><span class="line">factory.WaitForCacheSync(stopCh)</span><br><span class="line"></span><br><span class="line">// 启动自定义控制器</span><br><span class="line">controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller.go文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">package pkg</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">corev1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">netv1 &quot;k8s.io/api/networking/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/api/errors&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/util/wait&quot;</span><br><span class="line">informercorev1 &quot;k8s.io/client-go/informers/core/v1&quot;</span><br><span class="line">informernetv1 &quot;k8s.io/client-go/informers/networking/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">listercorev1 &quot;k8s.io/client-go/listers/core/v1&quot;</span><br><span class="line">listernetv1 &quot;k8s.io/client-go/listers/networking/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/cache&quot;</span><br><span class="line">&quot;k8s.io/client-go/util/workqueue&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">// worker 数量</span><br><span class="line">workNum = 5</span><br><span class="line">// service 指定 ingress 的 annotation key</span><br><span class="line">annoKey = &quot;ingress/http&quot;</span><br><span class="line">// 调谐失败的最大重试次数</span><br><span class="line">maxRetry = 10</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 自定义控制器</span><br><span class="line">type controller struct &#123;</span><br><span class="line">client        kubernetes.Interface</span><br><span class="line">serviceLister listercorev1.ServiceLister</span><br><span class="line">ingressLister listernetv1.IngressLister</span><br><span class="line">queue         workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewController 创建一个自定义控制器</span><br><span class="line">func NewController(clientset *kubernetes.Clientset, serviceInformer informercorev1.ServiceInformer, ingressInformer informernetv1.IngressInformer) *controller &#123;</span><br><span class="line">// 控制器中，包含一个clientset、service和ingress的缓存监听器、一个workqueue</span><br><span class="line">c := controller&#123;</span><br><span class="line">client:        clientset,</span><br><span class="line">serviceLister: serviceInformer.Lister(),</span><br><span class="line">ingressLister: ingressInformer.Lister(),</span><br><span class="line">queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &quot;ingressManager&quot;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为 serviceInformer 添加 ResourceEventHandler</span><br><span class="line">serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">// 添加service时触发</span><br><span class="line">AddFunc: c.addService,</span><br><span class="line">// 修改service时触发</span><br><span class="line">UpdateFunc: c.updateService,</span><br><span class="line">// 这里没有删除service的逻辑，因为我们会使用 OwnerReferences 将service+ingress关联起来。</span><br><span class="line">// 因此删除service，会由kubernetes的ControllerManager中的特殊Controller，自动完成ingress的gc</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为 ingressInformer 添加 ResourceEventHandler</span><br><span class="line">ingressInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">// 删除ingress时触发</span><br><span class="line">DeleteFunc: c.deleteIngress,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">return &amp;c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加service时触发</span><br><span class="line">func (c *controller) addService(obj interface&#123;&#125;) &#123;</span><br><span class="line">// 将 添加service 的 key 加入 workqueue</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改service时触发</span><br><span class="line">func (c *controller) updateService(oldObj interface&#123;&#125;, newObj interface&#123;&#125;) &#123;</span><br><span class="line">// 如果两个对象一致，就无需触发修改逻辑</span><br><span class="line">if reflect.DeepEqual(oldObj, newObj) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// todo 比较annotation</span><br><span class="line">// 将 修改service 的 key 加入 workqueue</span><br><span class="line">c.enqueue(newObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除ingress时触发</span><br><span class="line">func (c *controller) deleteIngress(obj interface&#123;&#125;) &#123;</span><br><span class="line">// 将对象转成ingress，并获取到它的 ownerReference</span><br><span class="line">ingress := obj.(*netv1.Ingress)</span><br><span class="line">ownerReference := metav1.GetControllerOf(ingress)</span><br><span class="line">// 如果ingress的 ownerReference 没有绑定到service，则无需处理</span><br><span class="line">if ownerReference == nil || ownerReference.Kind != &quot;Service&quot; &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// 如果ingress的 ownerReference 已经绑定到service，则需要处理</span><br><span class="line">c.enqueue(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// enqueue 将 待添加service 的 key 加入 workqueue</span><br><span class="line">func (c *controller) enqueue(obj interface&#123;&#125;) &#123;</span><br><span class="line">// 调用工具方法，获取 kubernetes资源对象的 key（默认是 ns/name，或 name）</span><br><span class="line">key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">// 获取失败，不加入队列，即本次事件不予处理</span><br><span class="line">if err != nil &#123;</span><br><span class="line">runtime.HandleError(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// 将 key 加入 workqueue</span><br><span class="line">c.queue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// dequeue 将处理完成的 key 出队</span><br><span class="line">func (c *controller) dequeue(item interface&#123;&#125;) &#123;</span><br><span class="line">c.queue.Done(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Run 启动controller</span><br><span class="line">func (c *controller) Run(stopCh chan struct&#123;&#125;) &#123;</span><br><span class="line">// 启动多个worker，同时对workqueue中的事件进行处理，效率提升5倍</span><br><span class="line">for i := 0; i &lt; workNum; i++ &#123;</span><br><span class="line">// 每个worker都是一个协程，使用同一个停止信号</span><br><span class="line">go wait.Until(c.worker, time.Minute, stopCh)</span><br><span class="line">&#125;</span><br><span class="line">// 启动完成后，Run函数就停止在这里，等待停止信号</span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// worker方法</span><br><span class="line">func (c *controller) worker() &#123;</span><br><span class="line">// 死循环，worker处理完一个，再去处理下一个</span><br><span class="line">for c.processNextItem() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// processNextItem 处理下一个</span><br><span class="line">func (c *controller) processNextItem() bool &#123;</span><br><span class="line">// 从 workerqueue 取出一个key</span><br><span class="line">item, shutdown := c.queue.Get()</span><br><span class="line">// 如果已经收到停止信号了，则返回false，worker就会停止处理</span><br><span class="line">if shutdown &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">// 处理完成后，将这个key出队</span><br><span class="line">defer c.dequeue(item)</span><br><span class="line"></span><br><span class="line">// 转成string类型的key</span><br><span class="line">key := item.(string)</span><br><span class="line"></span><br><span class="line">// 处理service逻辑的核心方法</span><br><span class="line">err := c.syncService(key)</span><br><span class="line">// 处理过程出错，进入错误统一处理逻辑</span><br><span class="line">if err != nil &#123;</span><br><span class="line">c.handleError(key, err)</span><br><span class="line">&#125;</span><br><span class="line">// 处理结束，返回true</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// handleError 错误统一处理逻辑</span><br><span class="line">func (c *controller) handleError(key string, err error) &#123;</span><br><span class="line">// 如果当前key的处理次数，还不到最大重试次数，则再次加入队列</span><br><span class="line">if c.queue.NumRequeues(key) &lt; maxRetry &#123;</span><br><span class="line">c.queue.AddRateLimited(key)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行时统一处理错误</span><br><span class="line">runtime.HandleError(err)</span><br><span class="line">// 不再处理这个key</span><br><span class="line">c.queue.Forget(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// syncService 处理service逻辑的核心方法</span><br><span class="line">func (c *controller) syncService(key string) error &#123;</span><br><span class="line">// 将 key 切割为 ns 和 name</span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从indexer中，获取service</span><br><span class="line">service, err := c.serviceLister.Services(namespace).Get(name)</span><br><span class="line">// 没有service，直接返回</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查service的annotation，是否包含 key: &quot;ingress/http&quot;</span><br><span class="line">_, ok := service.Annotations[annoKey]</span><br><span class="line">// 从indexer缓存中，获取ingress</span><br><span class="line">ingress, err := c.ingressLister.Ingresses(namespace).Get(name)</span><br><span class="line"></span><br><span class="line">if ok &amp;&amp; errors.IsNotFound(err) &#123;</span><br><span class="line">// ingress不存在，但是service有&quot;ingress/http&quot;，需要创建ingress</span><br><span class="line">// 创建ingress</span><br><span class="line">ig := c.createIngress(service)</span><br><span class="line">// 调用controller中的client，完成ingress的创建</span><br><span class="line">_, err := c.client.NetworkingV1().Ingresses(namespace).Create(context.TODO(), ig, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if !ok &amp;&amp; ingress != nil &#123;</span><br><span class="line">// ingress存在，但是service没有&quot;ingress/http&quot;，需要删除ingress</span><br><span class="line">// 调用controller中的client，完成ingress的删除</span><br><span class="line">err := c.client.NetworkingV1().Ingresses(namespace).Delete(context.TODO(), name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// createIngress 创建ingress</span><br><span class="line">func (c *controller) createIngress(service *corev1.Service) *netv1.Ingress &#123;</span><br><span class="line">icn := &quot;ingress&quot;</span><br><span class="line">pathType := netv1.PathTypePrefix</span><br><span class="line">return &amp;netv1.Ingress&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name:      service.Name,</span><br><span class="line">Namespace: service.Namespace,</span><br><span class="line">OwnerReferences: []metav1.OwnerReference&#123;</span><br><span class="line">*metav1.NewControllerRef(service, corev1.SchemeGroupVersion.WithKind(&quot;Service&quot;)),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Spec: netv1.IngressSpec&#123;</span><br><span class="line">IngressClassName: &amp;icn,</span><br><span class="line">Rules: []netv1.IngressRule&#123;</span><br><span class="line">&#123;</span><br><span class="line">Host: &quot;example.com&quot;,</span><br><span class="line">IngressRuleValue: netv1.IngressRuleValue&#123;</span><br><span class="line">HTTP: &amp;netv1.HTTPIngressRuleValue&#123;</span><br><span class="line">Paths: []netv1.HTTPIngressPath&#123;</span><br><span class="line">&#123;</span><br><span class="line">Path:     &quot;/&quot;,</span><br><span class="line">PathType: &amp;pathType,</span><br><span class="line">Backend: netv1.IngressBackend&#123;</span><br><span class="line">Service: &amp;netv1.IngressServiceBackend&#123;</span><br><span class="line">Name: service.Name,</span><br><span class="line">Port: netv1.ServiceBackendPort&#123;</span><br><span class="line">Number: 80,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>client-go之DiscoveryClient</title>
      <link href="/posts/4a17d0005.html"/>
      <url>/posts/4a17d0005.html</url>
      
        <content type="html"><![CDATA[<h2 id="DiscoveryClient是什么"><a href="#DiscoveryClient是什么" class="headerlink" title="DiscoveryClient是什么"></a>DiscoveryClient是什么</h2><ul><li>我们前面学习的3种Client：RESTClient、Clientset、DynamicClient，都是用来操作 kubernetes 资源的，我们目前还缺少一个用于检索 kuberentes资源的 Client</li><li>DiscoveryClient 就是这样一个 Client。用于检索 kuberentes集群中支持的 API 资源的相关信息，例如版本、组、资源类型等。</li><li>DiscoveryClient 提供了一组方法来查询和获取这些信息，以便在编写 Controller 或 Operator 时，能够动态地了解集群中可用的资源。</li></ul><h2 id="DiscoveryClient结构体"><a href="#DiscoveryClient结构体" class="headerlink" title="DiscoveryClient结构体"></a>DiscoveryClient结构体</h2><ul><li>位于 staging&#x2F;src&#x2F;k8s.io&#x2F;client-go&#x2F;discovery&#x2F;discovery_client.go</li><li>DiscoveryClient 结构体很简单<ul><li>LegacyPrefix 字段表示旧版本资源的访问前缀，一般值都是&#x2F;api。Kubernetes 1.16 以前，资源的访问前缀都是 &#x2F;api，1.16及之后，全面改成 &#x2F;apis，为了兼容旧资源，这里特意保存了一个常量字符串 &#x2F;api<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type DiscoveryClient struct &#123;</span><br><span class="line">restClient restclient.Interface</span><br><span class="line"></span><br><span class="line">LegacyPrefix string</span><br><span class="line">// Forces the client to request only &quot;unaggregated&quot; (legacy) discovery.</span><br><span class="line">UseLegacyDiscovery bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DiscoveryClient的常用方法"><a href="#DiscoveryClient的常用方法" class="headerlink" title="DiscoveryClient的常用方法"></a>DiscoveryClient的常用方法</h2><p>1、discovery.NewDiscoveryClientForConfig()方法</p><ul><li><p>位于 &#x2F;client-go&#x2F;discovery&#x2F;discovery_client.go，是一个函数，位于discovery包下，所以直接点就可以使用</p></li><li><p>该方法用于创建一个 DiscoveryClient 实例，入参也是 *rest.Config 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NewDiscoveryClientForConfig(c *restclient.Config) (*DiscoveryClient, error) &#123;</span><br><span class="line">config := *c</span><br><span class="line">if err := setDiscoveryDefaults(&amp;config); err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">httpClient, err := restclient.HTTPClientFor(&amp;config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return NewDiscoveryClientForConfigAndClient(&amp;config, httpClient)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、DiscoveryClient的实例方法</p></li><li><p>DiscoveryClient 实现了接口的所有方法，用于获取API资源的各种信息</p><ul><li>ServerGroupsInterface等这些接口，内部也有很多方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type DiscoveryInterface interface &#123;</span><br><span class="line">RESTClient() restclient.Interface</span><br><span class="line">ServerGroupsInterface</span><br><span class="line">ServerResourcesInterface</span><br><span class="line">ServerVersionInterface</span><br><span class="line">OpenAPISchemaInterface</span><br><span class="line">OpenAPIV3SchemaInterface</span><br><span class="line">// Returns copy of current discovery client that will only</span><br><span class="line">// receive the legacy discovery format, or pointer to current</span><br><span class="line">// discovery client if it does not support legacy-only discovery.</span><br><span class="line">WithLegacy() DiscoveryInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="CachedDiscoveryClient-和-DiscoveryClient-的区别"><a href="#CachedDiscoveryClient-和-DiscoveryClient-的区别" class="headerlink" title="CachedDiscoveryClient 和 DiscoveryClient 的区别"></a>CachedDiscoveryClient 和 DiscoveryClient 的区别</h2><ul><li><p>在查看 DiscoveryInterface 的时候，除了 DiscoveryClient，还有一个实现类 CachedDiscoveryClient</p></li><li><p>顾名思义，CachedDiscoveryClient 就是实现了缓存机制的 DiscoveryClient 的封装</p></li><li><p>CachedDiscoveryClient 在 DiscoveryClient 的基础上增加了一层缓存，用于缓存获取的资源信息，以减少对 API Server 的频繁请求。</p></li><li><p>在首次调用时，CachedDiscoveryClient 会从 API Server 获取资源信息，并将其缓存在本地。之后的调用会直接从缓存中获取资源信息，而不需要再次向 API Server 发送请求。</p></li><li><p>因为 集群部署完成后，API 资源基本很少变化，所以缓存下来可以很好的提高请求效率。</p></li><li><p>kubectl 工具内部，kubectl api-versions命令其实就是使用了这个CachedDiscoveryClient，所以多次执行kubectl api-versions命令，其实只有第一次请求了API Server，后续都是直接使用的 本地缓存。</p></li></ul><h2 id="DiscoveryClient-使用示例"><a href="#DiscoveryClient-使用示例" class="headerlink" title="DiscoveryClient 使用示例"></a>DiscoveryClient 使用示例</h2><ul><li>需求：获取 当前kubernetes集群 的 所有资源列表</li><li>代码编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">// 1、先创建一个客户端配置config</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2、使用 discovery.NewDiscoveryClientForConfig()，创建一个 DiscoveryClient 对象</span><br><span class="line">discoveryClient, err := discovery.NewDiscoveryClientForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3、使用 DiscoveryClient.ServerGroupsAndResources()，获取所有资源列表</span><br><span class="line">_, resourceLists, err := discoveryClient.ServerGroupsAndResources()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4、遍历资源列表，打印出资源组和资源名称</span><br><span class="line">for _, resource := range resourceLists &#123;</span><br><span class="line">fmt.Printf(&quot;resource groupVersion: %s\n&quot;, resource.GroupVersion)</span><br><span class="line">for _, resource := range resource.APIResources &#123;</span><br><span class="line">fmt.Printf(&quot;resource name: %s\n&quot;, resource.Name)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;--------------------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  输出结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">resource groupVersion: v1</span><br><span class="line">resource name: bindings</span><br><span class="line">resource name: componentstatuses</span><br><span class="line">resource name: configmaps</span><br><span class="line">resource name: endpoints</span><br><span class="line">resource name: events</span><br><span class="line">resource name: limitranges</span><br><span class="line">resource name: namespaces</span><br><span class="line">resource name: namespaces/finalize</span><br><span class="line">resource name: namespaces/status</span><br><span class="line">resource name: nodes</span><br><span class="line">resource name: nodes/proxy</span><br><span class="line">resource name: nodes/status</span><br><span class="line">resource name: persistentvolumeclaims</span><br><span class="line">resource name: persistentvolumeclaims/status</span><br><span class="line">resource name: persistentvolumes</span><br><span class="line">resource name: persistentvolumes/status</span><br><span class="line">resource name: pods</span><br><span class="line">resource name: pods/attach</span><br><span class="line">resource name: pods/binding</span><br><span class="line">resource name: pods/eviction</span><br><span class="line">resource name: pods/exec</span><br><span class="line">resource name: pods/log</span><br><span class="line">resource name: pods/portforward</span><br><span class="line">resource name: pods/proxy</span><br><span class="line">resource name: pods/status</span><br><span class="line">resource name: podtemplates</span><br><span class="line">resource name: replicationcontrollers</span><br><span class="line">resource name: replicationcontrollers/scale</span><br><span class="line">resource name: replicationcontrollers/status</span><br><span class="line">resource name: resourcequotas</span><br><span class="line">resource name: resourcequotas/status</span><br><span class="line">resource name: secrets</span><br><span class="line">resource name: serviceaccounts</span><br><span class="line">resource name: services</span><br><span class="line">resource name: services/proxy</span><br><span class="line">resource name: services/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: apiregistration.k8s.io/v1</span><br><span class="line">resource name: apiservices</span><br><span class="line">resource name: apiservices/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: apiregistration.k8s.io/v1beta1</span><br><span class="line">resource name: apiservices</span><br><span class="line">resource name: apiservices/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: extensions/v1beta1</span><br><span class="line">resource name: ingresses</span><br><span class="line">resource name: ingresses/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: apps/v1</span><br><span class="line">resource name: controllerrevisions</span><br><span class="line">resource name: daemonsets</span><br><span class="line">resource name: daemonsets/status</span><br><span class="line">resource name: deployments</span><br><span class="line">resource name: deployments/scale</span><br><span class="line">resource name: deployments/status</span><br><span class="line">resource name: replicasets</span><br><span class="line">resource name: replicasets/scale</span><br><span class="line">resource name: replicasets/status</span><br><span class="line">resource name: statefulsets</span><br><span class="line">resource name: statefulsets/scale</span><br><span class="line">resource name: statefulsets/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: events.k8s.io/v1beta1</span><br><span class="line">resource name: events</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: authentication.k8s.io/v1</span><br><span class="line">resource name: tokenreviews</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: authentication.k8s.io/v1beta1</span><br><span class="line">resource name: tokenreviews</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: authorization.k8s.io/v1</span><br><span class="line">resource name: localsubjectaccessreviews</span><br><span class="line">resource name: selfsubjectaccessreviews</span><br><span class="line">resource name: selfsubjectrulesreviews</span><br><span class="line">resource name: subjectaccessreviews</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: authorization.k8s.io/v1beta1</span><br><span class="line">resource name: localsubjectaccessreviews</span><br><span class="line">resource name: selfsubjectaccessreviews</span><br><span class="line">resource name: selfsubjectrulesreviews</span><br><span class="line">resource name: subjectaccessreviews</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: autoscaling/v1</span><br><span class="line">resource name: horizontalpodautoscalers</span><br><span class="line">resource name: horizontalpodautoscalers/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: autoscaling/v2beta1</span><br><span class="line">resource name: horizontalpodautoscalers</span><br><span class="line">resource name: horizontalpodautoscalers/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: autoscaling/v2beta2</span><br><span class="line">resource name: horizontalpodautoscalers</span><br><span class="line">resource name: horizontalpodautoscalers/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: batch/v1</span><br><span class="line">resource name: jobs</span><br><span class="line">resource name: jobs/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: batch/v1beta1</span><br><span class="line">resource name: cronjobs</span><br><span class="line">resource name: cronjobs/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: certificates.k8s.io/v1beta1</span><br><span class="line">resource name: certificatesigningrequests</span><br><span class="line">resource name: certificatesigningrequests/approval</span><br><span class="line">resource name: certificatesigningrequests/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: networking.k8s.io/v1</span><br><span class="line">resource name: networkpolicies</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: networking.k8s.io/v1beta1</span><br><span class="line">resource name: ingresses</span><br><span class="line">resource name: ingresses/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: policy/v1beta1</span><br><span class="line">resource name: poddisruptionbudgets</span><br><span class="line">resource name: poddisruptionbudgets/status</span><br><span class="line">resource name: podsecuritypolicies</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">resource name: clusterrolebindings</span><br><span class="line">resource name: clusterroles</span><br><span class="line">resource name: rolebindings</span><br><span class="line">resource name: roles</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">resource name: clusterrolebindings</span><br><span class="line">resource name: clusterroles</span><br><span class="line">resource name: rolebindings</span><br><span class="line">resource name: roles</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: storage.k8s.io/v1</span><br><span class="line">resource name: csinodes</span><br><span class="line">resource name: storageclasses</span><br><span class="line">resource name: volumeattachments</span><br><span class="line">resource name: volumeattachments/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: storage.k8s.io/v1beta1</span><br><span class="line">resource name: csidrivers</span><br><span class="line">resource name: csinodes</span><br><span class="line">resource name: storageclasses</span><br><span class="line">resource name: volumeattachments</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: admissionregistration.k8s.io/v1</span><br><span class="line">resource name: mutatingwebhookconfigurations</span><br><span class="line">resource name: validatingwebhookconfigurations</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: admissionregistration.k8s.io/v1beta1</span><br><span class="line">resource name: mutatingwebhookconfigurations</span><br><span class="line">resource name: validatingwebhookconfigurations</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: apiextensions.k8s.io/v1</span><br><span class="line">resource name: customresourcedefinitions</span><br><span class="line">resource name: customresourcedefinitions/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: apiextensions.k8s.io/v1beta1</span><br><span class="line">resource name: customresourcedefinitions</span><br><span class="line">resource name: customresourcedefinitions/status</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: scheduling.k8s.io/v1</span><br><span class="line">resource name: priorityclasses</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: scheduling.k8s.io/v1beta1</span><br><span class="line">resource name: priorityclasses</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: coordination.k8s.io/v1</span><br><span class="line">resource name: leases</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: coordination.k8s.io/v1beta1</span><br><span class="line">resource name: leases</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: node.k8s.io/v1beta1</span><br><span class="line">resource name: runtimeclasses</span><br><span class="line">--------------------------</span><br><span class="line">resource groupVersion: discovery.k8s.io/v1beta1</span><br><span class="line">resource name: endpointslices</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>client-go之DyamicClient</title>
      <link href="/posts/4a17d0004.html"/>
      <url>/posts/4a17d0004.html</url>
      
        <content type="html"><![CDATA[<h2 id="DynamicClient是什么"><a href="#DynamicClient是什么" class="headerlink" title="DynamicClient是什么"></a>DynamicClient是什么</h2><ul><li>Clientset是一系列RESTClient的集合，创建一个 Clientset 实例，其中已经包含了所有kubernetes内置资源的RESTClient，可是对于CustomResource(CR)资源，Clientset就没有操作它们的RESTClient了。</li><li>因此，client-go特意提供了一种 客户端，即 DynamicClient，可以操作任意的kubernetes资源，包括 内置资源 + CR 资源</li></ul><h2 id="DynamicClient结构体分析"><a href="#DynamicClient结构体分析" class="headerlink" title="DynamicClient结构体分析"></a>DynamicClient结构体分析</h2><ul><li>位于 &#x2F;client-go&#x2F;dynamic&#x2F;simple.go</li><li>DynamicClient结构体<ul><li>可以看到，DynamicClient 中只包含一个RESTClient的字段 client</li><li>client 类型为 rest.Interface，即为 RESTClient实现的那个接口，可以在4.2.2中看到<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type DynamicClient struct &#123;</span><br><span class="line">   client rest.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DynamicClient的常用方法"><a href="#DynamicClient的常用方法" class="headerlink" title="DynamicClient的常用方法"></a>DynamicClient的常用方法</h2><h3 id="dynamic-NewForConfig-方法"><a href="#dynamic-NewForConfig-方法" class="headerlink" title="dynamic.NewForConfig()方法"></a>dynamic.NewForConfig()方法</h3><ul><li>位于 &#x2F;client-go&#x2F;dynamic&#x2F;simple.go，是一个函数，位于dynamic包下，所以直接点就可以使用</li><li>该方法用于创建一个 DynamicClient 实例，入参也是 *rest.Config 类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func NewForConfig(inConfig *rest.Config) (*DynamicClient, error) &#123;</span><br><span class="line">config := ConfigFor(inConfig)</span><br><span class="line"></span><br><span class="line">httpClient, err := rest.HTTPClientFor(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return NewForConfigAndClient(config, httpClient)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DynamicClient-的-实例方法"><a href="#DynamicClient-的-实例方法" class="headerlink" title="DynamicClient 的 实例方法"></a>DynamicClient 的 实例方法</h3><ul><li><p>结论：</p><ul><li>DynamicClient 只有一个实例方法： Resource(resource schema.GroupVersionResource)，用于指定当前 DynamicClient 要操作的究竟是什么类型。<br>下面进行源码分析。</li></ul></li><li><p>Resource()其实是 DynamicClient 实现了接口 dynamic.Interface</p><ul><li>接口中只有一个 Resource()</li><li>参数是一个 GVR，指定group、version、resource，就可以确定到底是哪个资源了</li><li>返回值为 NamespaceableResourceInterface 接口类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">Resource(resource schema.GroupVersionResource) NamespaceableResourceInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DynamicClient 实现了这个接口，自然也实现了Resource这个方法</p><ul><li>下面代码返回的是 NamespaceableResourceInterface 接口的实现类型 dynamicResourceClient 的对象</li><li>这个对象就是我们最终可以用于操作 你所指定资源 的 Client 了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (c *DynamicClient) Resource(resource schema.GroupVersionResource) NamespaceableResourceInterface &#123;</span><br><span class="line">return &amp;dynamicResourceClient&#123;client: c, resource: resource&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>dynamicResourceClient 类型</p><ul><li>可见，dynamicResourceClient 包含了DynamicClient对象、要操作的类型的GVR、还有资源的ns<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type dynamicResourceClient struct &#123;</span><br><span class="line">client    *DynamicClient</span><br><span class="line">namespace string</span><br><span class="line">resource  schema.GroupVersionResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以调用它的Namespace方法，为namespace字段赋值</p><ul><li>这个方法就是NamespaceableResourceInterface 接口提供的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (c *dynamicResourceClient) Namespace(ns string) ResourceInterface &#123;</span><br><span class="line">ret := *c</span><br><span class="line">ret.namespace = ns</span><br><span class="line">return &amp;ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="认识kubrenetes-的-Unstructured"><a href="#认识kubrenetes-的-Unstructured" class="headerlink" title="认识kubrenetes 的 Unstructured"></a>认识kubrenetes 的 Unstructured</h2><h3 id="为什么需要-Unstructured"><a href="#为什么需要-Unstructured" class="headerlink" title="为什么需要 Unstructured"></a>为什么需要 Unstructured</h3><ul><li>前面我们使用 RESTClient 或 Clientset，调用的是某个资源的 Get、List 等方法，返回值都是确定的。比如 调用Pod资源的List，我们能够确定返回的一定是PodList，所以Pod的List方法，就写死了，返回值就是PodList</li><li>可当使用 DynamicClient 时，DynamicClient 没有确定的资源，资源类型是我们使用的时候才会去指定GVR的，所以 开发DynamicClient 的时候，Get 方法自然无法确定返回值类型。</li><li>那么kubernetes人员应该如何开发这个Get方法？</li><li>我们自然而然的能够想到，如果有一个通用的数据结构，可以表示所有类型的资源，问题就解决了</li><li>Unstructured 应运而生。它就是一个 可以表示所有资源的类型。</li></ul><h3 id="Unstructured源码"><a href="#Unstructured源码" class="headerlink" title="Unstructured源码"></a>Unstructured源码</h3><ul><li><p>位于 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;apis&#x2F;meta&#x2F;v1&#x2F;unsructured&#x2F;unsructured.go 中<br>  Unstructured 结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Unstructured struct &#123;</span><br><span class="line">// Object is a JSON compatible map with string, float, int, bool, []interface&#123;&#125;, or</span><br><span class="line">// map[string]interface&#123;&#125;</span><br><span class="line">// children.</span><br><span class="line">Object map[string]interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Unstructured 包含一个 map，键为string，value为interface{}，因此value可以为任意类型</p></li></ul><h3 id="dynamicResourceClient对于-Unstructured-的应用"><a href="#dynamicResourceClient对于-Unstructured-的应用" class="headerlink" title="dynamicResourceClient对于 Unstructured 的应用"></a>dynamicResourceClient对于 Unstructured 的应用</h3><ul><li>我们最终操作资源，其实使用的是 dynamicResourceClient,dynamicResourceClient 实现了 ResourceInterface 接口的所有方法，这些方法就是我们最终操作资源所调用的。下面我们看一下 ResourceInterface 接口的所有方法签名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type ResourceInterface interface &#123;</span><br><span class="line">Create(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) (*unstructured.Unstructured, error)</span><br><span class="line">Update(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) (*unstructured.Unstructured, error)</span><br><span class="line">UpdateStatus(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) (*unstructured.Unstructured, error)</span><br><span class="line">Delete(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) error</span><br><span class="line">DeleteCollection(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) error</span><br><span class="line">Get(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) (*unstructured.Unstructured, error)</span><br><span class="line">List(ctx context.Context, opts metav1.ListOptions) (*unstructured.UnstructuredList, error)</span><br><span class="line">Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">Patch(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) (*unstructured.Unstructured, error)</span><br><span class="line">Apply(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) (*unstructured.Unstructured, error)</span><br><span class="line">ApplyStatus(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) (*unstructured.Unstructured, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Create方法因为不知道要创建什么资源，所以参数接收的是 obj *unstructured.Unstructured</li><li>Get方法因为不知道返回的是什么资源，所以返回的是 *unstructured.Unstructured</li><li>List方法因为不知道返回的是什么资源列表，所以返回的是 *unstructured.UnstructuredList。这个结构里面包含一个 []unstructured.Unstructured</li></ul><h3 id="Unstructured-与-资源对象的相互转换"><a href="#Unstructured-与-资源对象的相互转换" class="headerlink" title="Unstructured 与 资源对象的相互转换"></a>Unstructured 与 资源对象的相互转换</h3><ul><li><p>既然 dynamicResourceClient 的方法 接收和返回的，很多都是 Unstructured 类型，那么我们就需要实现 真正的资源对象 与 Unstructured 的 相互转换</p></li><li><p>runtime包下，给我们提供了一个 UnstructuredConverter 接口，接口中提供了两个方法，分别用于 资源对象–&gt;Unstructured 和 Unstructured–&gt;资源对象</p><ul><li>位于 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;converter.go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type UnstructuredConverter interface &#123;</span><br><span class="line">   ToUnstructured(obj interface&#123;&#125;) (map[string]interface&#123;&#125;, error)</span><br><span class="line">   FromUnstructured(u map[string]interface&#123;&#125;, obj interface&#123;&#125;) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>UnstructuredConverter 接口只有一个实现类 unstructuredConverter</p><ul><li>位于 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;converter.go<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type unstructuredConverter struct &#123;</span><br><span class="line">// If true, we will be additionally running conversion via json</span><br><span class="line">// to ensure that the result is true.</span><br><span class="line">// This is supposed to be set only in tests.</span><br><span class="line">mismatchDetection bool</span><br><span class="line">// comparison is the default test logic used to compare</span><br><span class="line">comparison conversion.Equalities</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>unstructuredConverter 实现了UnstructuredConverter 接口的 两个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (c *unstructuredConverter) ToUnstructured(obj interface&#123;&#125;) (map[string]interface&#123;&#125;, error)：资源对象–&gt;Unstructured</span><br><span class="line">func (c *unstructuredConverter) FromUnstructured(u map[string]interface&#123;&#125;, obj interface&#123;&#125;) error：Unstructured–&gt;资源对象</span><br></pre></td></tr></table></figure><p>不过，unstructuredConverter 类型开头小写，我们无法直接使用，kubernetes 创建了一个全局变量 DefaultUnstructuredConverter，类型就是unstructuredConverter，用以供外界使用;位于 staging&#x2F;src&#x2F;k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;runtime&#x2F;converter.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">......</span><br><span class="line">// DefaultUnstructuredConverter performs unstructured to Go typed object conversions.</span><br><span class="line">DefaultUnstructuredConverter = &amp;unstructuredConverter&#123;</span><br><span class="line">mismatchDetection: parseBool(os.Getenv(&quot;KUBE_PATCH_CONVERSION_DETECTOR&quot;)),</span><br><span class="line">comparison: conversion.EqualitiesOrDie(</span><br><span class="line">func(a, b time.Time) bool &#123;</span><br><span class="line">return a.UTC() == b.UTC()</span><br><span class="line">&#125;,</span><br><span class="line">),</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>总结：我们直接使用 runtime.DefaultUnstructuredConverter，调用它的 ToUnstructured 或 FromUnstructured 方法，就可以实现 Unstructured 与 资源对象的相互转换 了</p></li></ul><h2 id="DynamicClient使用示例"><a href="#DynamicClient使用示例" class="headerlink" title="DynamicClient使用示例"></a>DynamicClient使用示例</h2><ul><li>需求：获取 kube-system 命名空间下 name&#x3D;coredns 的 deploy 对象</li><li>步骤<ul><li>同样是先 创建一个客户端配置config</li><li>使用 dynamic.NewForConfig()，创建一个 DynamicClient 对象</li><li>使用 DynamicClient.Resource()，指定要操作的资源对象，获取到该资源的 Client</li><li>先为该Client指定ns，然后调用 Client 的 Get() 方法，获取到该资源对象</li><li>调用 runtime.DefaultUnstructuredConverter.FromUnstructured()，将 unstructured 反序列化成 Deployment 对象<br>代码编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">appsv1 &quot;k8s.io/api/apps/v1&quot;</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br><span class="line">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br><span class="line">&quot;k8s.io/client-go/dynamic&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 同样是先 创建一个客户端配置config</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 dynamic.NewForConfig()，创建一个 DynamicClient 对象</span><br><span class="line">dynamicClient, err := dynamic.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 DynamicClient.Resource()，指定要操作的资源对象，获取到该资源的 Client</span><br><span class="line">dynamicResourceClient := dynamicClient.Resource(schema.GroupVersionResource&#123;</span><br><span class="line">Group:    &quot;apps&quot;,</span><br><span class="line">Version:  &quot;v1&quot;,</span><br><span class="line">Resource: &quot;deployments&quot;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 先为该Client指定ns，然后调用 Client 的 Get() 方法，获取到该资源对象</span><br><span class="line">unstructured, err := dynamicResourceClient.</span><br><span class="line">Namespace(&quot;kube-system&quot;).</span><br><span class="line">Get(context.TODO(), &quot;coredns&quot;, metav1.GetOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用 runtime.DefaultUnstructuredConverter.FromUnstructured()，将 unstructured 反序列化成 Deployment 对象</span><br><span class="line">deploy := &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">err = runtime.DefaultUnstructuredConverter.FromUnstructured(unstructured.UnstructuredContent(), deploy)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印 deploy 名称和命名空间</span><br><span class="line">fmt.Printf(&quot;deploy.Name: %s\ndeploy.namespace: %s&quot;, deploy.Name, deploy.Namespace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  输出结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy.Name: coredns</span><br><span class="line">deploy.namespace: kube-system</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>client-go之ClientSet</title>
      <link href="/posts/4a17d0003.html"/>
      <url>/posts/4a17d0003.html</url>
      
        <content type="html"><![CDATA[<h2 id="Clientset是什么"><a href="#Clientset是什么" class="headerlink" title="Clientset是什么"></a>Clientset是什么</h2><p>结论：Clientset 是 一系列 RESTClient 的 集合。<br>使用 RESTClient 操作kubernetes资源，太麻烦了</p><ul><li>要操作 pods，需要指定config，给config设置 APIPath 为 “&#x2F;api”、设置序列化器、设置 GroupVersion，最后还要调用 rest.RESTClientFor(config) 得到一个 用于操作pods的Clientset</li><li>而如果我要操作 deployment，这个过程又需要写一遍，然后又得到一个 用于操作deployment的Clientset</li><li>代码冗余，不优雅，而且到处创建Clientset，耗时又浪费资源<br>因此，就有了事先创建 各种资源的RESTClient，存起来备用的需求。Clientset就是这样封装起来的一个set集合。</li></ul><h2 id="Clientset的结构体"><a href="#Clientset的结构体" class="headerlink" title="Clientset的结构体"></a>Clientset的结构体</h2><p>位于 &#x2F;kubernetes&#x2F;clientset.go 中,Clientset结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Clientset struct &#123;</span><br><span class="line">......</span><br><span class="line">appsV1                        *appsv1.AppsV1Client</span><br><span class="line">appsV1beta1                   *appsv1beta1.AppsV1beta1Client</span><br><span class="line">appsV1beta2                   *appsv1beta2.AppsV1beta2Client</span><br><span class="line">authenticationV1              *authenticationv1.AuthenticationV1Client</span><br><span class="line">authenticationV1alpha1        *authenticationv1alpha1.AuthenticationV1alpha1Client</span><br><span class="line">authenticationV1beta1         *authenticationv1beta1.AuthenticationV1beta1Client</span><br><span class="line">authorizationV1               *authorizationv1.AuthorizationV1Client</span><br><span class="line">authorizationV1beta1          *authorizationv1beta1.AuthorizationV1beta1Client</span><br><span class="line">autoscalingV1                 *autoscalingv1.AutoscalingV1Client</span><br><span class="line">autoscalingV2                 *autoscalingv2.AutoscalingV2Client</span><br><span class="line">autoscalingV2beta1            *autoscalingv2beta1.AutoscalingV2beta1Client</span><br><span class="line">autoscalingV2beta2            *autoscalingv2beta2.AutoscalingV2beta2Client</span><br><span class="line">batchV1                       *batchv1.BatchV1Client</span><br><span class="line">batchV1beta1                  *batchv1beta1.BatchV1beta1Client</span><br><span class="line">certificatesV1                *certificatesv1.CertificatesV1Client</span><br><span class="line">certificatesV1beta1           *certificatesv1beta1.CertificatesV1beta1Client</span><br><span class="line">certificatesV1alpha1          *certificatesv1alpha1.CertificatesV1alpha1Client</span><br><span class="line">coordinationV1beta1           *coordinationv1beta1.CoordinationV1beta1Client</span><br><span class="line">coordinationV1                *coordinationv1.CoordinationV1Client</span><br><span class="line">coreV1                        *corev1.CoreV1Client</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以 appsv1 的类型 *appsv1.AppsV1Client 举例：可以看到，内部包含了一个 restClient。这也进一步认证，Clientset 就是一系列 RESTClient 的集合。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type AppsV1Client struct &#123;</span><br><span class="line">restClient rest.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Clientset的常用方法"><a href="#Clientset的常用方法" class="headerlink" title="Clientset的常用方法"></a>Clientset的常用方法</h2><p>1、NewForConfig()方法</p><ul><li>位于 &#x2F;kubernetes&#x2F;clientset.go 中，所以可以直接使用 kubernetes.NewForConfig() 使用</li><li>用于创建一个Clientset，传入一个rest.Config配置对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func NewForConfig(c *rest.Config) (*Clientset, error) &#123;</span><br><span class="line">configShallowCopy := *c</span><br><span class="line"></span><br><span class="line">if configShallowCopy.UserAgent == &quot;&quot; &#123;</span><br><span class="line">configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// share the transport between all clients</span><br><span class="line">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个方法，就完成了所有 RESTClient 的创建</span><br><span class="line">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) &#123;</span><br><span class="line">configShallowCopy := *c</span><br><span class="line">if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 &#123;</span><br><span class="line">if configShallowCopy.Burst &lt;= 0 &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0&quot;)</span><br><span class="line">&#125;</span><br><span class="line">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cs Clientset</span><br><span class="line">var err error</span><br><span class="line">// 下面就是创建各种 RESTClient 了，创建结果，被保存到 cs 中</span><br><span class="line">cs.admissionregistrationV1, err = admissionregistrationv1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">cs.admissionregistrationV1alpha1, err = admissionregistrationv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">cs.admissionregistrationV1beta1, err = admissionregistrationv1beta1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">return &amp;cs, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2、Clientset的实例方法</p><ul><li><p>Clientset 实现了 &#x2F;kubernetes&#x2F;clientset.go 下的 Interface接口，将自己内部的 私有属性 供外部使用</p></li><li><p>Interface 接口源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">......</span><br><span class="line">AppsV1() appsv1.AppsV1Interface</span><br><span class="line">AppsV1beta1() appsv1beta1.AppsV1beta1Interface</span><br><span class="line">AppsV1beta2() appsv1beta2.AppsV1beta2Interface</span><br><span class="line">AuthenticationV1() authenticationv1.AuthenticationV1Interface</span><br><span class="line">AuthenticationV1alpha1() authenticationv1alpha1.AuthenticationV1alpha1Interface</span><br><span class="line">AuthenticationV1beta1() authenticationv1beta1.AuthenticationV1beta1Interface</span><br><span class="line">AuthorizationV1() authorizationv1.AuthorizationV1Interface</span><br><span class="line">AuthorizationV1beta1() authorizationv1beta1.AuthorizationV1beta1Interface</span><br><span class="line">AutoscalingV1() autoscalingv1.AutoscalingV1Interface</span><br><span class="line">AutoscalingV2() autoscalingv2.AutoscalingV2Interface</span><br><span class="line">AutoscalingV2beta1() autoscalingv2beta1.AutoscalingV2beta1Interface</span><br><span class="line">AutoscalingV2beta2() autoscalingv2beta2.AutoscalingV2beta2Interface</span><br><span class="line">BatchV1() batchv1.BatchV1Interface</span><br><span class="line">BatchV1beta1() batchv1beta1.BatchV1beta1Interface</span><br><span class="line">CertificatesV1() certificatesv1.CertificatesV1Interface</span><br><span class="line">CertificatesV1beta1() certificatesv1beta1.CertificatesV1beta1Interface</span><br><span class="line">CertificatesV1alpha1() certificatesv1alpha1.CertificatesV1alpha1Interface</span><br><span class="line">CoordinationV1beta1() coordinationv1beta1.CoordinationV1beta1Interface</span><br><span class="line">CoordinationV1() coordinationv1.CoordinationV1Interface</span><br><span class="line">CoreV1() corev1.CoreV1Interface</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以 AppsV1() 方法为例，返回值是接口 appsv1.AppsV1Interface 的实现类 appsv1.AppsV1Client 的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">type AppsV1Interface interface &#123;</span><br><span class="line">RESTClient() rest.Interface</span><br><span class="line">ControllerRevisionsGetter</span><br><span class="line">DaemonSetsGetter</span><br><span class="line">DeploymentsGetter</span><br><span class="line">ReplicaSetsGetter</span><br><span class="line">StatefulSetsGetter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">type AppsV1Client struct &#123;</span><br><span class="line">restClient rest.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppsV1Client 实现 AppsV1Interface 接口的方法</span><br><span class="line">func (c *AppsV1Client) RESTClient() rest.Interface &#123;</span><br><span class="line">if c == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">return c.restClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以 appsv1.AppsV1Client.Deployments() 方法举例</p><ul><li>Deployments() 方法源码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 返回值是DeploymentInterface </span><br><span class="line">func (c *AppsV1Client) Deployments(namespace string) DeploymentInterface &#123;</span><br><span class="line">// 实际上，返回值是 DeploymentInterface 的实现类 deployments 的对象</span><br><span class="line">return newDeployments(c, namespace)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造一个 deployments 的对象</span><br><span class="line">func newDeployments(c *AppsV1Client, namespace string) *deployments &#123;</span><br><span class="line">return &amp;deployments&#123;</span><br><span class="line">client: c.RESTClient(),</span><br><span class="line">ns:     namespace,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>返回值：DeploymentInterface 接口源码，可以看到包含操作Deployment的各种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type DeploymentInterface interface &#123;</span><br><span class="line">Create(ctx context.Context, deployment *v1.Deployment, opts metav1.CreateOptions) (*v1.Deployment, error)</span><br><span class="line">Update(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">UpdateStatus(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error</span><br><span class="line">DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error</span><br><span class="line">Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Deployment, error)</span><br><span class="line">List(ctx context.Context, opts metav1.ListOptions) (*v1.DeploymentList, error)</span><br><span class="line">Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Deployment, err error)</span><br><span class="line">Apply(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">ApplyStatus(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">GetScale(ctx context.Context, deploymentName string, options metav1.GetOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">UpdateScale(ctx context.Context, deploymentName string, scale *autoscalingv1.Scale, opts metav1.UpdateOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">ApplyScale(ctx context.Context, deploymentName string, scale *applyconfigurationsautoscalingv1.ScaleApplyConfiguration, opts metav1.ApplyOptions) (*autoscalingv1.Scale, error)</span><br><span class="line"></span><br><span class="line">DeploymentExpansion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>挑选 DeploymentInterface.Create 方法，查看 实现类 deployments 的 Create实现</p><ul><li>可以看出，Create方法的内容，就跟我们4.2.4中使用 RESTClient 的方式差不多</li><li>这更加印证了，Clientset 就是 对各种 GroupVersion 的 RESTClient 的封装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (c *deployments) Create(ctx context.Context, deployment *v1.Deployment, opts metav1.CreateOptions) (result *v1.Deployment, err error) &#123;</span><br><span class="line">result = &amp;v1.Deployment&#123;&#125;</span><br><span class="line">err = c.client.Post().</span><br><span class="line">Namespace(c.ns).</span><br><span class="line">Resource(&quot;deployments&quot;).</span><br><span class="line">VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">Body(deployment).</span><br><span class="line">Do(ctx).</span><br><span class="line">Into(result)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实际上，这些方法都不是人工写的，都是 code-generator 自动生成的</p><ul><li>code-generator 提供了很多工具用于为k8s中的资源生成相关代码，其中包括一个 client-gen</li><li>client-gen：可以为资源生成标准的操作方法(get;list;watch;create;update;patch;delete)</li><li>比如，在kuberentes源码 staging&#x2F;src&#x2F;k8s.io&#x2F;api&#x2F;core&#x2F;v1&#x2F;types.go 中，可以看到 type Pod struct 注释上，就使用了 genclient 的标记<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// +genclient</span><br><span class="line">// +genclient:method=UpdateEphemeralContainers,verb=update,subresource=ephemeralcontainers</span><br><span class="line">// ......</span><br><span class="line">type Pod struct &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>client-gen 常用标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +genclient - 生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）。</span><br><span class="line">// +genclient:nonNamespaced - 所有动作函数都是在没有名称空间的情况下生成</span><br><span class="line">// +genclient:onlyVerbs=create,get - 指定的动作函数被生成.</span><br><span class="line">// +genclient:skipVerbs=watch - 生成watch以外所有的动作函数.</span><br><span class="line">// +genclient:noStatus - 即使.Status字段存在也不生成updateStatus动作函数</span><br></pre></td></tr></table></figure></li></ul><h2 id="Clientset使用示例"><a href="#Clientset使用示例" class="headerlink" title="Clientset使用示例"></a>Clientset使用示例</h2><ul><li>需求：获取default命名空间下的pod列表，并获取kube-system命名空间下的deploy列表</li><li>从下面代码来看，创建了一个 clientset，就可以操作不同 GroupVersion 下的 不同资源，也无需再去手动指定 APIPath 等值了</li><li>代码编写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">v1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 同样是先 创建一个客户端配置config</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 kubernetes.NewForConfig()，创建一个ClientSet对象</span><br><span class="line">clientSet, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1、从 clientSet 中调用操作pod的 RESTClient，获取default命名空间下的pod列表</span><br><span class="line">pods, err := clientSet.CoreV1().Pods(v1.NamespaceDefault).List(context.TODO(), v1.ListOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">// 打印pod名称</span><br><span class="line">for _, pod := range pods.Items &#123;</span><br><span class="line">println(pod.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(&quot;------&quot;)</span><br><span class="line"></span><br><span class="line">// 2、从 clientSet 中调用操作 deploy 的 RESTClient，获取kube-system命名空间下的deploy列表</span><br><span class="line">deploys, err := clientSet.AppsV1().Deployments(&quot;kube-system&quot;).List(context.TODO(), v1.ListOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 deploy 名称</span><br><span class="line">for _, deploy := range deploys.Items &#123;</span><br><span class="line">println(deploy.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cassandra-5hbf7</span><br><span class="line">liveness-exec</span><br><span class="line">mysql-87pgn</span><br><span class="line">myweb-7f8rh</span><br><span class="line">myweb-rjblc</span><br><span class="line">nginx-pod-node1</span><br><span class="line">------</span><br><span class="line">coredns</span><br><span class="line">default-http-backend</span><br><span class="line">metrics-server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>client-go之RESTClient</title>
      <link href="/posts/4a17d0002.html"/>
      <url>/posts/4a17d0002.html</url>
      
        <content type="html"><![CDATA[<h2 id="RESTClient-是什么"><a href="#RESTClient-是什么" class="headerlink" title="RESTClient 是什么"></a>RESTClient 是什么</h2><ul><li>RESTClient 是最基础的客户端，提供与APIServer通信的最基本封装，可以向APIServer发送 Restful 风格请求。</li><li>之所以称 RESTClient 是 最基础的客户端，是因为其他三种Client，其实都是 RESTClient 的再封装，内部都使用了 RESTClient。</li></ul><h2 id="RESTClient结构体"><a href="#RESTClient结构体" class="headerlink" title="RESTClient结构体"></a>RESTClient结构体</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type RESTClient struct &#123;</span><br><span class="line">// base is the root URL for all invocations of the client</span><br><span class="line">base *url.URL</span><br><span class="line"></span><br><span class="line">// versionedAPIPath is a path segment connecting the base URL to the resource root</span><br><span class="line">versionedAPIPath string</span><br><span class="line"></span><br><span class="line">// content describes how a RESTClient encodes and decodes responses.</span><br><span class="line">content ClientContentConfig</span><br><span class="line"></span><br><span class="line">// creates BackoffManager that is passed to requests.</span><br><span class="line">createBackoffMgr func() BackoffManager</span><br><span class="line"></span><br><span class="line">// rateLimiter is shared among all requests created by this client unless specifically</span><br><span class="line">// overridden.</span><br><span class="line">rateLimiter flowcontrol.RateLimiter</span><br><span class="line"></span><br><span class="line">// warningHandler is shared among all requests created by this client.</span><br><span class="line">// If not set, defaultWarningHandler is used.</span><br><span class="line">warningHandler WarningHandler</span><br><span class="line"></span><br><span class="line">// Set specific behavior of the client.  If not set http.DefaultClient will be used.</span><br><span class="line">Client *http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RESTClient常用方法"><a href="#RESTClient常用方法" class="headerlink" title="RESTClient常用方法"></a>RESTClient常用方法</h2><ul><li>RESTClientFor()<ul><li>位置：rest&#x2F;config.go 文件</li><li>函数签名：func RESTClientFor(config *Config) (*RESTClient, error)，直接 rest点 调用</li><li>该方法是用于 创建一个 RESTClient 实例</li><li>接收一个 rest.Config 类型参数，Config中包含了 限速器、编解码器 等<ul><li>RESTClientFor 方法内部会从 Config 中取出这些配置，设置给RESTClient 实例</li><li>这样RESTClient 实例就具有了 限速、编解码 等多种功能</li><li>因此，我们创建Config的时候，可以手动设置这些功能，下面的示例中会展示。</li></ul></li></ul></li><li>RESTClient实例的常用方法<ul><li><p>&#x2F;rest&#x2F;client.go 中有一个接口 Interface</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Interface captures the set of operations for generically interacting with Kubernetes REST apis.</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">GetRateLimiter() flowcontrol.RateLimiter</span><br><span class="line">Verb(verb string) *Request</span><br><span class="line">Post() *Request</span><br><span class="line">Put() *Request</span><br><span class="line">Patch(pt types.PatchType) *Request</span><br><span class="line">Get() *Request</span><br><span class="line">Delete() *Request</span><br><span class="line">APIVersion() schema.GroupVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RESTClient 实现了这个接口，因此具有所有的方法，用于发送各种类型的请求</p></li><li><p>另外，Interface 每个方法的返回值都是 Request 类型，Request 类型的各种方法，很多的返回值也是 Request，这样就可以实现 链式编程 了</p></li></ul></li></ul><h2 id="RESTClient的一些其他知识点"><a href="#RESTClient的一些其他知识点" class="headerlink" title="RESTClient的一些其他知识点"></a>RESTClient的一些其他知识点</h2><ul><li><p>Request 和 Result 常用方法</p><ul><li>func (r *Request) Namespace(namespace string) *Request：设置 当前Resquest 访问的 namespace</li><li>func (r *Request) Resource(resource string) *Request：设置 当前Resquest 想要访问的资源类型</li><li>func (r *Request) Name(resourceName string) *Request：设置 当前Resquest 想要访问的资源的名称</li><li>func (r *Request) Do(ctx context.Context) Result：格式化并执行请求。返回一个 Result 对象，以便于处理响应。</li></ul></li><li><p>rest.Config 结构体</p></li></ul><p>位于 rest&#x2F;config.go 中，用于描述 kubernetes客户端的通用属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">// API 服务器的主机地址，格式为 https://&lt;hostname&gt;:&lt;port&gt;。默认情况下，它为空字符串，表示使用当前上下文中的集群配置。</span><br><span class="line">Host string</span><br><span class="line"></span><br><span class="line">// 指定 API 服务器的路径，目前只有两种取值:/api、/apis</span><br><span class="line">// - /api：访问core API 组资源时，其实group值为空</span><br><span class="line">// - /apis：访问其他 API 组资源时，都是apis，他们都有group值</span><br><span class="line">APIPath string</span><br><span class="line"></span><br><span class="line">// 对请求内容的配置，会影响对象在发送到服务器时的转换方式</span><br><span class="line">// - ContentConfig中有两个重要属性：</span><br><span class="line">//   - NegotiatedSerializer：用于序列化和反序列化请求和响应的接口</span><br><span class="line">//   - GroupVersion：请求资源的 API 组和版本</span><br><span class="line">ContentConfig</span><br><span class="line"></span><br><span class="line">// 用于进行基本身份验证的用户名的字符串</span><br><span class="line">Username string</span><br><span class="line"></span><br><span class="line">// 用于进行基本身份验证的密码的字符串</span><br><span class="line">Password string `datapolicy:&quot;password&quot;`</span><br><span class="line"></span><br><span class="line">// 用于进行身份验证的令牌的字符串</span><br><span class="line">BearerToken string `datapolicy:&quot;token&quot;`</span><br><span class="line"></span><br><span class="line">// 包含身份验证令牌的文件的路径</span><br><span class="line">BearerTokenFile string</span><br><span class="line"></span><br><span class="line">// TLS 客户端配置，包括证书和密钥</span><br><span class="line">TLSClientConfig</span><br><span class="line"></span><br><span class="line">// 每秒允许的请求数（Queries Per Second）。默认为 5.0。</span><br><span class="line">QPS float32</span><br><span class="line"></span><br><span class="line">// 突发请求数。默认为 10</span><br><span class="line">Burst int</span><br><span class="line"></span><br><span class="line">// 速率限制器，用于控制向 API 服务器发送请求的速率</span><br><span class="line">RateLimiter flowcontrol.RateLimiter</span><br><span class="line"></span><br><span class="line">// 与 API 服务器建立连接的超时时间</span><br><span class="line">Timeout time.Duration</span><br><span class="line"></span><br><span class="line">// 用于创建网络连接的 Dial 函数</span><br><span class="line">Dial func(ctx context.Context, network, address string) (net.Conn, error)</span><br><span class="line"></span><br><span class="line">// ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>tools&#x2F;clientcmd 工具</p><ul><li>源码位于 client-go&#x2F;tools&#x2F;clientcmd 包下</li><li>clientcmd 是 Kubernetes Go 客户端库（client-go）中的一个包，用于加载和解析 Kubernetes 配置文件，并辅助创建与 Kubernetes API 服务器进行通信的客户端。</li><li>clientcmd 提供了一些功能，使得在客户端应用程序中处理 Kubernetes 配置变得更加方便。主要包含以下几个方面的功能：<ul><li>加载配置文件：clientcmd 可以根据指定的路径加载 Kubernetes 配置文件，例如 kubeconfig 文件。</li><li>解析配置文件：一旦加载了配置文件，clientcmd 提供了解析配置文件的功能，可以获取各种配置信息，如集群信息、认证信息、上下文信息等。</li><li>辅助创建客户端：clientcmd 可以使用配置文件中的信息，辅助创建与 Kubernetes API 服务器进行通信的客户端对象。这些客户端对象可以用来执行对 Kubernetes 资源的增删改查操作。</li><li>切换上下文：clientcmd 还支持在多个上下文之间进行切换。上下文表示一组命名空间、集群和用户的组合，用于确定客户端与哪个Kubernetes 环境进行通信。</li></ul></li></ul></li></ul><h2 id="RESTClient使用示例"><a href="#RESTClient使用示例" class="headerlink" title="RESTClient使用示例"></a>RESTClient使用示例</h2><p>需求：获取default命名空间下的所有pod，并打印所有pod的name</p><p>代码编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">v1 &quot;k8s.io/api/core/v1&quot;</span><br><span class="line">&quot;k8s.io/client-go/kubernetes/scheme&quot;</span><br><span class="line">&quot;k8s.io/client-go/rest&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 在你机器的homeDir下，放入集群的config文件，用于连接集群（可以直接从集群master的~/.kube/config拷贝过来）</span><br><span class="line">// clientcmd是位于client-go/tools/clientcmd目录下的工具</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, clientcmd.RecommendedHomeFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">// 设置默认 GroupVersion（我要操作的是pod，不属于任何的group，所以使用了SchemeGroupVersion。你要操作什么，就写什么GroupVersion即可）</span><br><span class="line">config.GroupVersion = &amp;v1.SchemeGroupVersion</span><br><span class="line"></span><br><span class="line">// 设置序列化/反序列化器（后面的 Into方法 就是使用它完成 反序列化 的）</span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs</span><br><span class="line"></span><br><span class="line">// 设置 API 根的子路径（我们操作的是pod，属于core资源，所以设置为/api）</span><br><span class="line">config.APIPath = &quot;/api&quot;</span><br><span class="line"></span><br><span class="line">// 创建一个 RESTClient</span><br><span class="line">restClient, err := rest.RESTClientFor(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个Pod，用于接收请求结果</span><br><span class="line">pods := v1.PodList&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 链式编程 发送请求，并反序列化结果到pod中</span><br><span class="line">err = restClient.Get().Namespace(v1.NamespaceDefault).Resource(&quot;pods&quot;).Do(context.TODO()).Into(&amp;pods)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印pod名称</span><br><span class="line">for _, pod := range pods.Items &#123;</span><br><span class="line">println(pod.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>输出结果</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cassandra-5hbf7</span><br><span class="line">liveness-exec</span><br><span class="line">mysql-87pgn</span><br><span class="line">myweb-7f8rh</span><br><span class="line">myweb-rjblc</span><br><span class="line">nginx-pod-node1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator开发 Client-go篇</title>
      <link href="/posts/4a17d0001.html"/>
      <url>/posts/4a17d0001.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学习-client-go"><a href="#为什么要学习-client-go" class="headerlink" title="为什么要学习 client-go"></a>为什么要学习 client-go</h2><p>为了适应更多的业务场景，k8s提供了很多的扩展点，用于满足更复杂的需求。K8s的扩展点如下：</p><ul><li><p>① kubectl</p><ul><li>用户通过kubectl与ApiServer进行交互，kubectl提供了插件，可以扩展kubectl的行为，但是这些插件只能影响用户本地的环境</li></ul></li><li><p>② API Server</p><ul><li>处理所有的请求，可以对用户请求进行 身份认证、基于其内容阻止请求、编辑请求内容、处理删除操作等等。这个扩展点应该说的是：用户可以 自定义 API Server</li></ul></li><li><p>③ k8s提供的内置资源</p><ul><li>我们无法修改，只能通过 annotation、label 控制他们</li></ul></li><li><p>④ CRD</p><ul><li>自定义资源，配合 自定义控制器Custom Controller，扩展k8s的特定业务场景</li></ul></li><li><p>⑤ scheduler</p><ul><li>调度器，决定k8s把Pod放到哪个节点执行。k8s提供了多种方式扩展调度行为</li></ul></li><li><p>⑥ Controller Manager</p><ul><li>实际上也是k8s的一个客户端，通过与API Server交互。k8s的每种资源都有对应的控制器，都属于ControllerManager</li><li>client-go本质上就是一个与apiserver交互的库，所以Controller Manager也是通过 client-go 库与 API Server交互的</li></ul></li><li><p>⑦ Custom Controller</p><ul><li>自定义控制器，可以控制 内置资源，也可以控制自定义资源CRD</li></ul></li><li><p>⑧ kubelet</p><ul><li>使用CNI：使得k8s可以使用不同技术，连接Pod网络</li><li>使用CSI：使得k8s可以支持不同的存储类型</li><li>使用CRI：使得k8s可以支持不同的容器运行时</li></ul></li><li><p>⑨ client-go</p><ul><li>一个通用的Golang库，用于和 apiserver 交互</li><li>不管是k8s的各个组件，还是我们自己为CRD开发Custom Controller，都需要使用 client-go 与 API Server 进行通信</li></ul></li></ul><h2 id="client-go与kubernetes版本对应关系"><a href="#client-go与kubernetes版本对应关系" class="headerlink" title="client-go与kubernetes版本对应关系"></a>client-go与kubernetes版本对应关系</h2><p>我们假设前提：kubernetes版本为 v1.x.y</p><ul><li>kubernetes版本 &gt;&#x3D; v1.17.0时，client-go 版本使用 v0.x.y</li><li>kubernetes版本 &lt; v1.17.0时，client-go 版本使用 v1.x.y</li></ul><h2 id="client-go架构"><a href="#client-go架构" class="headerlink" title="client-go架构"></a>client-go架构</h2><h3 id="client-go-源代码目录介绍"><a href="#client-go-源代码目录介绍" class="headerlink" title="client-go 源代码目录介绍"></a>client-go 源代码目录介绍</h3><p>github地址：<a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a></p><ul><li>discovery：用于发现API Server都是支持哪些API。kubectl apiversions使用了同样的机制</li><li>dynamic：包含了kubernetes dynamic client的逻辑，可以操作任意的k8s资源API对象，包括内置的、自定义的资源对象</li><li>informers：包含了所有内置资源的informer，便于操作k8s的资源对象</li><li>kubernetes：包含了访问Kubernetes API的 所有ClientSet</li><li>listers：包含了所有内置资源的lister，用于读取缓存中k8s资源对象的信息</li><li>plugin&#x2F;pkg&#x2F;client&#x2F;auth：包含所有可选的认证插件，用于从外部获取credential（凭证）</li><li>tools：包含一系列工具，编写控制器时会用到很多里面的工具方法</li><li>transport：包含了创建连接、认证的逻辑，会被上层的ClientSet使用</li></ul><h3 id="client-go-架构"><a href="#client-go-架构" class="headerlink" title="client-go 架构"></a>client-go 架构</h3><p>下面先介绍各组件整体的运转流程，然后对 client-go 和 一个 CRDController 应该包含哪些组件进行详细介绍。</p><p>1、整体流程简介：</p><ul><li>Reflector会持续监听k8s集群中指定资源类型的API，当发现变动和更新时，就会创建一个发生变动的 对象副本，并将其添加到队列DeltaFIFO中</li><li>Informer监听DeltaFIFO队列，取出对象，做两件事：<ul><li>（1）将对象加入Indexer，Indexer 会将 [对象key, 对象] 存入一个线程安全的Cache中</li><li>（2）根据对象的 资源类型和操作，找到对应 Controller 预先提供的 Resource Event Handler，调用Handler，将对象的Key加入该 Controller 的 Workqueue</li><li>Controller 的循环函数 ProcessItem，监听到 Workqueue 有数据了，就会取出一个key，交给处理函数Worker，Worker 会根据 Key，使用 Indexer reference 从 Cache 中 获取 该key对应的 真实对象。然后就可以进行调谐了。<br>注意点</li></ul></li><li>DeltaFIFO 中 存的是 对象副本</li><li>Cache 中 存的是 [对象key, 对象] 的映射</li><li>Workqueue 中存的是 对象Key</li><li>CRDController 中，使用Informer对象，是为了向其中添加一些 Resource Event Handlers</li><li>CRDController 中，使用Indexer对象，是为了根据对象Key，获取对象实例</li></ul><p>2、client-go组件</p><ul><li>Reflector<ul><li>reflector会一直监听kubernetes中指定资源类型的API，实现监听的函数就是ListAndWatch。这种监听机制既适用于k8s的内建资源，也适用于自定义资源。</li><li>当reflector通过监听API发现资源对象实例存在新的 notification 时，它就会使用 listing API 获取这个新的实例对象，并将其放入 watchHandler 函数内的 DeltaFIFO 中；</li></ul></li><li>Informer<ul><li>Informer 会从 Delta FIFO 中取出对象。实现这个功能的方法对应源码中的 processLoop；</li><li>Informer 取出对象后，根据Resource类型，调用对应的 Resource Event Handler 回调函数，该函数实际上由某个具体的 Controller 提供，函数中会获取对象的 key，并将 key 放入到 该Controller 内部的 Workqueue 中，等候处理。</li></ul></li><li>Indexer 和 Thread Safe Store<ul><li>Indexer 会提供对象的索引功能，通常是基于对象Key来创建索引。默认索引函数是MetaNamespaceKeyFunc， 它生成的索引键为&#x2F;格式。</li><li>Indexer 维护着一个线程安全的 Cache，即 Thread Safe Store。存储的是[对象key, 对象]，用对象Key可以进行获取对象实例。</li></ul></li><li>Resource Event Handlers reference<ul><li>这实际上是所有Controller的Resource Event Handlers的引用。</li><li>这些 handlers 由具体的Controller提供，就是 Informer 的回调函数。Informer 会根据资源的类型，调用对应Controller的 handler 方法</li><li>handler 通常都是用于将资源对象的key放入到 该Controller 内部的 Workqueue 中，等候处理。<br>3、自定义控制器组件</li></ul></li><li>Informer reference<ul><li>Informer reference 是 Informer 实例对象的引用，用于操作和处理自定义资源对象</li><li>我们编写自定义控制器时，需要引用自己需要的Informer，向其中加入一系列 Resource Event Handlers</li></ul></li><li>Indexer reference<ul><li>Indexer reference 是 Indexer实例对象的引用，用于根据对象Key索引资源对象</li><li>我们编写自定义控制器时，应该创建Indexer的引用，将对象Key传给它，就可以获取想要处理的对象</li><li>NewIndexerInformer函数<ul><li>client-go中的基本控制器提供了 NewIndexerInformer 函数，用于创建Informer和Indexer。</li><li>可以直接使用NewIndexerInformer 函数，或者也可以使用工厂方法来创建Informer</li></ul></li></ul></li><li>Resource Event Handlers<ul><li>由具体的 Controller 给 Client-go 的Informer 提供的回调函数，获取待处理对象的key，并将key放入到Workqueue中。</li></ul></li><li>Workqueue<ul><li>此队列是 具体的Controller 内部创建的队列，用于暂时存储从Resource event handler 中 传递过来的，待处理对象的Key。</li><li>Resource event handler 函数通常会获取待处理对象的key，并将key放入到这个workqueue中。</li></ul></li><li>Process Item<ul><li>这个函数为循环函数，它不断从 Work queue 中取出对象的key，并使用 Indexer Reference 获取这个key对应的具体资源对象，然后根据资源的变化，做具体的调谐 Reconcile 动作。</li></ul></li></ul><h3 id="使用client-go编写Controller的步骤"><a href="#使用client-go编写Controller的步骤" class="headerlink" title="使用client-go编写Controller的步骤"></a>使用client-go编写Controller的步骤</h3><p>编写一个 自定义Controller，需要实现如下功能。</p><ul><li>先从client-go中获取对应资源的 Informer</li><li>提供 一系列的 Resource event handlers，并加入对应的Informer，供该informer回调</li><li>提供一个 Workqueue 队列，存储待处理的对象的Key</li><li>提供一个 循环函数 ProcessItem，不断从 Workqueue 中取出对象的key，交给 处理函数 Worker</li><li>提供一个 处理函数 Worker，根据对象Key，使用对应资源的Indexer，获取到该对象的实例，根据对象的属性变化，做真正的调谐过程。</li></ul><h2 id="client-go的client组件"><a href="#client-go的client组件" class="headerlink" title="client-go的client组件"></a>client-go的client组件</h2><p>client-go 主要提供了4种 client 组件：</p><ul><li>RESTClient：最基础的客户端，提供最基本的封装，可以通过它组装与API Server即时通讯时 的 url</li><li>Clientset：是一个Client的集合，在Clientset中包含了所有K8S内置资源 的 Client，通过Clientset便可以很方便的操作如Pod、Service这些资源</li><li>dynamicClient：动态客户端，可以操作任意K8S的资源，包括CRD定义的资源</li><li>DiscoveryClient：用于发现K8S提供的资源组、资源版本和资源信息，比如：kubectl api-resources</li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator开发 前置知识</title>
      <link href="/posts/4a17d0000.html"/>
      <url>/posts/4a17d0000.html</url>
      
        <content type="html"><![CDATA[<h2 id="Operator是什么"><a href="#Operator是什么" class="headerlink" title="Operator是什么"></a>Operator是什么</h2><ul><li>Operator 是 遵循 Kubernetes 的设计理念的一种扩展模式，它强调利用 定制 CR资源 去管理应用及其组件。</li><li>Operator 通过 将 应用程序的运维知识 转化为 可编程的代码，使我们能够定义和管理应用程序的整个生命周期，包括安装、配置、扩展、监控和升级等方面，进而以自动化的方式管理和运维复杂的应用程序。</li><li>一个Operator，主要包括两部分：自定义资源（Custom Resource） 和 控制器（Controller）</li><li>Operator核心原理是 声明式配置 和 状态驱动。您可以定义自定义资源的规范（Spec）和状态（Status），Operator会根据这些定义来自动化地管理应用程序。它可以监测资源的变化，识别和处理故障，以及根据配置和策略自动扩展应用程序。</li></ul><h2 id="开发一个Kubernetes-Operator的步骤"><a href="#开发一个Kubernetes-Operator的步骤" class="headerlink" title="开发一个Kubernetes Operator的步骤"></a>开发一个Kubernetes Operator的步骤</h2><h3 id="定义自定义资源"><a href="#定义自定义资源" class="headerlink" title="定义自定义资源"></a>定义自定义资源</h3><ul><li>使用Kubernetes的自定义资源定义语言（CRD），定义一个自定义资源来描述您的应用程序。</li><li>除了必备的TypeMeta、ObjectMeta，CRD中还应包含 资源规范Spec 和 资源状态Status 字段。<br>  创建Operator</li><li>编写一个自定义的控制器（Controller），用于监控和处理您定义的CR。</li><li>当用户创建或修改CR时，Controller 能够 获取到用户修改后的CR，并根据CR中Metadata、Spec等字段的变化，执行必要的操作，处理完后还要将CR的状态信息写入Status字段中，供用户查看。</li></ul><h3 id="部署Operator"><a href="#部署Operator" class="headerlink" title="部署Operator"></a>部署Operator</h3><ul><li>部署Operator包括两部分：安装CRD，部署Controller</li><li>安装CRD：将CRD应用到集群中，使kubernetes集群能够识别到该资源</li><li>部署Controller：Controller 通常会在control plane之外运行，就像运行任何容器化的应用程序一样。例如，将controller打包成镜像，以 Deployment 运行。</li></ul><h3 id="创建和管理自定义资源实例"><a href="#创建和管理自定义资源实例" class="headerlink" title="创建和管理自定义资源实例"></a>创建和管理自定义资源实例</h3><ul><li>使用 kubectl 或 编写yaml 创建CR的实例</li><li>使用 kubectl 或 其他kubernetes客户端工具 管理CR</li></ul>]]></content>
      
      
      <categories>
          
          <category> operator开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operator开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s源代码走读之Kubelet-Proxy</title>
      <link href="/posts/4a17b711.html"/>
      <url>/posts/4a17b711.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Kubernetes 生态系统中，Operator 是一种用于自动化应用程序和服务的运维任务的软件控制器。Operator 可以帮助开发者以声明性的方式定义、部署和管理应用程序。本文将深入介绍 Kubernetes Operator 的打包与部署过程，包括常用的打包工具、部署策略以及详细示例。</p><h2 id="Operator-打包工具"><a href="#Operator-打包工具" class="headerlink" title="Operator 打包工具"></a>Operator 打包工具</h2><p>为了便于部署和分享 Operator，通常需要将其打包成一个可执行的容器镜像。下面介绍两种常用的 Operator 打包工具。</p><h3 id="Operator-SDK"><a href="#Operator-SDK" class="headerlink" title="Operator SDK"></a>Operator SDK</h3><p>Operator SDK 是由 Operator 框架提供的一个命令行工具，用于简化 Operator 的开发、测试和部署。它提供了 init、create、build、run 等命令，帮助开发者快速构建 Operator 项目，并将其打包为容器镜像。</p><p>使用 Operator SDK 打包 Operator 的基本步骤：</p><ul><li><p>初始化项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk init --domain=example.com --repo=github.com/example/example-operator</span><br></pre></td></tr></table></figure></li><li><p>创建 API 资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk create api --group=example --version=v1alpha1 --kind=Example</span><br></pre></td></tr></table></figure></li><li><p>构建 Operator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk build example-operator</span><br></pre></td></tr></table></figure></li><li><p>推送镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push example-operator</span><br></pre></td></tr></table></figure></li></ul><h3 id="Kubebuilder"><a href="#Kubebuilder" class="headerlink" title="Kubebuilder"></a>Kubebuilder</h3><p>Kubebuilder 是另一个用于构建 Kubernetes Operator 的工具。它也提供了创建、测试和打包 Operator 的命令行工具。与 Operator SDK 类似，Kubebuilder 通过 make 工具来进行构建和打包。</p><p>使用 Kubebuilder 打包 Operator 的基本步骤：</p><ul><li><p>初始化项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder init --domain example.com</span><br></pre></td></tr></table></figure></li><li><p>创建 API 资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create api --group example --version v1alpha1 --kind Example</span><br></pre></td></tr></table></figure></li><li><p>构建 Operator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make manager</span><br></pre></td></tr></table></figure></li><li><p>推送镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t example-operator .</span><br><span class="line">docker tag example-operator example.com/example-operator:latest</span><br><span class="line">docker push example.com/example-operator:latest</span><br></pre></td></tr></table></figure></li></ul><h2 id="Operator-部署策略"><a href="#Operator-部署策略" class="headerlink" title="Operator 部署策略"></a>Operator 部署策略</h2><p>Operator 部署的方式多种多样，可以选择合适的策略来满足实际需求。以下是一些常见的 Operator 部署策略：</p><h3 id="Helm-Charts"><a href="#Helm-Charts" class="headerlink" title="Helm Charts"></a>Helm Charts</h3><p>Helm 是 Kubernetes 中常用的包管理工具，可以用来打包、发布和管理 Kubernetes 应用。通过 Helm Charts，可以将 Operator 打包成 Helm Chart，并通过 Helm 进行部署。</p><p>步骤：</p><ul><li><p>创建 Helm Chart：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create example-operator</span><br></pre></td></tr></table></figure></li><li><p>将 Operator 打包到 Helm Chart 中。</p></li><li><p>部署 Operator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install example-operator ./example-operator</span><br></pre></td></tr></table></figure></li></ul><h3 id="Kustomize"><a href="#Kustomize" class="headerlink" title="Kustomize"></a>Kustomize</h3><p>Kustomize 是 Kubernetes 官方提供的配置管理工具，用于定制化 Kubernetes 配置文件。通过 Kustomize，可以灵活地定制 Operator 的配置，并进行部署。</p><p>步骤：</p><ul><li><p>创建 Kustomization 文件。</p></li><li><p>在 Kustomization 文件中引入 Operator 配置。</p></li><li><p>部署 Operator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -k .</span><br></pre></td></tr></table></figure></li></ul><h3 id="Operator-Lifecycle-Manager-OLM"><a href="#Operator-Lifecycle-Manager-OLM" class="headerlink" title="Operator Lifecycle Manager (OLM)"></a>Operator Lifecycle Manager (OLM)</h3><p>OLM 是由 Red Hat 提供的 Operator 生命周期管理工具，用于简化 Operator 的安装、更新和卸载。OLM 可以通过 Operator 的 Catalog 来进行 Operator 的发现和安装。</p><p>步骤：</p><ul><li><p>创建 Operator 的 Catalog。</p></li><li><p>在 OLM 中注册 Catalog。</p></li><li><p>使用 OLM 安装 Operator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f operator-installation.yaml</span><br></pre></td></tr></table></figure></li></ul><h2 id="Operator-部署示例"><a href="#Operator-部署示例" class="headerlink" title="Operator 部署示例"></a>Operator 部署示例</h2><p>下面通过一个简单的示例演示如何使用 Operator SDK 将一个 Operator 打包成容器镜像，并通过 Helm Charts 部署。<br>示例：创建一个简单的 Nginx Operator</p><ul><li><p>使用 Operator SDK 初始化项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk init --domain=example.com --repo=github.com/example/nginx-operator</span><br></pre></td></tr></table></figure></li><li><p>创建 Nginx 资源 API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk create api --group=nginx --version=v1alpha1 --kind=Nginx</span><br></pre></td></tr></table></figure></li><li><p>在 controllers&#x2F;nginx_controller.go 中实现业务逻辑。</p></li><li><p>构建并推送 Operator 镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk build nginx-operator</span><br><span class="line">docker push nginx-operator</span><br></pre></td></tr></table></figure></li><li><p>使用 Helm 创建 Helm Chart：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create nginx-operator-chart</span><br></pre></td></tr></table></figure></li><li><p>编辑 Helm Chart 中的配置文件，指定 Operator 的镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deployment.yaml:</span><br><span class="line"></span><br><span class="line">containers:</span><br><span class="line">- name: nginx-operator</span><br><span class="line">  image: nginx-operator:latest</span><br></pre></td></tr></table></figure></li><li><p>部署 Helm Chart：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install nginx-operator ./nginx-operator-chart</span><br></pre></td></tr></table></figure></li></ul><p>通过以上步骤，就成功创建并部署了一个简单的 Nginx Operator。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Kubernetes Operator 的打包与部署是实现自动化运维的重要步骤。本文详细介绍了两种常用的 Operator 打包工具（Operator SDK 和 Kubebuilder）以及几种常见的 Operator 部署策略（Helm Charts、Kustomize、OLM）。通过示例演示了如何使用 Operator SDK 创建一个简单的 Nginx Operator，并通过 Helm Charts 进行部署。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s中的informer机制</title>
      <link href="/posts/4a17b710.html"/>
      <url>/posts/4a17b710.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Kubernetes 集群中，Informer 是一种重要的机制，用于监控和处理集群中资源对象的变化。它是基于观察者模式设计的，允许开发者注册对某类资源对象的关注，并在对象发生变化时得到通知。本文将深入介绍 Kubernetes 中的 Informer 机制，包括其设计思想、工作原理、示例和最佳实践。</p><h2 id="什么是-Informer？"><a href="#什么是-Informer？" class="headerlink" title="什么是 Informer？"></a>什么是 Informer？</h2><p>Informer 是 Kubernetes 中用于监控和处理资源对象变化的框架。它建立在 Kubernetes 的客户端库 client-go 之上，提供了高级别的 API，简化了开发者对资源对象状态变化的监听和处理。</p><p>Informer 的核心思想是将对资源对象的监听和处理逻辑进行模块化，以便更容易地维护和扩展。通过 Informer，开发者可以注册关注的资源类型，并在资源状态发生变化时执行自定义的业务逻辑。<br>Informer 的工作原理</p><p>Informer 机制的核心工作原理主要包括以下几个步骤：</p><ul><li>List-Watch 机制： Informer 使用 Kubernetes API 的 List-Watch 机制来获取资源对象的初始列表，并通过 Watch 机制实时接收对象的变化事件。</li><li>SharedInformerFactory： SharedInformerFactory 是 Informer 的工厂，负责创建和管理多个 SharedInformer。每个 SharedInformer 监听一种资源对象的变化。</li><li>Event Handlers： 开发者可以注册事件处理器（Event Handlers），在资源对象发生变化时触发相应的处理逻辑。Event Handlers 是 Informer 的核心扩展点，用于实现自定义的业务逻辑。</li><li>Delta FIFO Queue： 通过 Delta FIFO Queue，Informer 在收到资源对象的变化事件时，将事件推送到队列中。Event Handlers 从队列中取出事件进行处理。</li><li>Resync： Informer 支持定期的全量同步（Resync）机制，以确保本地缓存与实际状态的一致性。定期地对资源对象进行全量同步，更新本地缓存。</li></ul><h2 id="如何使用-Informer"><a href="#如何使用-Informer" class="headerlink" title="如何使用 Informer"></a>如何使用 Informer</h2><h3 id="创建-SharedInformerFactory"><a href="#创建-SharedInformerFactory" class="headerlink" title="创建 SharedInformerFactory"></a>创建 SharedInformerFactory</h3><p>首先，创建一个 SharedInformerFactory 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">informerFactory := informers.NewSharedInformerFactory(clientset, time.Second*30)</span><br></pre></td></tr></table></figure><h3 id="注册关注的资源类型"><a href="#注册关注的资源类型" class="headerlink" title="注册关注的资源类型"></a>注册关注的资源类型</h3><p>使用 SharedInformerFactory 注册对某一种资源类型的关注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">podInformer := informerFactory.Core().V1().Pods()</span><br></pre></td></tr></table></figure><h3 id="注册-Event-Handlers"><a href="#注册-Event-Handlers" class="headerlink" title="注册 Event Handlers"></a>注册 Event Handlers</h3><p>注册事件处理器，定义在资源对象发生变化时的处理逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">    AddFunc: func(obj interface&#123;&#125;) &#123;</span><br><span class="line">        // 处理资源对象新增事件</span><br><span class="line">        pod := obj.(*corev1.Pod)</span><br><span class="line">        fmt.Printf(&quot;Pod added: %s\n&quot;, pod.Name)</span><br><span class="line">    &#125;,</span><br><span class="line">    UpdateFunc: func(oldObj, newObj interface&#123;&#125;) &#123;</span><br><span class="line">        // 处理资源对象更新事件</span><br><span class="line">        oldPod := oldObj.(*corev1.Pod)</span><br><span class="line">        newPod := newObj.(*corev1.Pod)</span><br><span class="line">        fmt.Printf(&quot;Pod updated: %s\n&quot;, newPod.Name)</span><br><span class="line">    &#125;,</span><br><span class="line">    DeleteFunc: func(obj interface&#123;&#125;) &#123;</span><br><span class="line">        // 处理资源对象删除事件</span><br><span class="line">        pod := obj.(*corev1.Pod)</span><br><span class="line">        fmt.Printf(&quot;Pod deleted: %s\n&quot;, pod.Name)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="启动-Informer"><a href="#启动-Informer" class="headerlink" title="启动 Informer"></a>启动 Informer</h3><p>启动 SharedInformerFactory，开始监听资源对象的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">informerFactory.Start(stopCh)</span><br></pre></td></tr></table></figure><h3 id="处理资源对象变化事件"><a href="#处理资源对象变化事件" class="headerlink" title="处理资源对象变化事件"></a>处理资源对象变化事件</h3><p>在 Event Handlers 中定义的逻辑将在资源对象发生变化时被触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-stopCh</span><br></pre></td></tr></table></figure><p>通过以上步骤，就可以使用 Informer 监听和处理 Kubernetes 集群中资源对象的变化。</p><h3 id="示例：使用-Informer-监听-Pod-变化"><a href="#示例：使用-Informer-监听-Pod-变化" class="headerlink" title="示例：使用 Informer 监听 Pod 变化"></a>示例：使用 Informer 监听 Pod 变化</h3><p>下面是一个简单的示例，演示如何使用 Informer 监听 Pod 对象的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;os/signal&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/cache&quot;</span><br><span class="line">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="line">&quot;k8s.io/client-go/util/homedir&quot;</span><br><span class="line">&quot;k8s.io/client-go/util/wait&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var kubeconfig *string</span><br><span class="line">if home := homedir.HomeDir(); home != &quot;&quot; &#123;</span><br><span class="line">kubeconfig = flag.String(&quot;kubeconfig&quot;, home+&quot;/.kube/config&quot;, &quot;kubeconfig file&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">kubeconfig = flag.String(&quot;kubeconfig&quot;, &quot;&quot;, &quot;kubeconfig file&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *kubeconfig)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopCh := make(chan struct&#123;&#125;)</span><br><span class="line">defer close(stopCh)</span><br><span class="line"></span><br><span class="line">informerFactory := cache.NewSharedInformerFactory(clientset, time.Second*30)</span><br><span class="line">podInformer := informerFactory.Core().V1().Pods()</span><br><span class="line"></span><br><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: func(obj interface&#123;&#125;) &#123;</span><br><span class="line">pod := obj.(*corev1.Pod)</span><br><span class="line">fmt.Printf(&quot;Pod added: %s\n&quot;, pod.Name)</span><br><span class="line">&#125;,</span><br><span class="line">UpdateFunc: func(oldObj, newObj interface&#123;&#125;) &#123;</span><br><span class="line">oldPod := oldObj.(*corev1.Pod)</span><br><span class="line">newPod := newObj.(*corev1.Pod)</span><br><span class="line">fmt.Printf(&quot;Pod updated: %s\n&quot;, newPod.Name)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: func(obj interface&#123;&#125;) &#123;</span><br><span class="line">pod := obj.(*corev1.Pod)</span><br><span class="line">fmt.Printf(&quot;Pod deleted: %s\n&quot;, pod.Name)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">go informerFactory.Start(stopCh)</span><br><span class="line">if !cache.WaitForCacheSync(stopCh, podInformer.Informer().HasSynced) &#123;</span><br><span class="line">fmt.Println(&quot;Timed out waiting for caches to sync&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Informer started. Waiting for Pod events...&quot;)</span><br><span class="line"></span><br><span class="line">c := make(chan os.Signal, 1)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line">&lt;-c</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Received interrupt signal. Stopping Informer...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Informer 机制是 Kubernetes 中强大且灵活的一部分，为开发者提供了便捷的方式监听和处理集群中资源对象的变化。通过 SharedInformerFactory 的注册和 Event Handlers 的定义，可以轻松实现对特定资源类型的关注和处理逻辑。Informer 的应用范围广泛，涉及到许多领域，包括控制器开发、自动伸缩、日志收集等。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端client-go的使用</title>
      <link href="/posts/4a17b709.html"/>
      <url>/posts/4a17b709.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Kubernetes 集群中进行资源的创建、更新和查询是日常运维和开发中常见的任务。为了简化这些操作，Kubernetes 提供了 client-go 这个官方的 Go 客户端库。client-go 封装了与 Kubernetes API 服务器的交互，提供了便捷的方式进行各种资源的管理。本文将详细介绍 client-go 的使用方法，并通过示例演示如何利用该库进行 Kubernetes 操作。</p><h2 id="安装-client-go"><a href="#安装-client-go" class="headerlink" title="安装 client-go"></a>安装 client-go</h2><p>client-go 是一个 Go 模块，可以使用 Go Module 的方式进行安装。在你的 Go 项目中，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get k8s.io/client-go@latest</span><br></pre></td></tr></table></figure><p>这将安装最新版本的 client-go。在代码中引入 client-go 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="line">import &quot;k8s.io/client-go/tools/clientcmd&quot;</span><br></pre></td></tr></table></figure><h2 id="创建-Kubernetes-客户端"><a href="#创建-Kubernetes-客户端" class="headerlink" title="创建 Kubernetes 客户端"></a>创建 Kubernetes 客户端</h2><p>在使用 client-go 之前，首先需要创建一个 Kubernetes 客户端。client-go 提供了两种创建客户端的方式：in-cluster 配置和 out-of-cluster 配置。</p><h3 id="In-Cluster-配置"><a href="#In-Cluster-配置" class="headerlink" title="In-Cluster 配置"></a>In-Cluster 配置</h3><p>在 Kubernetes Pod 内运行时，可以使用 in-cluster 配置。这种方式不需要手动指定 kubeconfig 文件路径，client-go 会自动使用集群中的服务账户进行身份验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config, err := rest.InClusterConfig()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Out-of-Cluster-配置"><a href="#Out-of-Cluster-配置" class="headerlink" title="Out-of-Cluster 配置"></a>Out-of-Cluster 配置</h3><p>在本地开发环境或其他非 Kubernetes 集群中运行时，可以使用 out-of-cluster 配置。这需要指定 kubeconfig 文件的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeconfig := &quot;/path/to/kubeconfig&quot;</span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, kubeconfig)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-client-go-进行基本操作"><a href="#使用-client-go-进行基本操作" class="headerlink" title="使用 client-go 进行基本操作"></a>使用 client-go 进行基本操作</h3><h3 id="列出所有的-Pod"><a href="#列出所有的-Pod" class="headerlink" title="列出所有的 Pod"></a>列出所有的 Pod</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pods, err := clientset.CoreV1().Pods(&quot;default&quot;).List(context.Background(), metav1.ListOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, pod := range pods.Items &#123;</span><br><span class="line">    fmt.Printf(&quot;Pod: %s\n&quot;, pod.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个-Deployment"><a href="#创建一个-Deployment" class="headerlink" title="创建一个 Deployment"></a>创建一个 Deployment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">deployment := &amp;appsv1.Deployment&#123;</span><br><span class="line">    ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">        Name: &quot;example-deployment&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spec: appsv1.DeploymentSpec&#123;</span><br><span class="line">        Replicas: int32Ptr(3),</span><br><span class="line">        Selector: &amp;metav1.LabelSelector&#123;</span><br><span class="line">            MatchLabels: map[string]string&#123;</span><br><span class="line">                &quot;app&quot;: &quot;example&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Template: corev1.PodTemplateSpec&#123;</span><br><span class="line">            ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">                Labels: map[string]string&#123;</span><br><span class="line">                    &quot;app&quot;: &quot;example&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            Spec: corev1.PodSpec&#123;</span><br><span class="line">                Containers: []corev1.Container&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Name:  &quot;nginx&quot;,</span><br><span class="line">                        Image: &quot;nginx:latest&quot;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = clientset.AppsV1().Deployments(&quot;default&quot;).Create(context.Background(), deployment, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新一个-Service"><a href="#更新一个-Service" class="headerlink" title="更新一个 Service"></a>更新一个 Service</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service, err := clientset.CoreV1().Services(&quot;default&quot;).Get(context.Background(), &quot;example-service&quot;, metav1.GetOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service.Spec.Ports[0].Port = 8080</span><br><span class="line"></span><br><span class="line">_, err = clientset.CoreV1().Services(&quot;default&quot;).Update(context.Background(), service, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除一个-Namespace"><a href="#删除一个-Namespace" class="headerlink" title="删除一个 Namespace"></a>删除一个 Namespace</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = clientset.CoreV1().Namespaces().Delete(context.Background(), &quot;example-namespace&quot;, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>client-go 是 Kubernetes 官方提供的 Go 客户端库，提供了便捷的方式进行 Kubernetes 资源的管理。通过创建客户端并使用相应的 API 客户端进行操作，我们可以轻松地进行 Pod、Deployment、Service 等资源的增删改查。在实际开发和运维中，合理利用 client-go 可以提高工作效率，确保应用程序和服务在 Kubernetes 集群中的正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发自定义控制器</title>
      <link href="/posts/4a17b708.html"/>
      <url>/posts/4a17b708.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>KubeBuilder 是一套用于简化 Kubernetes 控制器和 Operator 开发的框架和工具集，它的设计理念是“约定优于配置”，旨在提供更便捷的开发体验。本文将详细介绍如何使用 KubeBuilder 开发自定义 Controller，并通过一个实际示例演示每个步骤。</p><h2 id="KubeBuilder-开发流程"><a href="#KubeBuilder-开发流程" class="headerlink" title="KubeBuilder 开发流程"></a>KubeBuilder 开发流程</h2><p>KubeBuilder 的开发流程主要包括以下步骤：</p><ul><li>项目初始化： 使用 KubeBuilder 初始化项目，创建基础文件结构和代码骨架。</li><li>定义 API 对象： 使用 KubeBuilder CLI 创建 API 对象，即自定义资源的规范。</li><li>实现控制器逻辑： 编写控制器的业务逻辑，包括处理自定义资源的创建、更新和删除等操作。</li><li>生成代码： 使用 KubeBuilder 提供的命令生成代码，包括 CRD 定义、API 对象的 DeepCopy 方法、以及控制器的代码。</li><li>运行控制器： 将生成的控制器运行在 Kubernetes 集群中，观察控制器对资源变化的响应。</li></ul><p>现在，让我们通过一个具体的示例来演示这个流程。</p><h2 id="示例：开发一个简单的-Todo-控制器"><a href="#示例：开发一个简单的-Todo-控制器" class="headerlink" title="示例：开发一个简单的 Todo 控制器"></a>示例：开发一个简单的 Todo 控制器</h2><h3 id="步骤-1：项目初始化"><a href="#步骤-1：项目初始化" class="headerlink" title="步骤 1：项目初始化"></a>步骤 1：项目初始化</h3><p>使用以下命令初始化一个 KubeBuilder 项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder init --domain example.com</span><br></pre></td></tr></table></figure><p>这将在当前目录下创建一个新的项目，并生成基础的文件结构。</p><h3 id="步骤-2：定义-API-对象"><a href="#步骤-2：定义-API-对象" class="headerlink" title="步骤 2：定义 API 对象"></a>步骤 2：定义 API 对象</h3><p>使用以下命令创建一个名为 Todo 的 API 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubebuilder create api --group todo --version v1alpha1 --kind Todo</span><br></pre></td></tr></table></figure><p>这将生成 api&#x2F;v1alpha1&#x2F;todo_types.go 文件，其中包含了 Todo 对象的定义。</p><h3 id="步骤-3：实现控制器逻辑"><a href="#步骤-3：实现控制器逻辑" class="headerlink" title="步骤 3：实现控制器逻辑"></a>步骤 3：实现控制器逻辑</h3><p>打开 controllers&#x2F;todo_controller.go 文件，实现 Todo 控制器的逻辑。在 Reconcile 方法中，可以处理 Todo 对象的创建、更新和删除等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// controllers/todo_controller.go</span><br><span class="line"></span><br><span class="line">// +kubebuilder:rbac:groups=todo.example.com,resources=todos,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">// +kubebuilder:rbac:groups=todo.example.com,resources=todos/status,verbs=get;update;patch</span><br><span class="line"></span><br><span class="line">// Reconcile handles Todo objects</span><br><span class="line">func (r *TodoReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">    log := r.Log.WithValues(&quot;todo&quot;, req.NamespacedName)</span><br><span class="line"></span><br><span class="line">    // Fetch the Todo instance</span><br><span class="line">    var todo v1alpha1.Todo</span><br><span class="line">    if err := r.Get(ctx, req.NamespacedName, &amp;todo); err != nil &#123;</span><br><span class="line">        log.Error(err, &quot;unable to fetch Todo&quot;)</span><br><span class="line">        return ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Your business logic goes here</span><br><span class="line"></span><br><span class="line">    return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4：生成代码"><a href="#步骤-4：生成代码" class="headerlink" title="步骤 4：生成代码"></a>步骤 4：生成代码</h3><p>执行以下命令，生成 CRD 定义、API 对象的 DeepCopy 方法和控制器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="步骤-5：运行控制器"><a href="#步骤-5：运行控制器" class="headerlink" title="步骤 5：运行控制器"></a>步骤 5：运行控制器</h3><p>运行生成的控制器，使其监听并处理 Todo 对象的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure><p>至此，一个简单的 Todo 控制器就完成了，可以开始创建和管理 Todo 对象了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 KubeBuilder 开发自定义 Controller 是一种高效且规范的方式，它遵循约定优于配置的原则，使得开发者能够更专注于业务逻辑的实现。通过代码生成和模板化的设计，大大简化了控制器和 CRD 的开发流程。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚手架工具KubeBuilder</title>
      <link href="/posts/4a17b707.html"/>
      <url>/posts/4a17b707.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着 Kubernetes 的广泛应用，为了更好地支持自定义资源定义（CRD）和自动化运维，KubeBuilder 应运而生。KubeBuilder 是一套用于简化 Kubernetes 控制器和 Operator 开发的框架和工具集。本文将深入探讨 KubeBuilder 的历史发展、设计理念以及具体的使用方式，帮助开发者更好地理解和利用这一工具集。</p><h2 id="KubeBuilder-的历史发展"><a href="#KubeBuilder-的历史发展" class="headerlink" title="KubeBuilder 的历史发展"></a>KubeBuilder 的历史发展</h2><p>KubeBuilder 的发展始于 Kubernetes Operator 的兴起。在 Kubernetes 1.7 版本之前，开发者通常需要手动编写控制器代码，进行资源的监控和操作。这导致了大量的重复工作和代码冗余。为了解决这个问题，KubeBuilder 在社区的努力下逐渐成为 Kubernetes Operator 开发的事实标准。</p><p>关键的里程碑：</p><ul><li>2017 年： KubeBuilder 项目正式启动，最初是由 Google、Red Hat 和 Microsoft 共同推动的。其目标是为 Kubernetes Operator 提供一个一致的开发模型。</li><li>2018 年 5 月： KubeBuilder 1.0 版本发布，正式进入生产环境。</li><li>2019 年 5 月： KubeBuilder 成为 CNCF（Cloud Native Computing Foundation）的孵化项目，表明其在云原生生态系统中的重要性。</li><li>2021 年 1 月： KubeBuilder 2.0 发布，引入了更多功能和改进，进一步提升了开发体验。</li></ul><h2 id="KubeBuilder-的设计理念"><a href="#KubeBuilder-的设计理念" class="headerlink" title="KubeBuilder 的设计理念"></a>KubeBuilder 的设计理念</h2><p>KubeBuilder 的设计理念主要包括以下几个方面：</p><ul><li>约定优于配置</li></ul><p>KubeBuilder 遵循 “约定优于配置” 的原则，通过一系列的默认约定，简化了操作员和控制器的开发。这使得开发者无需手动编写大量的模板代码，减少了出错的可能性，提高了开发效率。</p><ul><li>CRD 和控制器的生成</li></ul><p>KubeBuilder 提供了用于生成 CRD 和控制器代码的命令行工具。通过这些工具，开发者可以根据自己定义的 API 对象，自动生成相应的 CRD 规范和控制器骨架。这样，开发者只需关注业务逻辑的实现，而无需关心繁琐的模板代码。</p><ul><li>可插拔的架构</li></ul><p>KubeBuilder 提供了可插拔的架构，允许开发者自定义控制器的行为。通过实现各种接口，开发者可以添加自己的业务逻辑，实现对 CRD 的定制化管理。</p><ul><li>集成了测试框架</li></ul><p>KubeBuilder 集成了测试框架，包括单元测试和集成测试。这使得开发者能够更容易地编写和运行测试用例，确保控制器的稳定性和正确性。</p><h2 id="KubeBuilder-的使用"><a href="#KubeBuilder-的使用" class="headerlink" title="KubeBuilder 的使用"></a>KubeBuilder 的使用</h2><ul><li>安装 KubeBuilder</li></ul><p>首先，需要安装 KubeBuilder CLI。可以通过以下命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装 KubeBuilder CLI</span><br><span class="line">curl -L https://go.kubebuilder.io/dl/2.3.1/$(go env GOOS)/$(go env GOARCH) | tar -xz -C /tmp/</span><br><span class="line">sudo mv /tmp/kubebuilder_2.3.1_$(go env GOOS)_$(go env GOARCH) /usr/local/kubebuilder</span><br><span class="line">export PATH=$PATH:/usr/local/kubebuilder/bin</span><br></pre></td></tr></table></figure><ul><li>创建一个新的 KubeBuilder 项目</li></ul><p>使用 KubeBuilder CLI 创建一个新的项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建项目</span><br><span class="line">kubebuilder init --domain example.com</span><br></pre></td></tr></table></figure><ul><li>创建一个新的 API 对象</li></ul><p>使用 KubeBuilder CLI 创建一个新的 API 对象（CRD）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建 API 对象</span><br><span class="line">kubebuilder create api --group batch --version v1 --kind CronJob</span><br></pre></td></tr></table></figure><p>这将在项目中生成一个 api&#x2F;v1&#x2F;cronjob_types.go 文件，其中包含了 CronJob 对象的定义。</p><ul><li>实现控制器逻辑</li></ul><p>在 controllers&#x2F; 目录下，可以找到一个名为 cronjob_controller.go 的文件。在这个文件中，开发者可以实现对应的控制器逻辑。该文件已经包含了一些基础的骨架代码。</p><ul><li>生成 CRD 和控制器代码</li></ul><p>执行以下命令，生成 CRD 规范和控制器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>这将自动执行一系列的代码生成操作，包括 CRD 定义、API 对象的 DeepCopy 方法、以及控制器的代码。</p><ul><li>运行控制器</li></ul><p>运行控制器，使其监听并处理 CronJob 对象的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure><p>现在，控制器已经在集群中运行，可以开始创建和管理 CronJob 对象了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRD介绍</title>
      <link href="/posts/4a17b705.html"/>
      <url>/posts/4a17b705.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes (K8S) 作为容器编排领域的领军者，提供了强大的资源管理和编排能力。然而，有时候我们需要在 Kubernetes 中引入一些自定义的资源类型，以满足特定业务需求。为了实现这一点，Kubernetes 引入了自定义资源定义（Custom Resource Definition，CRD）的概念。本文将深入探讨 CRD 的意义以及如何在 Kubernetes 中使用它。</p><h2 id="什么是自定义资源定义（CRD）？"><a href="#什么是自定义资源定义（CRD）？" class="headerlink" title="什么是自定义资源定义（CRD）？"></a>什么是自定义资源定义（CRD）？</h2><p>CRD 是 Kubernetes 中的一种扩展机制，允许用户定义自己的资源类型。通常情况下，Kubernetes 提供了一系列内建的资源类型，如 Pod、Service、Deployment 等。然而，这些内建资源并不能满足所有业务需求，因此引入了 CRD，使得用户可以定义和使用自己的资源类型。</p><p>通过定义 CRD，用户可以将自己的应用程序或服务的业务逻辑抽象为 Kubernetes 中的一种资源类型，从而更方便、更一致地进行管理和编排。<br>CRD 对于 Kubernetes 的意义</p><h2 id="CRD-为-Kubernetes-提供了以下重要的优势和意义："><a href="#CRD-为-Kubernetes-提供了以下重要的优势和意义：" class="headerlink" title="CRD 为 Kubernetes 提供了以下重要的优势和意义："></a>CRD 为 Kubernetes 提供了以下重要的优势和意义：</h2><h3 id="定制资源类型"><a href="#定制资源类型" class="headerlink" title="定制资源类型"></a>定制资源类型</h3><p>CRD 允许用户在 Kubernetes 中定义自己的资源类型，这些资源类型可以完全适应用户的应用程序或服务的需求。这种灵活性使得 Kubernetes 能够更好地支持各种不同类型的工作负载。</p><h3 id="统一管理"><a href="#统一管理" class="headerlink" title="统一管理"></a>统一管理</h3><p>CRD 将自定义资源纳入 Kubernetes 统一的管理体系中，使得用户可以使用相同的工具和流程来管理自定义资源和内建资源。这种一致性有助于简化管理工作，降低学习成本。</p><h3 id="更好的扩展性"><a href="#更好的扩展性" class="headerlink" title="更好的扩展性"></a>更好的扩展性</h3><p>通过引入 CRD，Kubernetes 的架构变得更加灵活和可扩展。用户可以根据自己的需求，轻松扩展 Kubernetes 的能力，而无需修改 Kubernetes 的核心代码。</p><h3 id="与生态系统集成"><a href="#与生态系统集成" class="headerlink" title="与生态系统集成"></a>与生态系统集成</h3><p>CRD 使得用户可以更好地将自己的应用程序或服务整合到 Kubernetes 生态系统中。例如，使用 Helm 等工具，可以轻松地部署和管理包含 CRD 的应用程序。</p><h2 id="如何使用-CRD"><a href="#如何使用-CRD" class="headerlink" title="如何使用 CRD"></a>如何使用 CRD</h2><p>为了使用 CRD，首先需要定义一个 CRD 的规范，然后将其注册到 Kubernetes 集群中。以下是一个简单的示例，演示如何定义一个名为 Example 的 CRD：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># example-crd.yaml</span><br><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: examples.example.com</span><br><span class="line">spec:</span><br><span class="line">  group: example.com</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1</span><br><span class="line">      served: true</span><br><span class="line">      storage: true</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  names:</span><br><span class="line">    plural: examples</span><br><span class="line">    singular: example</span><br><span class="line">    kind: Example</span><br><span class="line">    shortNames:</span><br><span class="line">    - ex</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个名为 Example 的 CRD，其 API Group 为 example.com，版本为 v1。该 CRD 允许在命名空间中使用，并定义了资源名称的复数和单数形式，以及资源的简称。</p><p>接下来，我们可以使用 kubectl apply 命令将这个 CRD 注册到 Kubernetes 集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f example-crd.yaml</span><br></pre></td></tr></table></figure><p>现在，我们可以创建一个 Example 资源实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># example-instance.yaml</span><br><span class="line">apiVersion: example.com/v1</span><br><span class="line">kind: Example</span><br><span class="line">metadata:</span><br><span class="line">  name: example-instance</span><br><span class="line">spec:</span><br><span class="line">  foo: &quot;bar&quot;</span><br></pre></td></tr></table></figure><p>使用 kubectl apply 命令将这个资源实例创建到 Kubernetes 集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f example-instance.yaml</span><br></pre></td></tr></table></figure><p>通过以下命令，我们可以查看 Example 资源的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get example example-instance -o yaml</span><br></pre></td></tr></table></figure><p>这样，我们就成功地使用了一个简单的 CRD，并创建了一个相应的资源实例。</p><h2 id="CRD-的规范详解"><a href="#CRD-的规范详解" class="headerlink" title="CRD 的规范详解"></a>CRD 的规范详解</h2><p>上面的示例中，我们已经简要介绍了一个 CRD 的定义，下面我们将详细解释一个 CRD 的各个部分。</p><ol><li>apiVersion 和 kind<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br></pre></td></tr></table></figure></li></ol><p>这两个字段指定了 YAML 文件的 API 版本和资源类型。在定义 CRD 时，通常都使用 apiextensions.k8s.io&#x2F;v1 版本的 CustomResourceDefinition 类型。<br>2. metadata.name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metadata:</span><br><span class="line">  name: examples.example.com</span><br></pre></td></tr></table></figure><p>metadata.name 字段定义了 CRD 的名称。这个名称应该是唯一的，并且符合 DNS 子域名的命名规范。<br>3. spec.group 和 spec.versions</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  group: example.com</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1</span><br><span class="line">      served: true</span><br><span class="line">      storage: true</span><br></pre></td></tr></table></figure><p>spec.group 定义了 CRD 的 API 组。spec.versions 字段定义了支持的 API 版本。每个版本包含 name（版本名称）、served（是否提供服务，即是否可以创建资源实例）和 storage（是否进行持久化存储）等属性。<br>4. spec.scope</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  scope: Namespaced</span><br></pre></td></tr></table></figure><p>spec.scope 字段定义了资源的作用域。可以是 Cluster（全局作用域）或 Namespaced（命名空间作用域）。<br>5. spec.names</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  names:</span><br><span class="line">    plural: examples</span><br><span class="line">    singular: example</span><br><span class="line">    kind: Example</span><br><span class="line">    shortNames:</span><br><span class="line">    - ex</span><br></pre></td></tr></table></figure><p>spec.names 字段定义了 CRD 中资源名称的一些属性。其中包括 plural（资源名称的复数形式）、singular（资源名称的单数形式）、kind（资源的 Kubernetes 类型）和 shortNames（资源的简称）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>自定义资源定义（CRD）是 Kubernetes 中非常强大的一项特性，它为用户提供了定义和使用自定义资源类型的能力。通过 CRD，用户可以更灵活地扩展 Kubernetes，适应各种不同类型的工作负载。CRD 的设计和使用需要谨慎，但在合适的场景下，它将是 Kubernetes 中实现自定义需求的理想选择。希望本文对你理解和使用 Kubernetes 中的 CRD 提供了有益的指导。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operator介绍</title>
      <link href="/posts/4a17b704.html"/>
      <url>/posts/4a17b704.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着容器化技术的不断发展，Kubernetes 成为了容器编排领域的事实标准。然而，仅仅使用 Kubernetes 运行应用程序并不总能满足特定的应用需求，特别是一些需要定制化管理的应用。在这种背景下，Kubernetes Operator 应运而生，它为开发人员提供了一种在 Kubernetes 中自动化运维的新概念。</p><h2 id="什么是-Operator？"><a href="#什么是-Operator？" class="headerlink" title="什么是 Operator？"></a>什么是 Operator？</h2><p>Kubernetes Operator 是一种以自定义资源（Custom Resource，CR）为基础的自动化控制器。它的设计初衷是为了更好地支持应用程序的生命周期管理，使得开发者能够在 Kubernetes 上更轻松、更自动地部署、更新和管理应用。</p><p>Operator 的工作方式类似于一个 K8S 控制器，但是它不仅仅关注于基本的资源管理，还关心应用程序的特定需求。通过引入 Operator，我们可以将关于应用的操作和管理逻辑进行抽象，以实现更高级的自动化。</p><h2 id="Operator-的优势"><a href="#Operator-的优势" class="headerlink" title="Operator 的优势"></a>Operator 的优势</h2><ol><li>自动化操作</li></ol><p>Operator 的核心目标是自动化运维。它能够监视、调整和处理应用程序的状态，无需人工干预。这使得在 Kubernetes 上运行应用程序更加容易，降低了维护成本。<br>2. 定制资源</p><p>通过引入自定义资源（CR），Operator 允许用户在 Kubernetes 中定义和使用自己的资源类型。这使得 Operator 可以更好地适应不同应用的需求，提供了更灵活的管理方式。<br>3. 增强运维功能</p><p>Operator 可以包含业务领域专业知识，提供更复杂的应用程序管理功能。它不仅仅关心基础设施的层面，还能够理解应用程序的上下文，进行更细粒度的管理。<br>4. 增强 K8S 原生 API</p><p>Operator 可以通过扩展 Kubernetes API，为应用程序添加更多自定义的管理能力。这样，用户可以通过 K8S API 进行更多高级功能的调用。</p><h2 id="Operator-的优缺点"><a href="#Operator-的优缺点" class="headerlink" title="Operator 的优缺点"></a>Operator 的优缺点</h2><p>优点：</p><ol><li>自动化运维</li></ol><p>Operator 可以大幅度提高运维的自动化水平，减少手动操作，降低人为错误的风险。<br>2. 定制资源</p><p>通过定义自己的 CRD，用户可以在 Kubernetes 中创建和管理自定义资源，使得应用的管理变得更加灵活。<br>3. 跨平台性</p><p>由于 Operator 遵循 Kubernetes API 的标准，它可以在不同的 Kubernetes 发行版上运行，保持了跨平台性。<br>4. 增强 K8S API</p><p>Operator 可以通过扩展 K8S API 来为应用程序添加更多自定义管理的能力，提供更强大的 API。<br>缺点：</p><ol><li>学习成本</li></ol><p>Operator 的使用需要一定的学习成本，尤其是对于初次接触 Kubernetes 的开发者。需要熟悉 CRD、Controller 的概念和编写 Operator 的技能。<br>2. 复杂性</p><p>Operator 可能引入一定的复杂性，特别是在涉及到复杂应用的管理时。需要谨慎设计和实现 Operator，以确保其正确性和稳定性。<br>3. 需要专业知识</p><p>为了实现更复杂的运维功能，Operator 可能需要涉及到特定领域的专业知识，这对于一些小型团队可能会带来挑战。</p><h2 id="Operator-的工作原理"><a href="#Operator-的工作原理" class="headerlink" title="Operator 的工作原理"></a>Operator 的工作原理</h2><p>Operator 的工作原理可以简单概括为以下几个步骤：</p><ul><li>1.监听 CR 变化： Operator 通过监听自定义资源（CR）的变化来感知用户的操作。</li><li>2.解析 CR： 当 CR 发生变化时，Operator 解析 CR 的规范（Spec）和状态（Status）。</li><li>3.执行操作： Operator 根据 CR 中定义的规范执行相应的操作，这可能涉及创建、更新或删除资源。</li><li>4.更新状态： 执行完操作后，Operator 更新 CR 的状态，将执行结果反映到 CR 的状态字段中。</li><li>5.循环监听： Operator 不断循环监听 CR 的变化，保持对应用程序状态的同步。</li></ul><h2 id="示例：使用-Operator-部署一个数据库"><a href="#示例：使用-Operator-部署一个数据库" class="headerlink" title="示例：使用 Operator 部署一个数据库"></a>示例：使用 Operator 部署一个数据库</h2><p>让我们通过一个简单的示例来演示如何使用 Operator 部署一个数据库。假设我们有一个自定义资源类型叫做 Database，它的规范定义了数据库的类型、大小等信息，状态则记录了数据库的运行状态。</p><h3 id="编写-CRD（自定义资源定义）"><a href="#编写-CRD（自定义资源定义）" class="headerlink" title="编写 CRD（自定义资源定义）"></a>编写 CRD（自定义资源定义）</h3><p>首先，我们需要定义 Database 的自定义资源定义（CRD）。这个定义包括了 Database 的规范和状态。以下是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: databases.example.com</span><br><span class="line">spec:</span><br><span class="line">  group: example.com</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1alpha1</span><br><span class="line">      served: true</span><br><span class="line">      storage: true</span><br><span class="line">  names:</span><br><span class="line">    kind: Database</span><br><span class="line">    plural: databases</span><br><span class="line">    singular: database</span><br><span class="line">  scope: Namespaced</span><br></pre></td></tr></table></figure><h3 id="编写-Operator"><a href="#编写-Operator" class="headerlink" title="编写 Operator"></a>编写 Operator</h3><p>接下来，我们需要编写 Operator 的代码。这个代码会监听 Database 对象的变化，并执行相应的操作。以下是一个简化的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line"></span><br><span class="line">// +kubebuilder:rbac:groups=example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">// +kubebuilder:rbac:groups=example.com,resources=databases/status,verbs=get;update;patch</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 初始化 Operator</span><br><span class="line">    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">        Scheme:             scheme.Scheme,</span><br><span class="line">        MetricsBindAddress: &quot;0&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建并注册 Reconciler</span><br><span class="line">    if err = (&amp;controllers.DatabaseReconciler&#123;</span><br><span class="line">        Client: mgr.GetClient(),</span><br><span class="line">        Log:    ctrl.Log.WithName(&quot;controllers&quot;).WithName(&quot;Database&quot;),</span><br><span class="line">        Scheme: mgr.GetScheme(),</span><br><span class="line">    &#125;).SetupWithManager(mgr); err != nil &#123;</span><br><span class="line">        panic(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动 Manager</span><br><span class="line">    if err = mgr.Start(ctrl.SetupSignalHandler()); err != nil &#123;</span><br><span class="line">        panic(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// controllers/database_controller.go</span><br><span class="line"></span><br><span class="line">// DatabaseReconciler reconciles a Database object</span><br><span class="line">type DatabaseReconciler struct &#123;</span><br><span class="line">    client.Client</span><br><span class="line">    Log    logr.Logger</span><br><span class="line">    Scheme *runtime.Scheme</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +kubebuilder:rbac:groups=example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span><br><span class="line">// +kubebuilder:rbac:groups=example.com,resources=databases/status,verbs=get;update;patch</span><br><span class="line"></span><br><span class="line">func (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">    log := r.Log.WithValues(&quot;database&quot;, req.NamespacedName)</span><br><span class="line"></span><br><span class="line">    // 1. 读取 Database 对象</span><br><span class="line">    var db examplev1alpha1.Database</span><br><span class="line">    if err := r.Get(ctx, req.NamespacedName, &amp;db); err != nil &#123;</span><br><span class="line">        log.Error(err, &quot;unable to fetch Database&quot;)</span><br><span class="line">        return ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 执行部署逻辑，例如使用 StatefulSet 部署数据库</span><br><span class="line"></span><br><span class="line">    // 3. 更新状态</span><br><span class="line">    db.Status.Phase = &quot;Deployed&quot;</span><br><span class="line">    if err := r.Status().Update(ctx, &amp;db); err != nil &#123;</span><br><span class="line">        log.Error(err, &quot;unable to update Database status&quot;)</span><br><span class="line">        return ctrl.Result&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署-Operator"><a href="#部署-Operator" class="headerlink" title="部署 Operator"></a>部署 Operator</h3><p>将编写好的 Operator 部署到 Kubernetes 集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 构建 Operator 镜像</span><br><span class="line">docker build -t your-operator-image:latest .</span><br><span class="line"></span><br><span class="line"># 推送镜像到容器仓库</span><br><span class="line">docker push your-operator-image:latest</span><br><span class="line"></span><br><span class="line"># 部署 Operator</span><br><span class="line">kubectl apply -f deploy/operator.yaml</span><br></pre></td></tr></table></figure><h3 id="创建-Database-资源"><a href="#创建-Database-资源" class="headerlink" title="创建 Database 资源"></a>创建 Database 资源</h3><p>现在，我们可以创建一个 Database 资源，告诉 Operator 我们想要部署一个数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: example.com/v1alpha1</span><br><span class="line">kind: Database</span><br><span class="line">metadata:</span><br><span class="line">  name: example-database</span><br><span class="line">spec:</span><br><span class="line">  type: MySQL</span><br><span class="line">  size: Small</span><br></pre></td></tr></table></figure><h3 id="查看-Operator-执行结果"><a href="#查看-Operator-执行结果" class="headerlink" title="查看 Operator 执行结果"></a>查看 Operator 执行结果</h3><p>Operator 会监听到 Database 资源的创建，并自动执行相应的部署逻辑。通过查看 Database 资源的状态字段，我们可以了解到数据库的运行状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get database example-database -o yaml</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Kubernetes Operator 是一个强大的工具，为开发者提供了更高级别的自动化运维能力。通过引入 Operator，我们可以更方便、更灵活地管理应用程序的生命周期。然而，使用 Operator 需要谨慎，需要根据具体的场景和需求来评估其优缺点，以确定是否是合适的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源代码走读之Kubelet</title>
      <link href="/posts/4a17b703.html"/>
      <url>/posts/4a17b703.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes 源代码存放在 GitHub 上，你可以通过以下链接获取：Kubernetes GitHub 仓库。Kubelet 相关的代码位于 pkg&#x2F;kubelet 和 cmd&#x2F;kubelet 等目录中。</p><ul><li>pkg&#x2F;kubelet: 包含了 Kubelet 的核心逻辑，如 Pod 生命周期管理、容器启动和监控等。</li><li>cmd&#x2F;kubelet: 包含 Kubelet 的入口文件，以及启动 Kubelet 所需的配置和参数。</li></ul><h2 id="Kubelet-的代码结构"><a href="#Kubelet-的代码结构" class="headerlink" title="Kubelet 的代码结构"></a>Kubelet 的代码结构</h2><p>在 pkg&#x2F;kubelet 目录下，Kubelet 的代码结构主要分为以下几个模块：</p><ul><li>kubelet: 包含了 Kubelet 的主要逻辑，如 Pod 生命周期管理、容器启动和监控等。</li><li>pod: 包含了 Pod 相关的逻辑，如 Pod 的生命周期管理、状态管理等。</li><li>container: 包含了容器相关的逻辑，如容器的启动、停止和监控等。</li><li>config: 包含了 Kubelet 的配置项定义和解析逻辑。</li><li>util: 包含了一些通用的工具函数和结构体定义。</li></ul><h2 id="Kubelet-的核心逻辑"><a href="#Kubelet-的核心逻辑" class="headerlink" title="Kubelet 的核心逻辑"></a>Kubelet 的核心逻辑</h2><h3 id="Pod-生命周期管理"><a href="#Pod-生命周期管理" class="headerlink" title="Pod 生命周期管理"></a>Pod 生命周期管理</h3><p>1.1 Pod 启动逻辑</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： Kubelet 负责根据 PodSpec 中的描述，启动和管理容器。</li></ul><p>1.2 Pod 状态管理</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： Kubelet 负责监控和维护每个 Pod 的状态，确保其处于正确的运行状态。</li></ul><p>1.3 Pod 事件处理</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： Kubelet 通过事件处理机制监听 Pod 相关的事件，如创建、更新和删除等，执行相应的处理逻辑。</li></ul><h3 id="容器启动和监控"><a href="#容器启动和监控" class="headerlink" title="容器启动和监控"></a>容器启动和监控</h3><p>2.1 容器启动逻辑</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_container_manager.go</li><li>主要功能： Kubelet 通过容器运行时（如 Docker 或 containerd）启动容器，执行容器的初始化、下载镜像等操作。</li></ul><p>2.2 容器监控</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_container_manager.go</li><li>主要功能： Kubelet 监控容器的运行状态，包括容器的 CPU、内存使用情况、日志收集等。</li></ul><h3 id="容器网络和存储"><a href="#容器网络和存储" class="headerlink" title="容器网络和存储"></a>容器网络和存储</h3><p>3.1 容器网络</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_network.go</li><li>主要功能： Kubelet 负责为容器配置网络，包括 IP 地址分配、端口映射等。</li></ul><p>3.2 容器存储</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_volume_manager.go</li><li>主要功能： Kubelet 负责为容器挂载存储卷，执行存储卷的初始化、绑定等操作。</li></ul><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>4.1 资源分配</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： Kubelet 根据 Pod 的资源需求，通过 CAdvisor 等工具进行资源分配和监控。</li></ul><h3 id="启动和注册-Kubelet"><a href="#启动和注册-Kubelet" class="headerlink" title="启动和注册 Kubelet"></a>启动和注册 Kubelet</h3><p>5.1 启动逻辑</p><ul><li>代码位置： cmd&#x2F;kubelet&#x2F;kubelet.go</li><li>主要功能： Kubelet 的入口文件，定义了 Kubelet 的启动逻辑，包括命令行参数的解析和初始化。</li></ul><p>5.2 注册 Kubelet</p><ul><li>代码位置： cmd&#x2F;kubelet&#x2F;app&#x2F;server.go</li><li>主要功能： Kubelet 启动后，会向 Kubernetes API Server 注册自己，使其成为集群中的一个节点。</li></ul><h2 id="二次开发扩展点"><a href="#二次开发扩展点" class="headerlink" title="二次开发扩展点"></a>二次开发扩展点</h2><h3 id="容器运行时的自定义"><a href="#容器运行时的自定义" class="headerlink" title="容器运行时的自定义"></a>容器运行时的自定义</h3><p>1.1 容器运行时接口</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_container_manager.go</li><li>主要功能： 你可以扩展或替换容器运行时，实现自定义的容器启动和监控逻辑。</li></ul><h3 id="容器网络和存储的自定义"><a href="#容器网络和存储的自定义" class="headerlink" title="容器网络和存储的自定义"></a>容器网络和存储的自定义</h3><p>2.1 容器网络接口</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_network.go</li><li>主要功能： 你可以实现自定义的容器网络插件，以满足特定网络需求。</li></ul><p>2.2 容器存储接口</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_volume_manager.go</li><li>主要功能： 你可以实现自定义的容器存储插件，以满足特定存储需求。</li></ul><h3 id="Pod-生命周期管理的扩展"><a href="#Pod-生命周期管理的扩展" class="headerlink" title="Pod 生命周期管理的扩展"></a>Pod 生命周期管理的扩展</h3><p>3.1 Pod 生命周期钩子</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： 你可以实现自定义的 Pod 生命周期钩子，以在不同生命周期阶段执行特定逻辑。</li></ul><h3 id="事件处理的扩展"><a href="#事件处理的扩展" class="headerlink" title="事件处理的扩展"></a>事件处理的扩展</h3><p>4.1 事件处理逻辑</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： 你可以实现自定义的事件处理逻辑，以响应 Pod 相关的各种事件。</li></ul><h3 id="资源管理的扩展"><a href="#资源管理的扩展" class="headerlink" title="资源管理的扩展"></a>资源管理的扩展</h3><p>5.1 资源管理逻辑</p><ul><li>代码位置： pkg&#x2F;kubelet&#x2F;kubelet_pods.go</li><li>主要功能： 你可以实现自定义的资源管理逻辑，以满足对资源的特定需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s源代码走读之Kubelet-Proxy</title>
      <link href="/posts/4a17b706.html"/>
      <url>/posts/4a17b706.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes 源代码托管在 GitHub 上，你可以通过以下链接获取：Kubernetes GitHub 仓库。Kube-Proxy 相关的代码位于 pkg&#x2F;proxy 和 cmd&#x2F;kube-proxy 等目录中。</p><pre><code>pkg/proxy: 包含了 Kube-Proxy 的核心逻辑，如负载均衡、流量代理等。cmd/kube-proxy: 包含 Kube-Proxy 的入口文件，以及启动 Kube-Proxy 所需的配置和参数。</code></pre><h2 id="Kube-Proxy-的代码结构"><a href="#Kube-Proxy-的代码结构" class="headerlink" title="Kube-Proxy 的代码结构"></a>Kube-Proxy 的代码结构</h2><p>在 pkg&#x2F;proxy 目录下，Kube-Proxy 的代码结构主要分为以下几个模块：</p><ul><li>endpoints: 包含了与服务终端相关的代码，如负载均衡算法等。</li><li>iptables: 包含了与 iptables 相关的代码，用于配置 iptables 规则。</li><li>ipvs: 包含了与 IPVS（IP Virtual Server）相关的代码，用于配置 IPVS 规则。</li><li>service: 包含了服务代理的实现，处理服务的注册和反注册等逻辑。</li></ul><h2 id="Kube-Proxy-的核心逻辑"><a href="#Kube-Proxy-的核心逻辑" class="headerlink" title="Kube-Proxy 的核心逻辑"></a>Kube-Proxy 的核心逻辑</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>1.1 负载均衡算法</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;endpoints&#x2F;</li><li>主要功能： 定义了 Kube-Proxy 中的负载均衡算法，用于选择服务的后端节点。</li></ul><p>1.2 负载均衡策略</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;endpoints&#x2F;</li><li>主要功能： 定义了负载均衡的策略，如轮询、随机等，用于确定请求被转发到哪个后端节点。</li></ul><h3 id="iptables-规则配置"><a href="#iptables-规则配置" class="headerlink" title="iptables 规则配置"></a>iptables 规则配置</h3><p>2.1 iptables 规则生成</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;iptables&#x2F;</li><li>主要功能： 定义了生成 iptables 规则的逻辑，用于实现服务代理和负载均衡。</li></ul><p>2.2 iptables 规则生效</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;iptables&#x2F;</li><li>主要功能： 定义了 iptables 规则生效的逻辑，将生成的规则应用到系统中。</li></ul><h3 id="IPVS-规则配置"><a href="#IPVS-规则配置" class="headerlink" title="IPVS 规则配置"></a>IPVS 规则配置</h3><p>3.1 IPVS 规则生成</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;ipvs&#x2F;</li><li>主要功能： 定义了生成 IPVS 规则的逻辑，用于实现服务代理和负载均衡。</li></ul><p>3.2 IPVS 规则生效</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;ipvs&#x2F;</li><li>主要功能： 定义了 IPVS 规则生效的逻辑，将生成的规则应用到系统中。</li></ul><h3 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h3><p>4.1 服务代理注册</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;service&#x2F;</li><li>主要功能： 定义了服务的注册和反注册逻辑，确保 Kube-Proxy 可以感知到集群中的服务。</li></ul><p>4.2 服务代理处理逻辑</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;service&#x2F;</li><li>主要功能： 定义了服务代理的处理逻辑，包括请求的转发、负载均衡等。</li></ul><h3 id="代理模式切换"><a href="#代理模式切换" class="headerlink" title="代理模式切换"></a>代理模式切换</h3><p>5.1 代理模式选择</p><ul><li>代码位置： cmd&#x2F;kube-proxy&#x2F;app&#x2F;server.go</li><li>主要功能： 定义了 Kube-Proxy 的启动参数和代理模式的选择逻辑。</li></ul><p>5.2 代理模式切换逻辑</p><ul><li>代码位置： cmd&#x2F;kube-proxy&#x2F;app&#x2F;server.go</li><li>主要功能： 根据用户配置和系统环境，切换 Kube-Proxy 的代理模式，支持 iptables 和 IPVS。</li></ul><h2 id="二次开发扩展点"><a href="#二次开发扩展点" class="headerlink" title="二次开发扩展点"></a>二次开发扩展点</h2><h3 id="负载均衡算法的扩展"><a href="#负载均衡算法的扩展" class="headerlink" title="负载均衡算法的扩展"></a>负载均衡算法的扩展</h3><p>1.1 自定义负载均衡算法</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;endpoints&#x2F;</li><li>主要功能： 你可以编写自定义的负载均衡算法，以满足不同场景下的负载均衡需求。</li></ul><p>1.2 负载均衡策略的扩展</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;endpoints&#x2F;</li><li>主要功能： 你可以扩展负载均衡策略，以适应更多的调度和路由场景。</li></ul><h3 id="iptables-规则配置的扩展"><a href="#iptables-规则配置的扩展" class="headerlink" title="iptables 规则配置的扩展"></a>iptables 规则配置的扩展</h3><p>2.1 自定义 iptables 规则生成</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;iptables&#x2F;</li><li>主要功能： 你可以编写自定义的 iptables 规则生成逻辑，以适应特定的网络环境和需求。</li></ul><p>2.2 iptables 规则生效的扩展</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;iptables&#x2F;</li><li>主要功能： 你可以扩展 iptables 规则生效逻辑，以满足特定系统和网络配置。</li></ul><h3 id="IPVS-规则配置的扩展"><a href="#IPVS-规则配置的扩展" class="headerlink" title="IPVS 规则配置的扩展"></a>IPVS 规则配置的扩展</h3><p>3.1 自定义 IPVS 规则生成</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;ipvs&#x2F;</li><li>主要功能： 你可以编写自定义的 IPVS 规则生成逻辑，以适应不同的负载均衡需求。</li></ul><p>3.2 IPVS 规则生效的扩展</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;ipvs&#x2F;</li><li>主要功能： 你可以扩展 IPVS 规则生效逻辑，以适应特定系统和网络配置。</li></ul><h3 id="服务代理的扩展"><a href="#服务代理的扩展" class="headerlink" title="服务代理的扩展"></a>服务代理的扩展</h3><p>4.1 自定义服务注册逻辑</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;service&#x2F;</li><li>主要功能： 你可以编写自定义的服务注册逻辑，以适应集群中服务的动态变化。</li></ul><p>4.2 自定义服务代理处理逻辑</p><ul><li>代码位置： pkg&#x2F;proxy&#x2F;service&#x2F;</li><li>主要功能： 你可以扩展服务代理的处理逻辑，以实现特定的服务代理策略和行为。</li></ul><h3 id="代理模式切换的扩展"><a href="#代理模式切换的扩展" class="headerlink" title="代理模式切换的扩展"></a>代理模式切换的扩展</h3><p>5.1 新代理模式的添加</p><ul><li>代码位置： cmd&#x2F;kube-proxy&#x2F;app&#x2F;server.go</li><li>主要功能： 你可以添加新的代理模式，以满足特定的网络环境和性能需求。</li></ul><p>5.2 代理模式切换逻辑的扩展</p><ul><li>代码位置： cmd&#x2F;kube-proxy&#x2F;app&#x2F;server.go</li><li>主要功能： 你可以扩展代理模式切换逻辑，以根据集群和节点的特性动态选择最适合的代理模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源代码走读之Kube-Scheduler</title>
      <link href="/posts/4a17b702.html"/>
      <url>/posts/4a17b702.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes 源代码存放在 GitHub 上，你可以通过以下链接获取：Kubernetes GitHub 仓库。Kube-Scheduler 相关的代码位于 pkg&#x2F;scheduler 和 cmd&#x2F;kube-scheduler 等目录中。</p><ul><li>pkg&#x2F;scheduler: 包含了 Kube-Scheduler 的核心逻辑，如调度算法、预选和绑定等。</li><li>cmd&#x2F;kube-scheduler: 包含 Kube-Scheduler 的入口文件，以及启动 Kube-Scheduler 所需的配置和参数。</li></ul><h2 id="Kube-Scheduler-的代码结构"><a href="#Kube-Scheduler-的代码结构" class="headerlink" title="Kube-Scheduler 的代码结构"></a>Kube-Scheduler 的代码结构</h2><p>在 pkg&#x2F;scheduler 目录下，Kube-Scheduler 的代码结构主要分为以下几个模块：</p><ul><li>algorithm: 包含调度算法的实现，如优先级函数等。</li><li>framework: 包含调度框架的实现，定义了调度器的各个阶段。</li><li>plugins: 包含各种调度器插件的实现，如预选插件和绑定插件。</li><li>stages: 包含调度器各个阶段的具体实现，如预选阶段、优选阶段等。</li></ul><h2 id="Kube-Scheduler-的核心逻辑"><a href="#Kube-Scheduler-的核心逻辑" class="headerlink" title="Kube-Scheduler 的核心逻辑"></a>Kube-Scheduler 的核心逻辑</h2><h3 id="调度框架"><a href="#调度框架" class="headerlink" title="调度框架"></a>调度框架</h3><p>1.1 阶段划分</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;framework&#x2F;framework.go</li><li>主要功能： 定义了调度器的各个阶段，包括预选、优选等。</li></ul><p>1.2 阶段执行</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;scheduler.go</li><li>主要功能： 调度器在执行时按照预定义的阶段顺序，依次调用每个阶段的处理逻辑。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>2.1 优先级函数</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;priorities.go</li><li>主要功能： 定义了调度器中用于计算优先级的各种函数，影响 Pod 的调度顺序。</li></ul><p>2.2 优选函数</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;predicates.go</li><li>主要功能： 定义了调度器中用于筛选可行节点的各种函数，影响 Pod 的可调度性。</li></ul><h3 id="调度器插件"><a href="#调度器插件" class="headerlink" title="调度器插件"></a>调度器插件</h3><p>3.1 预选插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 预选插件影响节点的可用性，决定哪些节点可以继续参与调度。</li></ul><p>3.2 优选插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 优选插件通过给节点打分，影响节点的优选顺序，最终决定 Pod 被调度到哪个节点。</li></ul><p>3.3 绑定插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 绑定插件负责确定 Pod 被绑定到哪个节点上。</li></ul><h3 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h3><p>4.1 候选节点选择</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;predicates.go</li><li>主要功能： 调度器在节点选择阶段根据预选和优选函数选择候选节点。</li></ul><p>4.2 节点权重计算</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;priorities.go</li><li>主要功能： 调度器通过计算节点的权重，最终确定 Pod 被调度到哪个节点。</li></ul><h3 id="调度事件处理"><a href="#调度事件处理" class="headerlink" title="调度事件处理"></a>调度事件处理</h3><p>5.1 调度事件处理逻辑</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;scheduler.go</li><li>主要功能： 调度器根据调度事件的类型，执行相应的事件处理逻辑。</li></ul><p>5.2 事件队列</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;factory&#x2F;factory.go</li><li>主要功能： 调度器使用事件队列来异步处理调度事件，确保调度逻辑是非阻塞的。</li></ul><h2 id="二次开发扩展点"><a href="#二次开发扩展点" class="headerlink" title="二次开发扩展点"></a>二次开发扩展点</h2><h3 id="调度器插件的自定义"><a href="#调度器插件的自定义" class="headerlink" title="调度器插件的自定义"></a>调度器插件的自定义</h3><p>1.1 自定义预选插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 你可以编写自定义的预选插件，以实现对节点可用性的自定义判断逻辑。</li></ul><p>1.2 自定义优选插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 你可以编写自定义的优选插件，以实现对节点优选顺序的自定义调整。</li></ul><p>1.3 自定义绑定插件</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;plugins&#x2F;</li><li>主要功能： 你可以编写自定义的绑定插件，以实现对 Pod 绑定到节点的自定义策略。</li></ul><h3 id="调度算法的自定义"><a href="#调度算法的自定义" class="headerlink" title="调度算法的自定义"></a>调度算法的自定义</h3><p>2.1 优先级函数的扩展</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;priorities.go</li><li>主要功能： 你可以编写自定义的优先级函数，以实现对 Pod 调度优先级的自定义计算。</li></ul><p>2.2 优选函数的扩展</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;algorithm&#x2F;predicates.go</li><li>主要功能： 你可以编写自定义的优选函数，以实现对节点的可调度性的自定义判断。</li></ul><h3 id="调度器的扩展"><a href="#调度器的扩展" class="headerlink" title="调度器的扩展"></a>调度器的扩展</h3><p>3.1 调度器阶段的扩展</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;framework&#x2F;framework.go</li><li>主要功能： 你可以扩展调度器的各个阶段，以实现对调度流程的自定义控制。</li></ul><p>3.2 调度器事件处理的扩展</p><ul><li>代码位置： pkg&#x2F;scheduler&#x2F;scheduler.go</li><li>主要功能： 你可以扩展调度器的事件处理逻辑，以实现对调度事件的自定义响应。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s源代码走读之Controller-Manager</title>
      <link href="/posts/4a17b701.html"/>
      <url>/posts/4a17b701.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes 源代码存放在 GitHub 上，你可以通过以下链接获取：Kubernetes GitHub 仓库。Controller Manager 相关的代码位于 pkg&#x2F;controller、cmd&#x2F;kube-controller-manager 等目录中。</p><ul><li>pkg&#x2F;controller: 包含了各种控制器的代码，如 Deployment、Pod、Service 等。</li><li>cmd&#x2F;kube-controller-manager: 包含 Controller Manager 的入口文件，以及启动 Controller Manager 所需的配置和参数。</li></ul><h2 id="Controller-Manager-的代码结构"><a href="#Controller-Manager-的代码结构" class="headerlink" title="Controller Manager 的代码结构"></a>Controller Manager 的代码结构</h2><p>在 pkg&#x2F;controller 目录下，Controller Manager 的代码结构主要分为以下几个模块：</p><ul><li>deployment: 包含 Deployment 控制器的实现。</li><li>pod: 包含 Pod 控制器的实现。</li><li>service: 包含 Service 控制器的实现。</li><li>其他控制器：还有许多其他控制器的实现，用于管理不同类型的资源。</li></ul><h2 id="Controller-Manager-的核心逻辑"><a href="#Controller-Manager-的核心逻辑" class="headerlink" title="Controller Manager 的核心逻辑"></a>Controller Manager 的核心逻辑</h2><h3 id="控制器的注册和运行"><a href="#控制器的注册和运行" class="headerlink" title="控制器的注册和运行"></a>控制器的注册和运行</h3><p>1.1 控制器注册</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;</li><li>主要功能： 各个控制器的实现文件中通过注册机制将自己注册到 Controller Manager 中。</li></ul><p>1.2 控制器运行</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controllermanager.go</li><li>主要功能： Controller Manager 在启动时，根据注册的控制器列表运行这些控制器。</li></ul><h3 id="控制器的核心逻辑"><a href="#控制器的核心逻辑" class="headerlink" title="控制器的核心逻辑"></a>控制器的核心逻辑</h3><p>2.1 Pod 控制器</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;pod&#x2F;pod_controller.go</li><li>主要功能： Pod 控制器负责确保集群中的 Pod 按照用户定义的期望状态运行，处理创建、删除、更新等操作。</li></ul><p>2.2 Deployment 控制器</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;deployment&#x2F;deployment_controller.go</li><li>主要功能： Deployment 控制器管理 Deployment 对象，负责创建、扩容、缩容等相关的 Pod。</li></ul><p>2.3 Service 控制器</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;service&#x2F;service_controller.go</li><li>主要功能： Service 控制器确保 Service 对象的稳定性，处理 Service 相关的操作，如创建负载均衡器等。</li></ul><h3 id="控制器的事件处理"><a href="#控制器的事件处理" class="headerlink" title="控制器的事件处理"></a>控制器的事件处理</h3><p>3.1 控制器事件队列</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 控制器使用事件队列来处理与资源对象相关的事件，确保控制器的逻辑是异步的。</li></ul><p>3.2 控制器事件处理逻辑</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 控制器根据事件类型，执行相应的逻辑处理，如创建、更新、删除等。</li></ul><h3 id="控制器的状态同步"><a href="#控制器的状态同步" class="headerlink" title="控制器的状态同步"></a>控制器的状态同步</h3><p>4.1 控制器状态同步机制</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 控制器负责与 API Server 交互，确保控制器的状态与集群中的资源状态保持同步。</li></ul><p>4.2 控制器状态同步逻辑</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 控制器通过调用 API Server 提供的接口，获取最新的资源状态，与控制器内部状态进行比较和同步。</li></ul><h2 id="二次开发扩展点"><a href="#二次开发扩展点" class="headerlink" title="二次开发扩展点"></a>二次开发扩展点</h2><h3 id="控制器的自定义"><a href="#控制器的自定义" class="headerlink" title="控制器的自定义"></a>控制器的自定义</h3><p>1.1 自定义控制器</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;</li><li>主要功能： 你可以编写自定义控制器，注册到 Controller Manager 中，实现对你关心的资源的控制逻辑。</li></ul><p>1.2 控制器事件处理</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 自定义控制器的事件处理逻辑，可根据需求定制不同的行为。</li></ul><h3 id="控制器的扩展"><a href="#控制器的扩展" class="headerlink" title="控制器的扩展"></a>控制器的扩展</h3><p>2.1 控制器扩展点</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controllermanager.go</li><li>主要功能： 控制器扩展点允许你扩展 Controller Manager 的功能，添加新的控制器或修改现有控制器的行为。</li></ul><p>2.2 控制器参数配置</p><ul><li>代码位置： cmd&#x2F;kube-controller-manager&#x2F;app&#x2F;controllermanager.go</li><li>主要功能： 你可以通过修改 Controller Manager 的配置文件或启动参数，为控制器添加额外的配置。</li></ul><h3 id="控制器的状态同步-1"><a href="#控制器的状态同步-1" class="headerlink" title="控制器的状态同步"></a>控制器的状态同步</h3><p>3.1 存储接口</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;</li><li>主要功能： 控制器通过与 API Server 的存储接口交互，实现资源状态的同步。</li></ul><p>3.2 资源状态同步逻辑</p><ul><li>代码位置： pkg&#x2F;controller&#x2F;controller.go</li><li>主要功能： 控制器的状态同步逻辑可以根据需求进行定制，以满足不同资源的同步要求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件ETCD</title>
      <link href="/posts/4a17b629.html"/>
      <url>/posts/4a17b629.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>etcd作为Kubernetes（K8S）的核心组件之一，承担了分布式配置存储和服务发现的任务。它的设计思路、在K8S集群中的主要功能、内部工作原理以及与其他NoSQL产品的比较，都对整个Kubernetes集群的稳定性和可靠性有着重要的影响。本文将深入探讨etcd的方方面面，以期帮助读者更全面地理解和有效地使用Kubernetes。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="一致性与可靠性"><a href="#一致性与可靠性" class="headerlink" title="一致性与可靠性"></a>一致性与可靠性</h3><p>etcd的设计思路始终围绕一致性和可靠性。作为分布式系统中的数据存储组件，etcd采用Raft一致性算法来保证数据的一致性，通过数据的多副本存储和选主机制来确保高可用性，从而在整个Kubernetes集群中提供可靠的配置存储。</p><h3 id="分布式键值存储"><a href="#分布式键值存储" class="headerlink" title="分布式键值存储"></a>分布式键值存储</h3><p>etcd采用键值存储的模型，将配置信息以键值对的形式存储在分布式的存储引擎中。这种模型使得etcd不仅能够用于Kubernetes集群的配置存储，还可用于任何需要分布式键值存储的场景。</p><h2 id="在K8S集群中的主要功能"><a href="#在K8S集群中的主要功能" class="headerlink" title="在K8S集群中的主要功能"></a>在K8S集群中的主要功能</h2><h3 id="配置存储"><a href="#配置存储" class="headerlink" title="配置存储"></a>配置存储</h3><p>etcd作为Kubernetes的配置存储后端，负责存储整个集群的配置信息，包括节点信息、Pod信息、服务信息等。这些信息被Kubernetes的其他组件用于决策和调度。</p><h3 id="选主与高可用"><a href="#选主与高可用" class="headerlink" title="选主与高可用"></a>选主与高可用</h3><p>etcd通过Raft算法实现了选主机制，确保了在一个时间点只有一个etcd节点成为集群的领导者。这有助于提高系统的响应速度和整体的稳定性，同时保障了数据的一致性。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Kubernetes中的服务发现依赖于etcd，通过在etcd中注册服务的信息，实现了服务的动态发现和负载均衡。当Pod发生变化时，etcd及时更新服务的注册信息，确保整个集群对服务的访问始终指向可用的Pod。</p><h2 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h2><h3 id="Raft一致性算法"><a href="#Raft一致性算法" class="headerlink" title="Raft一致性算法"></a>Raft一致性算法</h3><p>etcd使用Raft一致性算法，通过选主、日志复制和安全提交等机制，确保了在集群中的不同节点上的数据的一致性。这种机制使得etcd能够在网络分区和节点故障等情况下依然保持数据的一致性。</p><h3 id="快照和日志"><a href="#快照和日志" class="headerlink" title="快照和日志"></a>快照和日志</h3><p>etcd使用快照和日志来持久化存储数据。快照用于定期备份数据，而日志则用于记录数据的变更。这种组合保证了etcd在发生故障时能够迅速恢复到最新的一致状态。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>etcd支持分布式事务，通过事务操作来确保多个键值对的一致性变更。这有助于在Kubernetes集群中实现复杂的配置更新和变更。</p><h2 id="与其他NoSQL产品的比较"><a href="#与其他NoSQL产品的比较" class="headerlink" title="与其他NoSQL产品的比较"></a>与其他NoSQL产品的比较</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>一致性</li></ul><p>etcd采用Raft算法，对于分布式系统来说，提供了较高水平的一致性。这使得etcd在数据的读写操作上能够更好地满足Kubernetes的要求。</p><ul><li>性能</li></ul><p>etcd在设计上注重了性能的优化，其底层存储引擎支持高吞吐和低延迟的数据访问，确保在大规模Kubernetes集群中也能够保持较高的性能。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>复杂性</li></ul><p>etcd的一致性机制和高可用机制使得其配置和部署相对复杂，需要一定的专业知识。相比之下，某些NoSQL产品可能更容易上手。</p><ul><li>存储引擎限制</li></ul><p>etcd的底层存储引擎虽然支持高性能，但也有其限制。在某些场景下，其他NoSQL产品可能更适合特定的数据模型和查询需求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>etcd作为Kubernetes的核心组件，扮演着分布式配置存储和服务发现的关键角色。其一致性和可靠性机制，保证了整个Kubernetes集群的稳定运行。通过深入了解其设计思路、主要功能、内部工作原理以及与其他NoSQL产品的比较，我们能够更好地理解etcd的作用和价值，并能够更灵活地配置和管理Kubernetes集群。在实际应用中，etcd的强一致性和高可用性使其成为分布式系统和容器编排的理想之选。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件Kubelet</title>
      <link href="/posts/4a17b628.html"/>
      <url>/posts/4a17b628.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8S）作为容器编排领域的领军者，其核心组件之一——Kubelet，扮演着关键的节点代理角色。Kubelet负责管理和维护节点上的容器，是K8S集群中不可或缺的组成部分。本文将深入探讨Kubelet的设计思想、主要功能、内部工作原理以及常见的故障排查方法，以帮助读者更全面地理解和有效地使用Kubernetes。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="分而治之的原则"><a href="#分而治之的原则" class="headerlink" title="分而治之的原则"></a>分而治之的原则</h3><p>Kubelet的设计思想遵循了Kubernetes整体的分布式系统原则。每个节点上的Kubelet都是独立的，负责管理本地的容器。这种分而治之的原则有助于提高系统的可扩展性和容错性，使得每个节点可以独立运行，同时保持整个集群的协同工作。</p><h3 id="声明式管理"><a href="#声明式管理" class="headerlink" title="声明式管理"></a>声明式管理</h3><p>Kubelet采用声明式的管理风格，通过接收来自API Server的Pod描述信息，将节点上的状态调整为期望的状态。这种设计思想使得Kubelet可以更灵活地适应不同的应用场景，同时与Kubernetes的其他组件协同工作，实现整体系统的一致性。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><p>Kubelet负责管理节点上容器的生命周期，包括容器的创建、启动、停止和销毁。它监控每个Pod的状态，根据实际情况主动调整容器的状态，以确保Pod中的容器处于预期的运行状态。</p><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>Kubelet通过监控节点的资源使用情况，确保容器在节点上得到合适的资源配额。它与容器运行时（如Docker、containerd）协同工作，调整容器的资源分配，防止节点资源过度占用。</p><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><p>Kubelet负责为Pod创建网络命名空间，并配置容器的网络环境。它与CNI（Container Network Interface）插件协同工作，实现容器之间和容器与外部网络的通信。</p><h2 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h2><h3 id="Pod描述同步"><a href="#Pod描述同步" class="headerlink" title="Pod描述同步"></a>Pod描述同步</h3><p>Kubelet通过与API Server的通信，获取与本节点相关的Pod描述信息。它周期性地拉取Pod的描述，与当前节点上运行的Pod进行比较，根据差异来执行相应的操作，以保持节点状态的一致性。</p><h3 id="容器运行时接口"><a href="#容器运行时接口" class="headerlink" title="容器运行时接口"></a>容器运行时接口</h3><p>Kubelet通过容器运行时接口（CRI，Container Runtime Interface）与底层的容器运行时进行通信。这使得Kubelet可以与不同的容器运行时（如Docker、containerd）无缝集成，通过CRI执行容器的创建、启动和停止等操作。</p><h3 id="健康检查和自愈"><a href="#健康检查和自愈" class="headerlink" title="健康检查和自愈"></a>健康检查和自愈</h3><p>Kubelet通过周期性的健康检查来监控Pod和容器的状态。当发现异常时，Kubelet会尝试自愈，例如重新启动容器或者重新拉取镜像，以确保Pod能够达到期望的状态。</p><h2 id="常见的故障排查"><a href="#常见的故障排查" class="headerlink" title="常见的故障排查"></a>常见的故障排查</h2><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>Kubelet生成详细的日志，管理员可以通过查看这些日志来了解Kubelet的运行状况。重要的日志通常包括容器启动失败、Pod调度问题等信息。</p><h3 id="资源不足"><a href="#资源不足" class="headerlink" title="资源不足"></a>资源不足</h3><p>如果节点资源不足，Kubelet可能会无法启动新的Pod或者容器。管理员需要检查节点资源使用情况，可能需要添加节点或者调整Pod的资源请求和限制。</p><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>Kubelet负责容器的网络配置，网络问题可能导致Pod之间或者与外部网络的通信失败。管理员可以通过检查网络命名空间、CNI插件状态等信息来进行故障排查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubelet作为Kubernetes集群中节点的关键组件，承担了容器的生命周期管理、资源管理和网络管理等重要任务。通过深入了解其设计思想、主要功能、内部工作原理以及常见的故障排查方法，我们能够更好地理解Kubernetes集群的运行机制，并能够更有效地管理和维护集群中的节点。Kubelet的可扩展性和自愈能力为Kubernetes的可靠性和灵活性提供了坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件Kube-Proxy</title>
      <link href="/posts/4a17b627.html"/>
      <url>/posts/4a17b627.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着容器编排技术的发展，Kubernetes（K8S）已经成为容器化应用部署和管理的事实标准。在K8S的核心组件中，Kube-Proxy（代理）扮演着网络代理的角色，负责实现集群内部服务的负载均衡和网络通信。本文将深入探讨Kube-Proxy的设计思想、主要功能、内部工作原理以及日常运维等方面，以期帮助读者更全面地理解和使用Kubernetes。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="抽象和统一网络访问"><a href="#抽象和统一网络访问" class="headerlink" title="抽象和统一网络访问"></a>抽象和统一网络访问</h3><p>Kube-Proxy的设计思想之一是抽象和统一网络访问。在K8S集群中，Pod可以在不同的节点上运行，而服务的IP地址也可能随时变化。Kube-Proxy通过提供一个统一的虚拟IP（ClusterIP）来抽象这些底层细节，使得服务的访问对用户而言是透明的。</p><h3 id="负载均衡与服务发现"><a href="#负载均衡与服务发现" class="headerlink" title="负载均衡与服务发现"></a>负载均衡与服务发现</h3><p>Kube-Proxy通过实现负载均衡机制，将访问服务的流量分发到后端的多个Pod实例上。同时，它也负责服务发现，及时更新服务的端点信息，确保流量被正确地引导到可用的Pod上。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h3><p>Kube-Proxy的主要功能之一是服务代理。它负责监听Kubernetes API Server，获取Service和Endpoint信息，并根据这些信息配置系统的网络规则，实现服务代理和负载均衡。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Kube-Proxy负责监控K8S集群中Service和Endpoint的变化。当有新的Pod加入或离开服务，Kube-Proxy会相应地更新服务的负载均衡规则，确保请求被正确地路由到可用的Pod上。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Kube-Proxy通过维护iptables规则或者IPVS规则，实现服务的负载均衡。这确保了在一个服务有多个Pod实例的情况下，流量能够被均匀地分发到各个实例上，提高服务的可用性和性能。</p><h2 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h2><h3 id="iptables和IPVS"><a href="#iptables和IPVS" class="headerlink" title="iptables和IPVS"></a>iptables和IPVS</h3><p>Kube-Proxy使用iptables或IPVS来实现负载均衡。在iptables模式下，Kube-Proxy会为每个Service创建一组iptables规则，通过NAT表来实现负载均衡。而在IPVS模式下，Kube-Proxy使用Linux内核的IPVS模块来进行负载均衡，具有更高的性能和效率。</p><h3 id="Service和Endpoint对象"><a href="#Service和Endpoint对象" class="headerlink" title="Service和Endpoint对象"></a>Service和Endpoint对象</h3><p>Kube-Proxy通过监听K8S API Server上的Service和Endpoint对象的变化来获取服务的信息。Service定义了服务的虚拟IP和端口，而Endpoint则包含了服务后端Pod的IP和端口信息。</p><h3 id="iptables规则生成"><a href="#iptables规则生成" class="headerlink" title="iptables规则生成"></a>iptables规则生成</h3><p>根据Service和Endpoint的信息，Kube-Proxy会生成对应的iptables规则。这些规则包括DNAT规则，用于将访问Service的流量重定向到后端的Pod实例上，以及SNAT规则，确保Pod返回的流量经过Kube-Proxy，而不是直接返回给客户端。</p><h2 id="日常运维"><a href="#日常运维" class="headerlink" title="日常运维"></a>日常运维</h2><h3 id="代理模式选择"><a href="#代理模式选择" class="headerlink" title="代理模式选择"></a>代理模式选择</h3><p>Kube-Proxy支持iptables和IPVS两种代理模式，管理员可以根据集群的规模和性能需求选择合适的代理模式。IPVS通常在大规模集群中表现更优秀。</p><h3 id="调优和性能监控"><a href="#调优和性能监控" class="headerlink" title="调优和性能监控"></a>调优和性能监控</h3><p>对于高流量的服务，管理员可能需要调整Kube-Proxy的配置以满足性能需求。监控系统可以通过收集Kube-Proxy的性能指标和日志信息来进行调优和性能监控。</p><h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p>Kube-Proxy可能会遇到网络故障、配置错误等问题。管理员可以通过查看Kube-Proxy的日志、监控系统的报警信息以及使用Kubernetes提供的工具来进行故障排查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kube-Proxy作为Kubernetes的核心组件之一，扮演着重要的网络代理和负载均衡角色。通过深入了解其设计思想、主要功能、内部工作原理以及日常运维，我们能更好地理解Kube-Proxy在K8S集群中的作用，并能更灵活地配置和管理网络流量，提高服务的可用性和性能。同时，Kube-Proxy的可插拔特性也为用户提供了丰富的定制和扩展空间，以适应不同规模和要求的集群。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的证书管理</title>
      <link href="/posts/4a17b619.html"/>
      <url>/posts/4a17b619.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，具有强大的集群管理和安全机制。在Kubernetes集群中，证书管理是一个关键的安全组成部分，用于保障集群通信的安全性和可信度。本文将深入讨论Kubernetes中的证书管理，包括证书的生成、颁发、续期以及如何在实际应用中进行合理配置，同时提供详细的示例演示证书管理的具体操作。</p><h2 id="什么是证书管理？"><a href="#什么是证书管理？" class="headerlink" title="什么是证书管理？"></a>什么是证书管理？</h2><p>证书管理是指在Kubernetes集群中有效、安全地管理证书的过程。在集群中的各个组件之间以及与外部系统的通信中，通常使用证书来确保通信的安全性。证书管理包括证书的生成、颁发、更新和撤销等操作，以及相关的安全策略。</p><p>在Kubernetes中，常见的证书使用场景包括：</p><ul><li>API Server 证书： 用于加密和保护 Kubernetes API Server 与其他组件之间的通信。</li><li>etcd 证书： 用于保护 etcd 数据库的通信，确保集群状态的安全。</li><li>kubelet 证书： 用于 kubelet 与 API Server 之间的通信，以及节点与控制平面之间的安全通信。</li></ul><h2 id="证书管理的基本流程"><a href="#证书管理的基本流程" class="headerlink" title="证书管理的基本流程"></a>证书管理的基本流程</h2><p>证书管理的基本流程包括证书的生成、签发、使用以及更新。以下是证书管理的基本步骤：</p><h3 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h3><p>证书生成是指创建用于加密通信的证书和私钥。通常使用工具如 OpenSSL 或 cfssl 进行生成。生成的证书包括公钥（用于加密）和私钥（用于解密），私钥应该妥善保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 OpenSSL 生成证书和私钥的示例</span><br><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout key.pem -out cert.pem</span><br></pre></td></tr></table></figure><h3 id="证书签发"><a href="#证书签发" class="headerlink" title="证书签发"></a>证书签发</h3><p>证书签发是指使用证书颁发机构（CA）对生成的证书进行签名，以确保证书的可信度。Kubernetes 使用的证书签发通常由集群中的工具或服务自动完成，也可以使用自签名证书。</p><h3 id="证书使用"><a href="#证书使用" class="headerlink" title="证书使用"></a>证书使用</h3><p>签发后的证书用于加密和验证通信。各个组件通过使用对应的证书进行身份验证和加密通信，确保通信的安全性。</p><h3 id="证书更新"><a href="#证书更新" class="headerlink" title="证书更新"></a>证书更新</h3><p>证书有一定的有效期，因此需要定期更新。证书更新可以通过颁发新的证书，并确保新证书在过渡期内逐渐替代旧证书。</p><h2 id="Kubernetes-证书管理示例"><a href="#Kubernetes-证书管理示例" class="headerlink" title="Kubernetes 证书管理示例"></a>Kubernetes 证书管理示例</h2><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>首先，我们通过 OpenSSL 工具生成一个自签名的证书和私钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成私钥</span><br><span class="line">openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line"></span><br><span class="line"># 生成证书请求</span><br><span class="line">openssl req -new -key private-key.pem -out certificate.csr</span><br><span class="line"></span><br><span class="line"># 自签名证书</span><br><span class="line">openssl x509 -req -in certificate.csr -signkey private-key.pem -out certificate.crt</span><br></pre></td></tr></table></figure><h3 id="使用自签名证书"><a href="#使用自签名证书" class="headerlink" title="使用自签名证书"></a>使用自签名证书</h3><p>在 Kubernetes 中，可以将生成的自签名证书用于某个组件的 TLS 配置。以下是一个使用自签名证书配置 Kubernetes API Server 的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: tls-secret</span><br><span class="line">type: kubernetes.io/tls</span><br><span class="line">data:</span><br><span class="line">  tls.crt: &lt;base64-encoded-certificate&gt;</span><br><span class="line">  tls.key: &lt;base64-encoded-private-key&gt;</span><br></pre></td></tr></table></figure><p>然后，在 API Server 的配置文件中引用该 Secret。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-apiserver</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: kube-apiserver</span><br><span class="line">    image: kube-apiserver:latest</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: tls-secret</span><br><span class="line">      mountPath: /etc/tls</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: tls-secret</span><br><span class="line">    secret:</span><br><span class="line">      secretName: tls-secret</span><br></pre></td></tr></table></figure><h3 id="部署使用证书的应用"><a href="#部署使用证书的应用" class="headerlink" title="部署使用证书的应用"></a>部署使用证书的应用</h3><p>在应用的部署配置中，可以指定使用某个 Secret 中的证书。以下是一个 Deployment 使用证书的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: sample-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: sample-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: sample-app</span><br><span class="line">        image: sample-app:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: sample-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: sample-app</span><br><span class="line">        image: sample-app:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">      volumes:</span><br><span class="line">      - name: tls-secret</span><br><span class="line">        secret:</span><br><span class="line">          secretName: tls-secret</span><br></pre></td></tr></table></figure><p>在这个示例中，Deployment 使用了一个名为 tls-secret 的 Secret，其中包含了应用所需的证书和私钥。<br>证书续期与更新</p><p>证书续期和更新是证书管理中的重要环节，以确保证书的有效性。续期是指在证书即将过期时，通过颁发机构（CA）签发新证书。而更新是指将新证书应用到集群中的组件。在 Kubernetes 中，通常通过以下步骤进行证书的续期和更新：</p><ul><li>颁发新证书： 使用 CA 工具颁发新证书。</li><li>将新证书存储为 Secret： 将新证书和私钥存储为 Kubernetes 的 Secret。</li><li>更新使用证书的组件： 更新使用证书的组件，引用新的 Secret。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 示例：更新 Secret 中的证书</span><br><span class="line">kubectl create secret tls new-tls-secret --cert=new-certificate.crt --key=new-private-key.pem</span><br></pre></td></tr></table></figure></li></ul><p>然后，在使用证书的组件的配置中更新 Secret 的引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-apiserver</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: kube-apiserver</span><br><span class="line">    image: kube-apiserver:latest</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: tls-secret</span><br><span class="line">      mountPath: /etc/tls</span><br><span class="line">      readOnly: true</span><br><span class="line">volumes:</span><br><span class="line">- name: tls-secret</span><br><span class="line">  secret:</span><br><span class="line">    secretName: new-tls-secret</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>证书管理是 Kubernetes 集群中至关重要的安全机制之一。通过本文的详细介绍和示例，读者可以更好地理解 Kubernetes 中证书的生成、使用、更新和续期等操作。在实际应用中，合理配置证书管理是确保 Kubernetes 集群通信安全性和稳定性的重要步骤。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件Kube-Scheduler</title>
      <link href="/posts/4a17b626.html"/>
      <url>/posts/4a17b626.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着云原生技术的兴起，Kubernetes（K8S）已成为容器编排领域的事实标准。Kubernetes通过一系列的核心组件来管理和调度容器化应用，其中Kube-Scheduler（调度器）起着至关重要的作用。本文将深入探讨Kube-Scheduler的设计思想、主要功能、内部工作原理以及日常运维等方面，以期帮助读者更深入地理解和使用Kubernetes。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="分布式系统设计理念"><a href="#分布式系统设计理念" class="headerlink" title="分布式系统设计理念"></a>分布式系统设计理念</h3><p>Kube-Scheduler的设计思想基于分布式系统的理念。在一个Kubernetes集群中，可能存在多个节点（Node），每个节点上运行着多个Pod（容器组）。调度器的任务就是在这些节点上选择合适的Pod位置进行调度，以实现资源最优的利用。</p><h3 id="可扩展性和灵活性"><a href="#可扩展性和灵活性" class="headerlink" title="可扩展性和灵活性"></a>可扩展性和灵活性</h3><p>Kube-Scheduler被设计为可扩展和灵活的组件，允许用户根据自身需求进行定制。用户可以通过定义调度策略和扩展调度器的插件来适应不同的业务场景。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="优先级和亲和性调度"><a href="#优先级和亲和性调度" class="headerlink" title="优先级和亲和性调度"></a>优先级和亲和性调度</h3><p>Kube-Scheduler通过优先级和亲和性规则来进行调度决策。优先级规则定义了Pod被调度的优先级，而亲和性规则定义了哪些Pod应该被调度到一起。这两者共同确保了集群中资源的高效利用。</p><h3 id="拓扑感知调度"><a href="#拓扑感知调度" class="headerlink" title="拓扑感知调度"></a>拓扑感知调度</h3><p>Kube-Scheduler支持拓扑感知调度，可以根据节点的拓扑信息（如区域、机架等）来进行调度决策。这有助于提高应用的可靠性和容错性，同时降低网络延迟。</p><h3 id="限制和资源约束"><a href="#限制和资源约束" class="headerlink" title="限制和资源约束"></a>限制和资源约束</h3><p>调度器考虑节点的资源状况，确保Pod被调度到具有足够资源的节点上。这包括CPU、内存、存储等方面的资源限制，以防止节点资源过度占用。</p><h2 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h2><p>3.1 调度流程</p><p>Kube-Scheduler的调度流程可以分为以下几个步骤：</p><ul><li>获取候选节点列表： 获取所有符合Pod资源需求和调度策略的节点列表。</li><li>评分和排序： 对候选节点进行评分，考虑优先级和亲和性规则，生成一个有序的节点列表。</li><li>选举胜出节点： 选择评分最高的节点作为最终的调度目标。</li><li>更新集群状态： 更新集群状态，标记已经被调度的Pod，并更新节点资源信息。</li></ul><h3 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h3><p>Kube-Scheduler支持插件机制，允许用户自定义调度器的行为。用户可以编写插件来实现特定的调度策略，例如自定义优先级算法、节点筛选规则等。</p><h3 id="事件和监控"><a href="#事件和监控" class="headerlink" title="事件和监控"></a>事件和监控</h3><p>调度器会生成事件记录，用于追踪调度过程中发生的事件。监控系统可以通过访问调度器的事件记录来获取有关调度器性能和决策的信息。</p><h2 id="日常运维"><a href="#日常运维" class="headerlink" title="日常运维"></a>日常运维</h2><h3 id="调度器配置"><a href="#调度器配置" class="headerlink" title="调度器配置"></a>调度器配置</h3><p>Kube-Scheduler的配置文件包含了各种调度器的参数，管理员可以根据需要进行调整。调度器的配置文件通常存储在etcd等持久存储中，以确保配置的持久性和一致性。</p><h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p>在集群运维过程中，可能会遇到调度器故障或异常情况。管理员可以通过查看调度器的日志、事件记录以及使用Kubernetes提供的工具来进行故障排查和调度器性能分析。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>对于大规模的集群，性能优化是一个重要的主题。管理员可以通过调整调度器的配置、增加调度器实例的数量，以及合理规划节点资源等方式来优化调度器的性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kube-Scheduler作为Kubernetes的核心组件之一，在容器编排中发挥着重要的作用。通过深入了解其设计思想、主要功能、内部工作原理以及日常运维，可以更好地理解和利用Kube-Scheduler来提高集群的可用性、性能和资源利用率。同时，Kube-Scheduler的可扩展性也为用户提供了丰富的定制和扩展空间，以适应不同的业务场景和需求。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件Controller-Manager</title>
      <link href="/posts/4a17b625.html"/>
      <url>/posts/4a17b625.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Kubernetes（K8s）这一容器编排平台中，Controller Manager（控制器管理器）是一个至关重要的核心组件，承担着自动化管理集群中资源的任务。本文将深入介绍 Controller Manager 的设计思路、主要功能，以及内部控制器的组成，以帮助读者更全面地理解这一关键组件。</p><h2 id="Controller-Manager-设计思路"><a href="#Controller-Manager-设计思路" class="headerlink" title="Controller Manager 设计思路"></a>Controller Manager 设计思路</h2><h3 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h3><p>Kubernetes 中采用了控制器模式，这种模式是一种自动化系统管理的方法。在控制器模式下，系统通过监控实际状态，与用户期望的状态进行比较，并采取必要的措施来使系统状态趋近于期望状态。</p><h3 id="分布式系统设计"><a href="#分布式系统设计" class="headerlink" title="分布式系统设计"></a>分布式系统设计</h3><p>Controller Manager 是一个分布式系统，其多个实例运行在集群的多个节点上，以确保高可用性。每个控制器负责管理一个特定的资源类型，这种设计使得 Controller Manager 能够保持独立性和扩展性，更好地应对集群中复杂的管理任务。</p><h2 id="Controller-Manager-主要功能"><a href="#Controller-Manager-主要功能" class="headerlink" title="Controller Manager 主要功能"></a>Controller Manager 主要功能</h2><h3 id="控制器管理"><a href="#控制器管理" class="headerlink" title="控制器管理"></a>控制器管理</h3><p>Controller Manager 的首要任务是管理各种控制器的生命周期。Kubernetes 中有多个内建的控制器，如 ReplicaSet、Deployment、StatefulSet 等。Controller Manager 通过启动、终止和监控这些控制器的运行状态，来保证集群中的各项资源按照用户定义的期望状态运行。</p><h3 id="控制器逻辑"><a href="#控制器逻辑" class="headerlink" title="控制器逻辑"></a>控制器逻辑</h3><p>每个控制器都有其特定的逻辑，用于监控系统状态并采取相应的行动，以保持系统状态的一致性。这包括资源的创建、删除、更新等操作。例如，ReplicaSet 控制器负责确保集群中运行的 Pod 数量与用户定义的期望数量一致。</p><h3 id="控制循环（Control-Loop）"><a href="#控制循环（Control-Loop）" class="headerlink" title="控制循环（Control Loop）"></a>控制循环（Control Loop）</h3><p>控制器的核心是控制循环，这是一个不断运行的过程，负责监控系统状态并采取相应的操作，使实际状态趋近于期望状态。控制循环的主要步骤包括：</p><ul><li>观察（Observe）： 监控资源对象的实际状态。</li><li>比较（Compare）： 比较实际状态与期望状态的差异。</li><li>调整（Adapt）： 根据比较的结果采取相应的操作，例如创建、删除、更新资源对象。</li></ul><h2 id="内部控制器的组成"><a href="#内部控制器的组成" class="headerlink" title="内部控制器的组成"></a>内部控制器的组成</h2><p>Kubernetes 中的内部控制器是 Controller Manager 的核心组成部分，负责管理不同类型的资源。以下是一些常见的内部控制器：</p><h3 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p>Replication Controller 确保在集群中运行指定数量的 Pod 副本。如果实际运行的副本数量少于期望值，Replication Controller 将创建新的 Pod 副本；如果多于期望值，它将删除多余的副本。</p><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>ReplicaSet 是 Replication Controller 的升级版本，支持更强大的选择器匹配，提供更灵活的 Pod 副本管理。ReplicaSet 用于确保指定数量的 Pod 副本在集群中运行，并支持滚动更新。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 控制器是更高级别的抽象，用于定义应用程序的部署。它管理 ReplicaSet，并提供滚动更新、回滚等功能，使得应用程序的部署和更新更加灵活和可控。</p><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>StatefulSet 控制器用于管理有状态的应用程序，确保这些应用程序的每个副本都有唯一的标识和网络标识符。StatefulSet 通常用于部署数据库等需要持久化存储和唯一标识的应用程序。</p><h2 id="示例演示：使用-Controller-Manager-创建-Deployment"><a href="#示例演示：使用-Controller-Manager-创建-Deployment" class="headerlink" title="示例演示：使用 Controller Manager 创建 Deployment"></a>示例演示：使用 Controller Manager 创建 Deployment</h2><h3 id="创建-Deployment-资源"><a href="#创建-Deployment-资源" class="headerlink" title="创建 Deployment 资源"></a>创建 Deployment 资源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># deployment.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: my-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><h2 id="查看-Deployment-控制器"><a href="#查看-Deployment-控制器" class="headerlink" title="查看 Deployment 控制器"></a>查看 Deployment 控制器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment my-deployment</span><br></pre></td></tr></table></figure><h3 id="观察控制器调整状态"><a href="#观察控制器调整状态" class="headerlink" title="观察控制器调整状态"></a>观察控制器调整状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide --watch</span><br></pre></td></tr></table></figure><p>在另一个终端中删除一个 Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>观察 Controller Manager 通过控制循环调整系统状态，确保实际运行的 Pod 数量与期望数量一致。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Controller Manager 作为 Kubernetes 控制平面的核心组件，通过控制器模式实现对集群状态的自动管理。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心组件API-Server</title>
      <link href="/posts/4a17b624.html"/>
      <url>/posts/4a17b624.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Kubernetes（K8s）中，API Server（API 服务器）是其核心组件之一，扮演着集群管理的关键角色。本文将深入探讨 API Server 的架构设计、主要功能以及提供详细的示例，以帮助读者更好地理解和利用这一核心组件。</p><h2 id="API-Server-架构设计"><a href="#API-Server-架构设计" class="headerlink" title="API Server 架构设计"></a>API Server 架构设计</h2><h3 id="组件关系"><a href="#组件关系" class="headerlink" title="组件关系"></a>组件关系</h3><p>API Server 是 Kubernetes 控制平面的入口，负责处理来自客户端的请求，执行相应的操作。与其他核心组件（如 Etcd、Controller Manager、Scheduler）协同工作，形成整个 Kubernetes 集群的基础架构。</p><h3 id="多层设计"><a href="#多层设计" class="headerlink" title="多层设计"></a>多层设计</h3><p>API Server 采用多层架构设计，其中包括：</p><ul><li>RESTful API 层： 提供基于 HTTP&#x2F;HTTPS 的 RESTful API，定义了资源的操作方式和行为。</li><li>认证授权层： 负责验证请求的合法性，并授予相应的权限。</li><li>Admission Control 层： 实施额外的访问控制策略，允许插入自定义的逻辑。</li><li>业务逻辑层： 处理请求的具体业务逻辑，包括资源的创建、删除、更新等操作。</li></ul><p>这种多层设计使得 API Server 具有较好的扩展性和灵活性，方便集成新的特性和功能。</p><h2 id="API-Server-主要功能"><a href="#API-Server-主要功能" class="headerlink" title="API Server 主要功能"></a>API Server 主要功能</h2><h3 id="提供-RESTful-API"><a href="#提供-RESTful-API" class="headerlink" title="提供 RESTful API"></a>提供 RESTful API</h3><p>API Server 提供了一套 RESTful API，定义了 Kubernetes 集群中的各类资源（Pod、Service、Deployment 等）以及对这些资源的操作。通过 API Server，用户和其他组件可以使用标准的 HTTP&#x2F;HTTPS 请求进行集群管理。</p><h3 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h3><p>API Server 实现了 Kubernetes 集群的身份验证（Authentication）和授权（Authorization）。身份验证确保请求的发起者是合法的用户或组件，而授权则决定该请求是否有足够的权限执行相应的操作。<br>示例：使用 kubectl 进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-credentials myuser --client-certificate=mycert.crt --client-key=mykey.key</span><br><span class="line">kubectl config set-context mycontext --cluster=mycluster --user=myuser</span><br><span class="line">kubectl config use-context mycontext</span><br></pre></td></tr></table></figure><h3 id="Admission-Control"><a href="#Admission-Control" class="headerlink" title="Admission Control"></a>Admission Control</h3><p>Admission Control 是一个可插拔的组件，用于在请求进入 API Server 之前和之后执行一系列操作。这些操作包括验证、转换请求的资源对象等。开发者可以通过 Admission Control 自定义集群的行为，增强安全性和可操作性。<br>示例：禁止创建特定标签的 Pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## 在 Admission Control 配置中添加 PodSecurityPolicy</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  labels:</span><br><span class="line">    forbidden-label: &quot;true&quot;</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mycontainer</span><br><span class="line">    image: nginx:latest</span><br></pre></td></tr></table></figure><h3 id="业务逻辑处理"><a href="#业务逻辑处理" class="headerlink" title="业务逻辑处理"></a>业务逻辑处理</h3><p>API Server 的业务逻辑层包含了对请求的具体处理逻辑，例如创建、删除、更新资源对象等。这一层通过调用不同的存储后端（通常是 Etcd）实现对集群状态的修改。<br>示例：使用 kubectl 创建一个 Deployment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment my-deployment --image=nginx:latest</span><br></pre></td></tr></table></figure><h2 id="示例演示：使用-API-Server-操作集群"><a href="#示例演示：使用-API-Server-操作集群" class="headerlink" title="示例演示：使用 API Server 操作集群"></a>示例演示：使用 API Server 操作集群</h2><h3 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace mynamespace</span><br></pre></td></tr></table></figure><h3 id="部署一个应用程序"><a href="#部署一个应用程序" class="headerlink" title="部署一个应用程序"></a>部署一个应用程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment mynginx --image=nginx:latest --namespace=mynamespace</span><br></pre></td></tr></table></figure><h3 id="查看-Pod-列表"><a href="#查看-Pod-列表" class="headerlink" title="查看 Pod 列表"></a>查看 Pod 列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --namespace=mynamespace</span><br></pre></td></tr></table></figure><h3 id="删除应用程序"><a href="#删除应用程序" class="headerlink" title="删除应用程序"></a>删除应用程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment mynginx --namespace=mynamespace</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>API Server 作为 Kubernetes 控制平面的核心组件，承担着管理整个集群的任务。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s包管理模版Chart语法</title>
      <link href="/posts/4a17b623.html"/>
      <url>/posts/4a17b623.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）生态系统中，Helm 是一款流行的包管理工具，而 Helm Chart 则是用于描述和定义 K8s 应用程序的模板。本文将深入讨论 Helm Chart 的语法，包括 Chart 的结构、模板文件、函数、变量等方面，同时提供详细的示例演示如何使用 Helm Chart 创建和定制 K8s 应用程序。</p><h2 id="Helm-Chart-结构"><a href="#Helm-Chart-结构" class="headerlink" title="Helm Chart 结构"></a>Helm Chart 结构</h2><p>一个 Helm Chart 通常由一组文件和目录组成，其中包含了定义 K8s 应用程序所需的所有信息。以下是一个标准 Helm Chart 的基本结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mychart/</span><br><span class="line">|-- Chart.yaml</span><br><span class="line">|-- values.yaml</span><br><span class="line">|-- charts/</span><br><span class="line">|-- templates/</span><br><span class="line">|   |-- deployment.yaml</span><br><span class="line">|   |-- service.yaml</span><br><span class="line">|-- ...</span><br></pre></td></tr></table></figure><ul><li>Chart.yaml： Chart 的元数据文件，包含 Chart 的名称、版本、描述等信息。</li><li>values.yaml： 默认的配置值文件，用于定义 Chart 的默认配置。</li><li>charts&#x2F;： 用于存放依赖的子 Charts。</li><li>templates&#x2F;： 包含 K8s 资源的模板文件，如 Deployment、Service 等。</li></ul><h2 id="Chart-yaml-文件"><a href="#Chart-yaml-文件" class="headerlink" title="Chart.yaml 文件"></a>Chart.yaml 文件</h2><p>Chart.yaml 文件包含了 Chart 的元数据信息，以下是一个简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v2</span><br><span class="line">name: mychart</span><br><span class="line">description: A Helm chart for my Kubernetes application</span><br><span class="line">version: 0.1.0</span><br></pre></td></tr></table></figure><ul><li>apiVersion： 表示使用的 Helm API 版本，通常为 v2。</li><li>name： Chart 的名称，用于唯一标识 Chart。</li><li>description： Chart 的描述信息，用于说明 Chart 的用途。</li><li>version： Chart 的版本，遵循 Semantic Versioning 规范。</li></ul><h2 id="values-yaml-文件"><a href="#values-yaml-文件" class="headerlink" title="values.yaml 文件"></a>values.yaml 文件</h2><p>values.yaml 文件用于定义 Chart 的默认配置值，以下是一个简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># values.yaml</span><br><span class="line"></span><br><span class="line">replicaCount: 1</span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: stable</span><br><span class="line">  pullPolicy: IfNotPresent</span><br><span class="line">service:</span><br><span class="line">  name: my-service</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure><p>在模板文件中，可以使用这些配置值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># templates/deployment.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;mychart.fullname&quot; . &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: my-container</span><br><span class="line">        image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><p>模板文件位于 templates 目录下，其中包含了 K8s 资源的 YAML 文件，使用 Go 的模板语法进行参数替换。以下是一个简单的 Deployment 模板文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># templates/deployment.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;mychart.fullname&quot; . &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: my-container</span><br><span class="line">        image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p>在这个例子中，.Values.replicaCount 和 .Values.image.repository 是从 values.yaml 文件中获取的配置值。</p><h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><p>Helm 提供了一系列内置的模板函数，用于在模板文件中执行各种操作。以下是一些常用的模板函数：</p><ul><li>include： 用于引入其他模板。</li><li>toYaml： 将对象转换为 YAML 格式。</li><li>tpl： 执行模板字符串，并返回结果。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># templates/service.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Values.service.name | default &quot;default-service&quot; | quote &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  type: &#123;&#123; .Values.service.type &#125;&#125;</span><br><span class="line">  ports:</span><br><span class="line">    - port: &#123;&#123; .Values.service.port &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在这个例子中，使用了 default 函数确保 .Values.service.name 的值存在，并使用 quote 函数将值转换为引号括起来的字符串。</p><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><h3 id="创建一个简单的-Helm-Chart"><a href="#创建一个简单的-Helm-Chart" class="headerlink" title="创建一个简单的 Helm Chart"></a>创建一个简单的 Helm Chart</h3><p>首先，使用 Helm 创建一个新的 Chart：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create mychart</span><br></pre></td></tr></table></figure><p>然后，编辑 values.yaml 文件和 templates&#x2F;deployment.yaml 文件，定义应用程序的配置和 Deployment。</p><h3 id="安装-Chart-到-Kubernetes-集群"><a href="#安装-Chart-到-Kubernetes-集群" class="headerlink" title="安装 Chart 到 Kubernetes 集群"></a>安装 Chart 到 Kubernetes 集群</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install myrelease ./mychart</span><br></pre></td></tr></table></figure><p>这将在 Kubernetes 集群中部署一个应用程序实例，使用 values.yaml 中定义的默认配置。</p><h3 id="定制-Chart-配置"><a href="#定制-Chart-配置" class="headerlink" title="定制 Chart 配置"></a>定制 Chart 配置</h3><p>在安装时，可以通过 –set 参数或 -f 参数指定自定义的配置值文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install myrelease ./mychart --set replicaCount=3</span><br></pre></td></tr></table></figure><p>或者使用自定义的 values 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install myrelease ./mychart -f custom-values.yaml</span><br></pre></td></tr></table></figure><h2 id="Helm-Chart-的高级用法"><a href="#Helm-Chart-的高级用法" class="headerlink" title="Helm Chart 的高级用法"></a>Helm Chart 的高级用法</h2><h3 id="使用-Helm-Secrets-进行敏感信息加密"><a href="#使用-Helm-Secrets-进行敏感信息加密" class="headerlink" title="使用 Helm Secrets 进行敏感信息加密"></a>使用 Helm Secrets 进行敏感信息加密</h3><p>Helm Secrets 是 Helm 的一个插件，可以用于对敏感信息进行加密。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm plugin install https://github.com/jkroepke/helm-secrets</span><br><span class="line">helm secrets init</span><br></pre></td></tr></table></figure><h3 id="使用-Helmfile-进行多-Chart-管理"><a href="#使用-Helmfile-进行多-Chart-管理" class="headerlink" title="使用 Helmfile 进行多 Chart 管理"></a>使用 Helmfile 进行多 Chart 管理</h3><p>Helmfile 是一个声明性的工具，用于管理 Helm Charts 的多个部署。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Helmfile</span><br><span class="line">brew install helmfile</span><br><span class="line"></span><br><span class="line"># 创建 Helmfile.yaml 文件</span><br><span class="line">echo &quot;repositories:</span><br><span class="line">- name: stable</span><br><span class="line">  url: https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line">releases:</span><br><span class="line">- name: myrelease</span><br><span class="line">  namespace: default</span><br><span class="line">  chart: stable/nginx-ingress&quot; &gt; Helmfile.yaml</span><br><span class="line"></span><br><span class="line"># 使用 Helmfile 部署</span><br><span class="line">helmfile sync</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Helm Chart 的语法是深入学习 Helm 的重要一步，它为在 Kubernetes 中部署和管理应用程序提供了便捷和灵活的方式。通过本文的详细介绍和示例，读者可以更好地理解 Helm Chart 的结构、语法和高级用法。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s包管理工具</title>
      <link href="/posts/4a17b622.html"/>
      <url>/posts/4a17b622.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）生态系统中，Helm是一个强大的包管理工具，被广泛用于简化应用程序的部署、升级和管理。本文将深入讨论Helm的基本概念、架构、使用方法，并提供详细的示例演示如何使用Helm在Kubernetes中进行应用程序的打包和部署。</p><h2 id="Helm-基本概念"><a href="#Helm-基本概念" class="headerlink" title="Helm 基本概念"></a>Helm 基本概念</h2><h3 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a>Chart</h3><p>在Helm中，一个Chart是一个预定义的Kubernetes资源包。它包含了用于创建Kubernetes应用程序的所有信息，包括部署、服务、ConfigMap等。Chart可以被认为是一种应用程序的打包形式。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>一个Release是一个特定Chart的运行实例。当您使用Helm部署一个Chart时，将创建一个Release。Release具有唯一的名称，并包含了该应用程序的所有Kubernetes资源。</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>Repository是存储和共享Charts的地方。Helm Repository可以是公共的，也可以是私有的。Charts从Repository中获取，使得它们能够被广泛共享和重复使用。</p><h2 id="Helm-的架构"><a href="#Helm-的架构" class="headerlink" title="Helm 的架构"></a>Helm 的架构</h2><p>Helm的架构包含两个核心组件：</p><h3 id="Helm-客户端"><a href="#Helm-客户端" class="headerlink" title="Helm 客户端"></a>Helm 客户端</h3><p>Helm客户端是一个命令行工具，用于与Kubernetes集群交互。它允许用户创建、打包、发布和部署Charts。Helm客户端负责处理用户输入，并将操作传递给Tiller服务器。</p><h3 id="Tiller-服务器"><a href="#Tiller-服务器" class="headerlink" title="Tiller 服务器"></a>Tiller 服务器</h3><p>Tiller是Helm的服务端组件，运行在Kubernetes集群中。它负责与Kubernetes API Server交互，创建和管理Release，以及将用户请求翻译为Kubernetes资源。Tiller将Charts解析成Kubernetes资源，并在集群中创建相应的对象。</p><h2 id="Helm-使用示例"><a href="#Helm-使用示例" class="headerlink" title="Helm 使用示例"></a>Helm 使用示例</h2><h3 id="安装-Helm"><a href="#安装-Helm" class="headerlink" title="安装 Helm"></a>安装 Helm</h3><p>首先，需要安装Helm客户端。可以从Helm GitHub Releases下载适用于您操作系统的二进制文件，或者使用包管理器进行安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在 Linux 上使用 curl 安装 Helm</span><br><span class="line">curl -LO https://get.helm.sh/helm-v3.7.0-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v3.7.0-linux-amd64.tar.gz</span><br><span class="line">sudo mv linux-amd64/helm /usr/local/bin/helm</span><br></pre></td></tr></table></figure><h3 id="初始化-Helm"><a href="#初始化-Helm" class="headerlink" title="初始化 Helm"></a>初始化 Helm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init</span><br></pre></td></tr></table></figure><h3 id="创建一个-Chart"><a href="#创建一个-Chart" class="headerlink" title="创建一个 Chart"></a>创建一个 Chart</h3><p>使用以下命令创建一个新的Chart：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create mychart</span><br></pre></td></tr></table></figure><p>这将在当前目录下创建一个名为mychart的目录，包含了Chart的基本结构。</p><h3 id="编辑-Chart"><a href="#编辑-Chart" class="headerlink" title="编辑 Chart"></a>编辑 Chart</h3><p>进入mychart目录，编辑values.yaml文件以配置Chart的默认值。然后编辑templates目录下的模板文件，例如deployment.yaml和service.yaml，定义部署和服务的规格。</p><h3 id="打包-Chart"><a href="#打包-Chart" class="headerlink" title="打包 Chart"></a>打包 Chart</h3><p>在Chart目录下运行以下命令将Chart打包成一个tgz文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm package .</span><br></pre></td></tr></table></figure><h3 id="发布-Chart"><a href="#发布-Chart" class="headerlink" title="发布 Chart"></a>发布 Chart</h3><p>将打包的Chart发布到Helm Repository：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm repo add myrepo https://example.com/charts</span><br><span class="line">helm push mychart-0.1.0.tgz myrepo</span><br></pre></td></tr></table></figure><h3 id="部署-Release"><a href="#部署-Release" class="headerlink" title="部署 Release"></a>部署 Release</h3><p>在Kubernetes集群中使用Helm来部署Release：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install myrelease myrepo/mychart</span><br></pre></td></tr></table></figure><h2 id="Helm-的高级用法"><a href="#Helm-的高级用法" class="headerlink" title="Helm 的高级用法"></a>Helm 的高级用法</h2><h3 id="使用-Helm-Secrets-进行敏感信息加密"><a href="#使用-Helm-Secrets-进行敏感信息加密" class="headerlink" title="使用 Helm Secrets 进行敏感信息加密"></a>使用 Helm Secrets 进行敏感信息加密</h3><p>Helm Secrets是一个Helm插件，允许您加密敏感信息并将其存储在Charts中。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm plugin install https://github.com/jkroepke/helm-secrets</span><br><span class="line">helm secrets init</span><br></pre></td></tr></table></figure><h3 id="使用-Helmfile-进行多Chart管理"><a href="#使用-Helmfile-进行多Chart管理" class="headerlink" title="使用 Helmfile 进行多Chart管理"></a>使用 Helmfile 进行多Chart管理</h3><p>Helmfile是一个用于声明性地管理Helm Charts的工具。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Helmfile</span><br><span class="line">brew install helmfile</span><br><span class="line"></span><br><span class="line"># 创建 Helmfile.yaml 文件</span><br><span class="line">echo &quot;repositories:</span><br><span class="line">- name: stable</span><br><span class="line">  url: https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line">releases:</span><br><span class="line">- name: myrelease</span><br><span class="line">  namespace: default</span><br><span class="line">  chart: stable/nginx-ingress&quot; &gt; Helmfile.yaml</span><br><span class="line"></span><br><span class="line"># 使用 Helmfile 部署</span><br><span class="line">helmfile sync</span><br></pre></td></tr></table></figure><h2 id="Helm-的进阶主题"><a href="#Helm-的进阶主题" class="headerlink" title="Helm 的进阶主题"></a>Helm 的进阶主题</h2><h3 id="Helm-3-新特性"><a href="#Helm-3-新特性" class="headerlink" title="Helm 3 新特性"></a>Helm 3 新特性</h3><p>Helm 3引入了一些重要的变化，包括移除Tiller，改进的依赖管理，以及更强大的Chart版本管理。升级到Helm 3后，可以享受到这些新特性。</p><h3 id="使用-Helm-Operator-进行持续交付"><a href="#使用-Helm-Operator-进行持续交付" class="headerlink" title="使用 Helm Operator 进行持续交付"></a>使用 Helm Operator 进行持续交付</h3><p>Helm Operator是一个Kubernetes控制器，用于自动化Helm Charts的部署和更新。它可以与GitOps工作流程集成，实现持续交付。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Helm作为Kubernetes生态系统中的包管理工具，为应用程序的打包、部署和管理提供了强大的工具。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的集群监控概述</title>
      <link href="/posts/4a17b621.html"/>
      <url>/posts/4a17b621.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）作为一款容器编排平台，其集群监控是确保系统稳定性和性能优化的关键方面。本文将介绍常用的几种Kubernetes集群监控方案，并比较各自的优缺点。同时，提供详细的示例演示如何在Kubernetes中配置和使用这些监控工具。</p><h2 id="常用的-Kubernetes-集群监控方案"><a href="#常用的-Kubernetes-集群监控方案" class="headerlink" title="常用的 Kubernetes 集群监控方案"></a>常用的 Kubernetes 集群监控方案</h2><h3 id="Prometheus-Grafana"><a href="#Prometheus-Grafana" class="headerlink" title="Prometheus + Grafana"></a>Prometheus + Grafana</h3><p>优点：</p><ul><li>强大的数据模型： Prometheus使用多维数据模型存储时间序列数据，提供灵活的查询和聚合功能。</li><li>动态服务发现： Prometheus支持自动发现目标，并动态更新配置。</li><li>开源社区支持： Prometheus拥有庞大的开源社区，提供丰富的插件和整合。</li></ul><p>缺点：</p><ul><li>资源消耗： Prometheus在处理大规模集群时可能占用较多资源。</li><li>存储周期： 长时间跨度的历史数据存储可能需要额外的处理。</li></ul><h3 id="Heapster-InfluxDB-Grafana"><a href="#Heapster-InfluxDB-Grafana" class="headerlink" title="Heapster + InfluxDB + Grafana"></a>Heapster + InfluxDB + Grafana</h3><p>优点：</p><ul><li>易于集成： Heapster与Kubernetes深度集成，可以轻松获取集群中的度量数据。</li><li>InfluxDB存储： InfluxDB是时序数据库，适合处理时间序列数据。</li><li>Grafana可视化： Grafana提供直观的图表和仪表板，易于定制。</li></ul><p>缺点：</p><ul><li>Heapster 的局限性： Heapster本身的性能和扩展性存在一些局限性。</li><li>InfluxDB配置： 需要额外配置InfluxDB来满足高可用和数据保留策略。</li></ul><h3 id="Elastic-Stack（ELK-Stack）"><a href="#Elastic-Stack（ELK-Stack）" class="headerlink" title="Elastic Stack（ELK Stack）"></a>Elastic Stack（ELK Stack）</h3><p>优点：</p><ul><li>全面的日志处理： ELK Stack包含Elasticsearch、Logstash和Kibana，提供了全面的日志处理解决方案。</li><li>强大的搜索与分析： Elasticsearch提供强大的搜索和分析能力。</li><li>实时监控： Logstash可以实时处理和分析日志。</li></ul><p>缺点：</p><ul><li>资源占用： ELK Stack的部署可能需要较多资源。</li><li>学习曲线： 对ELK Stack的配置和使用需要一定的学习曲线。</li></ul><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><h3 id="Prometheus-Grafana-示例"><a href="#Prometheus-Grafana-示例" class="headerlink" title="Prometheus + Grafana 示例"></a>Prometheus + Grafana 示例</h3><p>首先，创建一个Prometheus的配置文件 prometheus.yml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kubernetes-pods&#x27;</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: pod</span><br></pre></td></tr></table></figure><p>然后，创建一个Prometheus Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: prometheus</span><br><span class="line">        image: prom/prometheus:latest</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config</span><br><span class="line">          mountPath: /etc/prometheus/prometheus.yml</span><br><span class="line">          subPath: prometheus.yml</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        configMap:</span><br><span class="line">          name: prometheus-config</span><br></pre></td></tr></table></figure><p>最后，创建一个Prometheus Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 9090</span><br><span class="line">    targetPort: 9090</span><br></pre></td></tr></table></figure><h3 id="Heapster-InfluxDB-Grafana-示例"><a href="#Heapster-InfluxDB-Grafana-示例" class="headerlink" title="Heapster + InfluxDB + Grafana 示例"></a>Heapster + InfluxDB + Grafana 示例</h3><p>首先，创建一个Heapster Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: heapster</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: heapster</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: heapster</span><br><span class="line">        image: k8s.gcr.io/heapster:v1.5.2</span><br><span class="line">        command:</span><br><span class="line">        - /heapster</span><br><span class="line">        - --source=kubernetes.summary_api:&#x27;&#x27;</span><br><span class="line">        - --sink=influxdb:http://influxdb-influxdb.kube-system.svc:8086</span><br></pre></td></tr></table></figure><p>然后，创建一个InfluxDB Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: influxdb</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: influxdb</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: influxdb</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: influxdb</span><br><span class="line">        image: influxdb:1.7.8</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8086</span><br></pre></td></tr></table></figure><p>最后，创建一个Grafana Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: grafana</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: grafana</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: grafana</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: grafana</span><br><span class="line">        image: grafana/grafana:5.2.4</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3000</span><br></pre></td></tr></table></figure><h3 id="Elastic-Stack-示例"><a href="#Elastic-Stack-示例" class="headerlink" title="Elastic Stack 示例"></a>Elastic Stack 示例</h3><p>首先，创建一个Elasticsearch Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: elasticsearch</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: elasticsearch</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: elasticsearch</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: elasticsearch</span><br><span class="line">        image: docker.elastic.co/elasticsearch/elasticsearch:7.2.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9200</span><br><span class="line">        - containerPort: 9300</span><br></pre></td></tr></table></figure><p>然后，创建一个Logstash Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: logstash</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: logstash</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: logstash</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: logstash</span><br><span class="line">        image: docker.elastic.co/logstash/logstash:7.2.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 5044</span><br></pre></td></tr></table></figure><p>最后，创建一个Kibana Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kibana</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kibana</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kibana</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kibana</span><br><span class="line">        image: docker.elastic.co/kibana/kibana:7.2.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 5601</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Kubernetes集群监控是确保系统健康和性能优化的必要环节。通过本文的详细介绍和示例，读者可以更好地理解和比较常用的监控方案，以及如何在Kubernetes中配置和使用这些监控工具。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的日志管理概述</title>
      <link href="/posts/4a17b620.html"/>
      <url>/posts/4a17b620.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，广泛用于部署、扩展和管理容器化应用。在Kubernetes集群中，日志管理是一个至关重要的任务，用于监控、故障排除和性能优化。本文将深入讨论Kubernetes中的日志管理，包括容器日志、集群级别日志以及相关的工具和实践。同时，提供详细的示例演示如何在Kubernetes中进行有效的日志管理。</p><h2 id="容器日志管理"><a href="#容器日志管理" class="headerlink" title="容器日志管理"></a>容器日志管理</h2><p>在Kubernetes中，容器是应用程序的最小部署单元，每个容器都会生成日志。容器日志对于故障排除、性能监控和应用程序追踪至关重要。以下是容器日志管理的关键方面：</p><h3 id="容器日志格式"><a href="#容器日志格式" class="headerlink" title="容器日志格式"></a>容器日志格式</h3><p>容器日志通常以文本格式输出到stdout和stderr。应用程序可以选择输出到不同的文件或使用不同的日志库，但建议将关键信息输出到stdout和stderr，以便Kubernetes可以方便地收集和处理。</p><h3 id="容器日志收集"><a href="#容器日志收集" class="headerlink" title="容器日志收集"></a>容器日志收集</h3><p>Kubernetes通过Kubelet来收集容器日志。Kubelet负责监视Pod中每个容器的日志文件，并将其发送到集中的日志存储。日志存储可以是本地文件系统、集中式日志服务器（如ELK Stack）或云服务提供商的日志服务。</p><h3 id="容器日志示例"><a href="#容器日志示例" class="headerlink" title="容器日志示例"></a>容器日志示例</h3><p>以下是一个简单的Pod定义示例，展示了如何将容器的stdout和stderr输出到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mycontainer</span><br><span class="line">    image: myimage:latest</span><br><span class="line">    command: [&quot;./myapp&quot;]</span><br><span class="line">    args: [&quot;arg1&quot;, &quot;arg2&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs</span><br><span class="line">      mountPath: /var/log/myapp</span><br><span class="line">  volumes:</span><br><span class="line">  - name: logs</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，mycontainer容器的stdout和stderr将输出到&#x2F;var&#x2F;log&#x2F;myapp目录下。</p><h2 id="集群级别日志管理"><a href="#集群级别日志管理" class="headerlink" title="集群级别日志管理"></a>集群级别日志管理</h2><p>除了容器日志，Kubernetes还提供了一些集群级别的日志，用于监控和维护整个集群的健康状态。</p><h3 id="API-Server-日志"><a href="#API-Server-日志" class="headerlink" title="API Server 日志"></a>API Server 日志</h3><p>API Server是Kubernetes控制平面的核心组件，负责处理API请求。API Server的日志包含了请求和响应的详细信息，对于排查API请求问题非常有用。</p><h3 id="Controller-Manager-和-Scheduler-日志"><a href="#Controller-Manager-和-Scheduler-日志" class="headerlink" title="Controller Manager 和 Scheduler 日志"></a>Controller Manager 和 Scheduler 日志</h3><p>Controller Manager负责运行集群级别的控制器，而Scheduler负责决定Pod在哪个节点上运行。它们的日志包含了控制器的操作和Pod的调度决策信息。</p><h3 id="Kubelet-日志"><a href="#Kubelet-日志" class="headerlink" title="Kubelet 日志"></a>Kubelet 日志</h3><p>Kubelet是运行在每个节点上的代理，负责管理节点上的容器。Kubelet的日志包含了与容器生命周期和状态相关的信息。</p><h3 id="Etcd-日志"><a href="#Etcd-日志" class="headerlink" title="Etcd 日志"></a>Etcd 日志</h3><p>Etcd是Kubernetes集群的分布式键值存储，存储了整个集群的状态。Etcd的日志对于监控集群状态和排查故障非常关键。</p><h2 id="Kubernetes-日志管理工具"><a href="#Kubernetes-日志管理工具" class="headerlink" title="Kubernetes 日志管理工具"></a>Kubernetes 日志管理工具</h2><p>为了更有效地管理Kubernetes中的日志，通常会使用专门的工具。以下是一些常用的Kubernetes日志管理工具：</p><h3 id="kubectl-logs"><a href="#kubectl-logs" class="headerlink" title="kubectl logs"></a>kubectl logs</h3><p>kubectl logs是Kubernetes的命令行工具，用于查看Pod的容器日志。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs mypod mycontainer</span><br></pre></td></tr></table></figure><h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h3><p>Fluentd是一种流式数据收集器，可以在Kubernetes中用于收集、过滤和转发日志。它可以与各种输出插件集成，将日志发送到不同的目的地。</p><h3 id="Elasticsearch-Logstash-Kibana-ELK-Stack"><a href="#Elasticsearch-Logstash-Kibana-ELK-Stack" class="headerlink" title="Elasticsearch, Logstash, Kibana (ELK Stack)"></a>Elasticsearch, Logstash, Kibana (ELK Stack)</h3><p>ELK Stack是一组流行的开源工具，用于日志收集、存储和可视化。Elasticsearch用于存储日志，Logstash用于日志的收集和过滤，Kibana用于创建仪表板和可视化日志数据。</p><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>Prometheus是一款开源的监控和警报工具，可以用于收集和存储Kubernetes集群中的度量和日志。它与Grafana等工具集成，提供了强大的监控和可视化功能。</p><h2 id="日志查询与过滤"><a href="#日志查询与过滤" class="headerlink" title="日志查询与过滤"></a>日志查询与过滤</h2><p>在实际运维中，需要对大量的日志进行查询和过滤，以便找到关键信息。以下是一些常用的日志查询和过滤方法：</p><h3 id="kubectl-logs-查询"><a href="#kubectl-logs-查询" class="headerlink" title="kubectl logs 查询"></a>kubectl logs 查询</h3><p>使用kubectl logs命令可以在终端中直接查询Pod的日志。可以使用-f参数实时跟踪日志，使用–since和–until参数指定时间范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f --since=1h mypod mycontainer</span><br></pre></td></tr></table></figure><h3 id="Fluentd-过滤"><a href="#Fluentd-过滤" class="headerlink" title="Fluentd 过滤"></a>Fluentd 过滤</h3><p>Fluentd可以通过配置过滤器对日志进行过滤。例如，可以使用正则表达式过滤掉不需要的日志行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter kubernetes.var.log.containers.**&gt;</span><br><span class="line">  @type grep</span><br><span class="line">  &lt;regexp&gt;</span><br><span class="line">    key log</span><br><span class="line">    pattern ^INFO</span><br><span class="line">  &lt;/regexp&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure><h3 id="ELK-Stack-查询"><a href="#ELK-Stack-查询" class="headerlink" title="ELK Stack 查询"></a>ELK Stack 查询</h3><p>在ELK Stack中，可以使用Kibana的查询语句对日志进行灵活的搜索和过滤。例如，可以通过Kibana的搜索栏使用Lucene查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log: &quot;error&quot; AND pod_name: &quot;mypod&quot;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Kubernetes日志管理是确保集群正常运行和故障排除的关键部分。通过本文的详细介绍和示例，读者可以更好地理解Kubernetes中容器和集群级别的日志管理机制，以及如何使用不同的工具和方法进行日志查询和过滤。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的pod驱逐</title>
      <link href="/posts/4a17b617.html"/>
      <url>/posts/4a17b617.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，具有强大的调度和管理能力。在容器化应用部署到Kubernetes集群时，由于各种原因（例如节点故障、资源不足等），可能会触发Pod的驱逐操作。本文将深入探讨Kubernetes中Pod的驱逐机制，解释驱逐的原因、策略以及如何优雅地处理Pod的驱逐，同时提供详细的示例演示实际应用场景中的驱逐操作。</p><h2 id="什么是Pod的驱逐？"><a href="#什么是Pod的驱逐？" class="headerlink" title="什么是Pod的驱逐？"></a>什么是Pod的驱逐？</h2><p>Pod的驱逐是指Kubernetes系统自动终止运行中的Pod，并将其重新调度到其他节点的过程。驱逐通常发生在以下情况下：</p><ul><li>节点故障： 当节点发生故障或不可用时，Kubernetes会将该节点上运行的Pod驱逐，以确保应用的高可用性。</li><li>资源不足： 当节点资源（如CPU、内存）不足以满足Pod的需求时，调度器可能会决定驱逐某些Pod，以释放资源并为其他Pod腾出空间。</li></ul><p>在驱逐发生时，Kubernetes调度器会尽量保持系统的稳定性，确保驱逐的Pod在其他节点上得到合理的重新调度。</p><h2 id="驱逐的原因"><a href="#驱逐的原因" class="headerlink" title="驱逐的原因"></a>驱逐的原因</h2><p>Pod被驱逐的主要原因有两种：节点故障和资源不足。</p><h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h3><p>节点故障是指节点发生硬件故障、网络问题或其他无法正常运行的情况。为了确保应用的高可用性，Kubernetes会监测节点的健康状态，一旦发现节点不可用，系统会触发驱逐操作，将节点上的Pod重新调度到其他健康的节点上。</p><h3 id="资源不足"><a href="#资源不足" class="headerlink" title="资源不足"></a>资源不足</h3><p>资源不足是指节点上的资源（如CPU、内存）无法满足Pod的需求。Kubernetes调度器会根据Pod的资源请求和节点的资源容量进行调度决策，当资源不足时，调度器可能选择将某些Pod从节点上驱逐，以满足其他Pod的需求。</p><h2 id="驱逐策略"><a href="#驱逐策略" class="headerlink" title="驱逐策略"></a>驱逐策略</h2><p>Kubernetes提供了一些驱逐策略，以确保Pod在驱逐时能够以最小的影响重新调度。以下是一些常见的驱逐策略：</p><h3 id="优雅终止"><a href="#优雅终止" class="headerlink" title="优雅终止"></a>优雅终止</h3><p>优雅终止是指Pod在被驱逐之前，系统会发送终止信号（SIGTERM）给Pod中的应用程序，等待一段时间（称为terminationGracePeriodSeconds），以确保应用程序能够完成正在进行中的任务，并释放资源。如果在等待时间内应用程序未能正常终止，系统将发送强制终止信号（SIGKILL）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: graceful-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx:latest</span><br><span class="line">  terminationGracePeriodSeconds: 30</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个Pod，并设置了terminationGracePeriodSeconds为30秒，即在驱逐前等待30秒，以便应用程序有足够的时间完成工作。</p><h3 id="PodDisruptionBudget"><a href="#PodDisruptionBudget" class="headerlink" title="PodDisruptionBudget"></a>PodDisruptionBudget</h3><p>PodDisruptionBudget（PDB）是一种用于限制Pod驱逐速率的资源。通过定义PDB，可以控制在任何给定时间内可被驱逐的Pod数量，以确保系统的稳定性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodDisruptionBudget</span><br><span class="line">metadata:</span><br><span class="line">  name: web-pdb</span><br><span class="line">spec:</span><br><span class="line">  maxUnavailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为web-pdb的PodDisruptionBudget，限制了同一时间最多只能有1个标签为app: web的Pod被驱逐。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个运行在Kubernetes集群中的Web应用程序，由于某些原因需要进行节点维护。我们希望在进行维护时，尽量减少对用户的影响，通过设置Pod的优雅终止和PodDisruptionBudget来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: web-app</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web-container</span><br><span class="line">    image: web-app:latest</span><br><span class="line">  terminationGracePeriodSeconds: 30</span><br><span class="line">---</span><br><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodDisruptionBudget</span><br><span class="line">metadata:</span><br><span class="line">  name: web-pdb</span><br><span class="line">spec:</span><br><span class="line">  maxUnavailable: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为web-app的Pod，设置了terminationGracePeriodSeconds为30秒，同时创建了一个名为web-pdb的PodDisruptionBudget，限制了同一时间最多只能有1个标签为app: web的Pod被驱逐。</p><p>通过这样的设置，当进行节点维护时，Kubernetes将以优雅的方式终止Pod，并确保在任何给定时间内最多只有1个Pod被驱逐，以减少对用户的影响。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Pod的驱逐是Kubernetes中一个重要的调度和管理机制，通过设置驱逐策略，可以确保在节点故障或资源不足时系统行为稳定，最大程度地减少对应用程序的影响。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的pod优先级PriorityClass</title>
      <link href="/posts/4a17b616.html"/>
      <url>/posts/4a17b616.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，其调度系统负责将容器化应用程序合理地分配到集群中的节点上。Pod的优先级管理是Kubernetes调度中的一个重要特性，通过PriorityClass（优先级类）的设置，我们可以为Pod指定不同的优先级，从而在资源有限的情况下更精细地调整调度顺序。本文将深入探讨PriorityClass的概念、用法，并通过详细的示例演示如何在实际场景中应用PriorityClass。</p><h2 id="什么是PriorityClass？"><a href="#什么是PriorityClass？" class="headerlink" title="什么是PriorityClass？"></a>什么是PriorityClass？</h2><p>PriorityClass是Kubernetes中用于指定Pod优先级的机制。通过为Pod分配不同的优先级，K8s调度器可以更好地管理资源，确保高优先级的Pod被更优先地调度。PriorityClass主要由以下几个组件构成：</p><ul><li>name： 优先级类的名称，用于标识该类。</li><li>value： 优先级的数值，数值越大，优先级越高。</li><li>globalDefault： 是否将该优先级类设为全局默认，即在没有为Pod指定PriorityClass的情况下使用该类的优先级。</li><li>description： 对优先级类的描述。</li></ul><p>以下是一个简单的PriorityClass示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: high-priority</span><br><span class="line">value: 1000</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;High priority class&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为high-priority的PriorityClass，其优先级为1000，不将其设为全局默认。该类被描述为“High priority class”。</p><h2 id="PriorityClass的基本结构"><a href="#PriorityClass的基本结构" class="headerlink" title="PriorityClass的基本结构"></a>PriorityClass的基本结构</h2><p>在使用PriorityClass之前，我们需要了解其基本结构。PriorityClass主要由上述几个组件构成，其中name和value是必需的，globalDefault和description是可选的。以下是一个PriorityClass的详细说明：</p><ul><li>name： 优先级类的名称，是一个字符串，用于标识PriorityClass。同一集群中不允许存在两个相同名称的PriorityClass。</li><li>value： 优先级的数值，是一个整数，用于确定PriorityClass的优先级。数值越大，优先级越高。</li><li>globalDefault： 是否将该优先级类设为全局默认。如果设为true，则该类将在没有为Pod指定PriorityClass的情况下使用，全局默认只能有一个。</li><li>description： 对优先级类的描述，是一个可选的字符串，用于说明该类的用途和意义。</li></ul><h2 id="PriorityClass的使用方法"><a href="#PriorityClass的使用方法" class="headerlink" title="PriorityClass的使用方法"></a>PriorityClass的使用方法</h2><h3 id="定义PriorityClass"><a href="#定义PriorityClass" class="headerlink" title="定义PriorityClass"></a>定义PriorityClass</h3><p>要使用PriorityClass，首先需要定义一个或多个PriorityClass。以下是一个带有多个PriorityClass的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: low-priority</span><br><span class="line">value: 10</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;Low priority class&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: medium-priority</span><br><span class="line">value: 50</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;Medium priority class&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: high-priority</span><br><span class="line">value: 100</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;High priority class&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了三个PriorityClass，分别是low-priority、medium-priority和high-priority，它们的优先级分别为10、50和100。每个类都有相应的描述，说明了其用途。</p><h3 id="应用PriorityClass到Pod"><a href="#应用PriorityClass到Pod" class="headerlink" title="应用PriorityClass到Pod"></a>应用PriorityClass到Pod</h3><p>将定义好的PriorityClass应用到实际的Pod。以下是一个示例，演示了如何在Pod中指定PriorityClass：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: high-priority-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx:latest</span><br><span class="line">  priorityClassName: high-priority</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为high-priority-pod的Pod，并通过priorityClassName字段将该Pod的优先级指定为high-priority，即高优先级。</p><h3 id="验证PriorityClass"><a href="#验证PriorityClass" class="headerlink" title="验证PriorityClass"></a>验证PriorityClass</h3><p>通过查看Pod的描述，我们可以验证PriorityClass是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与指定的PriorityClass相对应的信息，确认Pod是否按照预期被调度。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个Kubernetes集群，其中运行着多个应用程序，这些应用程序对资源的需求和重要性不同。我们希望通过PriorityClass实现对这些应用程序的灵活调度。以下是一个示例，演示了如何在集群中使用PriorityClass：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: low-importance</span><br><span class="line">value: 10</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;Low importance class&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: medium-importance</span><br><span class="line">value: 50</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;Medium importance class&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: scheduling.k8s.io/v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: high-importance</span><br><span class="line">value: 100</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;High importance class&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: important-app-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: important-app-container</span><br><span class="line">    image: important-app:latest</span><br><span class="line">  priorityClassName: high-importance</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: regular-app-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: regular-app-container</span><br><span class="line">    image: regular-app:latest</span><br><span class="line">  priorityClassName: medium-importance</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: background-app-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: background-app-container</span><br><span class="line">    image: background-app:latest</span><br><span class="line">  priorityClassName: low-importance</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了三个PriorityClass，分别是low-importance、medium-importance和high-importance，它们的优先级分别为10、50和100。然后，我们创建了三个Pod，important-app-pod、regular-app-pod和background-app-pod，分别指定了对应的PriorityClass。这样，通过PriorityClass，我们实现了对这三个应用程序的灵活调度，确保重要应用程序优先被调度。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Pod优先级（PriorityClass）是Kubernetes中非常有用的调度特性，通过为Pod分配不同的优先级，我们可以更灵活地调整资源的调度顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s调度之污点与容忍度</title>
      <link href="/posts/4a17b615.html"/>
      <url>/posts/4a17b615.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，具有强大的调度系统，负责将容器化应用程序合理地分配到集群中的节点上。在K8s中，通过污点（Taints）和容忍度（Tolerations）的机制，可以实现对节点的特性进行标记和容忍，从而实现更灵活的调度策略。本文将深入讨论污点与容忍度的概念、用法，并通过详细的示例演示如何在实际场景中应用这两个特性。</p><h2 id="什么是污点与容忍度？"><a href="#什么是污点与容忍度？" class="headerlink" title="什么是污点与容忍度？"></a>什么是污点与容忍度？</h2><p>在Kubernetes中，污点是一种用于标记节点的机制，它表示该节点上可能存在某些不适用于所有Pod的特性，如特定硬件、操作系统等。而容忍度则是Pod对污点的响应机制，它定义了Pod是否可以被调度到带有特定污点的节点上。</p><p>污点和容忍度的主要应用场景包括：</p><ul><li>硬件差异： 将某个节点标记为具有特定硬件特性，如GPU，然后只有那些具备相应容忍度的Pod才能被调度到该节点上。</li><li>操作系统需求： 标记一些节点为运行特定操作系统的节点，只有设置了相应容忍度的Pod才能被调度到这些节点上。</li><li>节点负载限制： 将一些节点标记为负载较高，只有具备相应容忍度的Pod才能被调度到这些节点上，以实现负载均衡。</li></ul><h2 id="污点（Taints）的基本结构"><a href="#污点（Taints）的基本结构" class="headerlink" title="污点（Taints）的基本结构"></a>污点（Taints）的基本结构</h2><p>在使用污点之前，我们需要了解其基本结构。一个节点可以被标记为具有一个或多个污点，每个污点都由以下几个组件构成：</p><ul><li>key： 污点的键，用于标识污点。</li><li>value： 污点的值，与键一起形成唯一的标识。</li><li>effect： 污点的作用效果，包括NoSchedule（不调度）、PreferNoSchedule（尽量不调度）和NoExecute（驱逐已有Pod）。</li></ul><p>以下是一个简单的节点污点示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: node-1</span><br><span class="line">spec:</span><br><span class="line">  taints:</span><br><span class="line">  - key: &quot;special&quot;</span><br><span class="line">    value: &quot;gpu&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们将名为node-1的节点标记为具有一个特殊的污点，键为special，值为gpu，作用效果为NoSchedule，表示不允许调度普通Pod到这个节点上。<br>容忍度（Tolerations）的基本结构</p><p>容忍度是Pod对污点的响应机制，它定义了Pod是否可以被调度到带有特定污点的节点上。每个容忍度都由以下几个组件构成：</p><ul><li>key： 容忍度的键，与污点的键进行匹配。</li><li>operator： 匹配操作符，包括Exists（键存在）、Equal（键值匹配）等。</li><li>value： 匹配的值，与污点的值进行匹配。</li><li>effect： 匹配成功后的生效效果，包括NoSchedule（不调度）、PreferNoSchedule（尽量不调度）和NoExecute（驱逐已有Pod）。</li></ul><p>以下是一个简单的Pod容忍度示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: tolerant-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx:latest</span><br><span class="line">  tolerations:</span><br><span class="line">  - key: &quot;special&quot;</span><br><span class="line">    operator: &quot;Equal&quot;</span><br><span class="line">    value: &quot;gpu&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为tolerant-pod的Pod，定义了容忍度，表示该Pod可以被调度到带有special键为gpu值的节点上。</p><h2 id="污点与容忍度的使用方法"><a href="#污点与容忍度的使用方法" class="headerlink" title="污点与容忍度的使用方法"></a>污点与容忍度的使用方法</h2><h3 id="定义节点污点"><a href="#定义节点污点" class="headerlink" title="定义节点污点"></a>定义节点污点</h3><p>要使用污点，首先需要在节点的定义中配置污点。以下是一个带有多个污点的节点定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: node-2</span><br><span class="line">spec:</span><br><span class="line">  taints:</span><br><span class="line">  - key: &quot;special&quot;</span><br><span class="line">    value: &quot;gpu&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">  - key: &quot;critical&quot;</span><br><span class="line">    value: &quot;high-load&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为node-2的节点，它被标记为具有两个污点。第一个污点的键为special，值为gpu，作用效果为NoSchedule。第二个污点的键为critical，值为high-load，同样作用效果为NoSchedule。</p><h3 id="定义Pod容忍度"><a href="#定义Pod容忍度" class="headerlink" title="定义Pod容忍度"></a>定义Pod容忍度</h3><p>将定义好的污点应用于实际的Pod。以下是一个示例，演示了如何在Pod中定义容忍度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: tolerant-pod-2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx:latest</span><br><span class="line">  tolerations:</span><br><span class="line">  - key: &quot;special&quot;</span><br><span class="line">    operator: &quot;Equal&quot;</span><br><span class="line">    value: &quot;gpu&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">  - key: &quot;critical&quot;</span><br><span class="line">    operator: &quot;Exists&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为tolerant-pod-2的Pod，定义了两个容忍度。第一个容忍度表示该Pod可以被调度到带有special键为gpu值的节点上，而第二个容忍度表示该Pod可以被调度到带有critical键的节点上。</p><h3 id="验证污点与容忍度"><a href="#验证污点与容忍度" class="headerlink" title="验证污点与容忍度"></a>验证污点与容忍度</h3><p>通过查看节点和Pod的描述，我们可以验证污点与容忍度是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;node-name&gt;</span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与定义的污点和容忍度相对应的信息，确认节点是否被正确标记为有污点，以及Pod是否被正确容忍。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个Kubernetes集群，其中包含一些具有GPU的节点，同时一些节点负载较高。我们希望确保GPU密集型的Pod能够被调度到具有GPU的节点上，并且负载较高的Pod能够避免被调度到负载已经较高的节点上。通过污点与容忍度，我们可以实现这一需求。</p><p>以下是一个示例，演示了如何在集群中使用污点与容忍度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: gpu-node</span><br><span class="line">spec:</span><br><span class="line">  taints:</span><br><span class="line">  - key: &quot;gpu&quot;</span><br><span class="line">    value: &quot;true&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: high-load-node</span><br><span class="line">spec:</span><br><span class="line">  taints:</span><br><span class="line">  - key: &quot;load&quot;</span><br><span class="line">    value: &quot;high&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: gpu-intensive-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: gpu-container</span><br><span class="line">    image: gpu-intensive-app:latest</span><br><span class="line">  tolerations:</span><br><span class="line">  - key: &quot;gpu&quot;</span><br><span class="line">    operator: &quot;Equal&quot;</span><br><span class="line">    value: &quot;true&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: low-load-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: low-load-container</span><br><span class="line">    image: low-load-app:latest</span><br><span class="line">  tolerations:</span><br><span class="line">  - key: &quot;load&quot;</span><br><span class="line">    operator: &quot;Exists&quot;</span><br><span class="line">    effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个节点，分别是gpu-node和high-load-node，它们分别被标记为具有gpu和load的污点。然后，我们创建了两个Pod，gpu-intensive-pod和low-load-pod，它们分别定义了对应的容忍度。gpu-intensive-pod容忍gpu污点，而low-load-pod容忍load污点。</p><p>通过这样的方式，我们可以实现GPU密集型Pod被调度到具有GPU的节点上，而负载较低的Pod避免被调度到负载较高的节点上。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>污点与容忍度是Kubernetes中非常有用的调度特性，通过定义节点的污点和Pod的容忍度，实现了对集群资源的更细粒度控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s调度之拓扑分布TopologySpreadConstraints</title>
      <link href="/posts/4a17b614.html"/>
      <url>/posts/4a17b614.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，其调度系统能够智能地将容器化应用程序部署到集群中的节点。在分布式系统中，节点的负载均衡是至关重要的，而TopologySpreadConstraints（拓扑分散约束）正是K8s调度器的一个关键特性。本文将深入讨论TopologySpreadConstraints的概念、用法，并通过详细的示例演示如何在实际场景中应用TopologySpreadConstraints。</p><h2 id="什么是TopologySpreadConstraints？"><a href="#什么是TopologySpreadConstraints？" class="headerlink" title="什么是TopologySpreadConstraints？"></a>什么是TopologySpreadConstraints？</h2><p>TopologySpreadConstraints是K8s中一种用于调整Pod在集群中分布的机制。它允许我们定义一组规则，指导调度器确保Pod在各个拓扑域（Topology Domain）中得到均匀分布。拓扑域可以是节点、机架、区域等，这有助于提高应用程序的可用性和鲁棒性。</p><p>TopologySpreadConstraints的主要应用场景包括：</p><ul><li>故障隔离： 将同一应用程序的Pod分散在不同节点、机架或区域，以防止单一点故障引起的影响。</li><li>资源均衡： 在集群中均匀分布Pod，以确保各个节点的资源利用率相对平衡，提高整体性能。</li><li>地理位置感知： 在跨多地域的集群中，通过TopologySpreadConstraints实现Pod的地理位置感知调度，降低跨地域通信的延迟。</li></ul><h2 id="TopologySpreadConstraints的基本结构"><a href="#TopologySpreadConstraints的基本结构" class="headerlink" title="TopologySpreadConstraints的基本结构"></a>TopologySpreadConstraints的基本结构</h2><p>在使用TopologySpreadConstraints之前，我们需要了解其基本结构。TopologySpreadConstraints主要由以下几个组件构成：</p><ul><li>maxSkew： 定义了期望的最大偏差，表示允许不同拓扑域的Pod数量差异。</li><li>topologyKey： 定义了用于拓扑域的标签键。</li><li>whenUnsatisfiable： 定义了在无法满足约束条件时的行为，可以选择”DoNotSchedule”（不调度）或”ScheduleAnyway”（继续调度）。</li></ul><p>以下是一个简单的TopologySpreadConstraints示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: spread-constraints-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: spread-constraints-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: spread-constraints-app</span><br><span class="line">    spec:</span><br><span class="line">      topologySpreadConstraints:</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: spread-constraints-container</span><br><span class="line">        image: spread-constraints-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为spread-constraints-deployment的Deployment，其中的Pod被标记为app: spread-constraints-app。通过TopologySpreadConstraints的设置，我们要求这些Pod在调度时具有拓扑分散约束，即它们应该在kubernetes.io&#x2F;hostname拓扑域上均匀分布，且允许最大偏差为1。</p><h2 id="TopologySpreadConstraints的使用方法"><a href="#TopologySpreadConstraints的使用方法" class="headerlink" title="TopologySpreadConstraints的使用方法"></a>TopologySpreadConstraints的使用方法</h2><h3 id="定义TopologySpreadConstraints"><a href="#定义TopologySpreadConstraints" class="headerlink" title="定义TopologySpreadConstraints"></a>定义TopologySpreadConstraints</h3><p>要使用TopologySpreadConstraints，首先需要在Pod的定义中配置ToplogySpreadConstraints。以下是一个带有多个拓扑域的TopologySpreadConstraints的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: complex-constraints-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: complex-constraints-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: complex-constraints-app</span><br><span class="line">    spec:</span><br><span class="line">      topologySpreadConstraints:</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;rack&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;zone&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: complex-constraints-container</span><br><span class="line">        image: complex-constraints-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为complex-constraints-deployment的Deployment，其中的Pod被标记为app: complex-constraints-app。通过TopologySpreadConstraints的设置，我们要求这些Pod在调度时具有多个拓扑域的拓扑分散约束，分别在kubernetes.io&#x2F;hostname、rack和zone拓扑域上均匀分布，且允许最大偏差为1。</p><h3 id="应用TopologySpreadConstraints"><a href="#应用TopologySpreadConstraints" class="headerlink" title="应用TopologySpreadConstraints"></a>应用TopologySpreadConstraints</h3><p>将定义好的TopologySpreadConstraints应用于实际的应用场景。以下是一个示例，演示了如何在一个具有多个节点、机架和区域的集群中使用TopologySpreadConstraints：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: spread-across-nodes-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: spread-across-nodes-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: spread-across-nodes-app</span><br><span class="line">    spec:</span><br><span class="line">      topologySpreadConstraints:</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;rack&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;zone&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: spread-across-nodes-container</span><br><span class="line">        image: spread-across-nodes-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为spread-across-nodes-deployment的Deployment，其中的Pod被标记为app: spread-across-nodes-app。通过TopologySpreadConstraints的设置，我们要求这些Pod在调度时具有节点、机架和区域的拓扑分散约束，分别在kubernetes.io&#x2F;hostname、rack和zone拓扑域上均匀分布，且允许最大偏差为1。</p><h3 id="验证TopologySpreadConstraints"><a href="#验证TopologySpreadConstraints" class="headerlink" title="验证TopologySpreadConstraints"></a>验证TopologySpreadConstraints</h3><p>通过查看Pod的描述，我们可以验证TopologySpreadConstraints是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与TopologySpreadConstraints中定义的拓扑域和条件相对应的信息，确认Pod是否按照预期被调度到了符合约束的节点上。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个大型Kubernetes集群，由于某些原因，我们希望确保同一应用程序的Pod在整个集群中得到均匀分布，同时考虑到节点、机架和区域的拓扑域因素。通过TopologySpreadConstraints，我们可以实现这一需求。</p><p>以下是一个示例，演示了如何在一个大型集群中使用TopologySpreadConstraints：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: uniform-distribution-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: uniform-distribution-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: uniform-distribution-app</span><br><span class="line">    spec:</span><br><span class="line">      topologySpreadConstraints:</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;rack&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      - maxSkew: 1</span><br><span class="line">        topologyKey: &quot;zone&quot;</span><br><span class="line">        whenUnsatisfiable: &quot;DoNotSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: uniform-distribution-container</span><br><span class="line">        image: uniform-distribution-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为uniform-distribution-deployment的Deployment，其中的Pod被标记为app: uniform-distribution-app。通过TopologySpreadConstraints的设置，我们要求这些Pod在调度时具有节点、机架和区域的拓扑分散约束，分别在kubernetes.io&#x2F;hostname、rack和zone拓扑域上均匀分布，且允许最大偏差为1。</p><p>通过这样的方式，我们可以确保同一应用程序的Pod在整个集群中得到均匀分布，提高应用程序的可用性和鲁棒性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>TopologySpreadConstraints是Kubernetes中非常有用的调度特性，通过定义Pod在集群中的拓扑分散约束，实现节点的负载均衡。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s调度之NodeAffinity</title>
      <link href="/posts/4a17b613.html"/>
      <url>/posts/4a17b613.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，通过调度系统，能够智能地将容器化应用程序部署到集群中的节点。Node Affinity是Kubernetes调度器的一个重要特性，它允许开发者通过定义Pod与节点之间的亲和性关系，影响Pod的调度位置。本文将深入讨论Node Affinity的概念、用法，并通过详细的示例演示如何在实际场景中应用Node Affinity。</p><h2 id="什么是Node-Affinity？"><a href="#什么是Node-Affinity？" class="headerlink" title="什么是Node Affinity？"></a>什么是Node Affinity？</h2><p>Node Affinity是Kubernetes调度器的一种机制，用于指定Pod与节点之间的亲和性关系。通过Node Affinity，我们可以要求或禁止将某个Pod调度到具有特定亲和性关系的节点上，以满足应用程序的性能和资源需求。</p><p>Node Affinity的主要应用场景包括：</p><ul><li>硬件亲和性： 将需要特定硬件资源的Pod调度到具有相应硬件标签的节点上。</li><li>数据本地性： 将依赖特定数据存储的Pod调度到具有相同存储特性的节点上。</li><li>地理位置感知： 将需要在同一地理位置运行的Pod调度到具有相同地理位置标签的节点上。</li></ul><h2 id="Node-Affinity的基本结构"><a href="#Node-Affinity的基本结构" class="headerlink" title="Node Affinity的基本结构"></a>Node Affinity的基本结构</h2><p>在使用Node Affinity之前，我们需要了解其基本结构。Node Affinity通过以下两个关键组件来实现：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution： 指定Pod必须调度到具有特定标签的节点上。</li><li>preferredDuringSchedulingIgnoredDuringExecution： 指定Pod更倾向于调度到具有特定标签的节点上，但不是必须的。</li></ul><p>以下是一个简单的Node Affinity示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: &quot;gpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: affinity-container</span><br><span class="line">        image: affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为affinity-deployment的Deployment，其中的Pod被标记为app: affinity-app。通过Node Affinity的设置，我们要求这些Pod在调度时具有硬件亲和性，即它们应该被调度到具有gpu: true标签的节点上。</p><h2 id="Node-Affinity的使用方法"><a href="#Node-Affinity的使用方法" class="headerlink" title="Node Affinity的使用方法"></a>Node Affinity的使用方法</h2><h3 id="定义Node-Affinity"><a href="#定义Node-Affinity" class="headerlink" title="定义Node Affinity"></a>定义Node Affinity</h3><p>要使用Node Affinity，首先需要在Pod的定义中配置Affinity。以下是一个具有多个匹配条件的Node Affinity的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: complex-affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: complex-affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: complex-affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: &quot;gpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">              - key: &quot;cpu&quot;</span><br><span class="line">                operator: NotIn</span><br><span class="line">                values:</span><br><span class="line">                - &quot;low-performance&quot;</span><br><span class="line">          preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - weight: 100</span><br><span class="line">            preference:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;zone&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;us-west&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: complex-affinity-container</span><br><span class="line">        image: complex-affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为complex-affinity-deployment的Deployment，其中的Pod被标记为app: complex-affinity-app。通过Node Affinity的设置，我们要求这些Pod在调度时具有硬件亲和性：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution条件表示，这些Pod必须被调度到具有gpu: true且不具有cpu: low-performance标签的节点上。</li><li>preferredDuringSchedulingIgnoredDuringExecution条件表示，如果可能，这些Pod更倾向于被调度到具有zone: us-west标签的节点上，并设置了100的权重。</li></ul><h3 id="应用Node-Affinity"><a href="#应用Node-Affinity" class="headerlink" title="应用Node Affinity"></a>应用Node Affinity</h3><p>将定义好的Node Affinity应用于实际的应用场景。以下是一个示例，演示了如何在一个具有多个硬件配置的集群中使用Node Affinity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: hardware-affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: hardware-affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: hardware-affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: &quot;gpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">          preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - weight: 50</span><br><span class="line">            preference:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;cpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;high-performance&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: hardware-affinity-container</span><br><span class="line">        image: hardware-affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为hardware-affinity-deployment的Deployment，其中的Pod被标记为app: hardware-affinity-app。通过Node Affinity的设置，我们要求这些Pod在调度时具有硬件亲和性：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution条件表示，这些Pod必须被调度到具有gpu: true标签的节点上。</li><li>preferredDuringSchedulingIgnoredDuringExecution条件表示，如果可能，这些Pod更倾向于被调度到具有cpu: high-performance标签的节点上，并设置了50的权重。</li></ul><h3 id="验证Node-Affinity"><a href="#验证Node-Affinity" class="headerlink" title="验证Node Affinity"></a>验证Node Affinity</h3><p>通过查看Pod的描述，我们可以验证Node Affinity是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与Node Affinity中定义的标签和条件相对应的信息，确认Pod是否按照预期被调度到了正确的节点上。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个具有多种硬件配置的Kubernetes集群，我们有两类应用程序，一类需要GPU资源，另一类则对CPU性能更为敏感。通过Node Affinity，我们可以实现这一资源分配策略。</p><p>以下是一个示例，演示了如何在一个具有多种硬件配置的集群中使用Node Affinity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: gpu-intensive-app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: gpu-intensive-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: gpu-intensive-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: &quot;gpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: gpu-intensive-app-container</span><br><span class="line">        image: gpu-intensive-app:latest</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: high-performance-app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: high-performance-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: high-performance-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: &quot;cpu&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;high-performance&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: high-performance-app-container</span><br><span class="line">        image: high-performance-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个Deployment，分别属于gpu-intensive-app和high-performance-app两个应用程序。通过Node Affinity的设置，我们要求：</p><ul><li>gpu-intensive-app的Pod必须被调度到具有gpu: true标签的节点上。</li><li>high-performance-app的Pod必须被调度到具有cpu: high-performance标签的节点上。</li></ul><p>通过这样的方式，我们可以灵活地控制不同类型应用程序的资源分配，更好地利用集群中不同节点的硬件特性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Node Affinity是Kubernetes中非常有用的调度特性，通过定义Pod与节点之间的亲和性关系，影响Pod的调度位置。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s调度之PodAffinity</title>
      <link href="/posts/4a17b612.html"/>
      <url>/posts/4a17b612.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，其强大的调度系统能够智能地将容器化应用程序部署到集群中的节点。Pod Affinity是Kubernetes调度器的一个重要特性，它通过定义Pod之间的关系来影响它们的调度位置。本文将深入讨论Pod Affinity的概念、用法，并通过详细的示例演示如何在实际场景中应用Pod Affinity。</p><h2 id="什么是Pod-Affinity？"><a href="#什么是Pod-Affinity？" class="headerlink" title="什么是Pod Affinity？"></a>什么是Pod Affinity？</h2><p>Pod Affinity是一种调度策略，用于指定Pod应该如何与其他Pod或节点进行亲和性关联。通过Pod Affinity，我们可以要求或禁止将某个Pod调度到与其他Pod具有特定亲和性关系的节点上。</p><p>Pod Affinity的主要应用场景包括：</p><ul><li>故障区域感知： 将同一应用程序的Pod调度到不同的故障区域，提高应用程序的高可用性。</li><li>数据本地性： 将需要紧密协同工作的Pod调度到同一节点，减少网络延迟，提高性能。</li><li>硬件依赖性： 将依赖相同硬件资源的Pod调度到同一节点，避免硬件争用。</li></ul><h2 id="Pod-Affinity的基本结构"><a href="#Pod-Affinity的基本结构" class="headerlink" title="Pod Affinity的基本结构"></a>Pod Affinity的基本结构</h2><p>在使用Pod Affinity之前，我们需要了解其基本结构。Pod Affinity通过以下两个关键组件来实现：</p><ul><li>topologyKey： 定义了用于匹配节点的拓扑域的标签键。</li><li>labelSelector： 用于匹配其他Pod的标签选择器。</li></ul><p>以下是一个简单的Pod Affinity示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;app&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - affinity-app</span><br><span class="line">            topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: affinity-container</span><br><span class="line">        image: affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为affinity-deployment的Deployment，其中的Pod被标记为app: affinity-app。通过Pod Affinity的设置，我们要求这些Pod在调度时具有亲和性，即它们应该被调度到具有相同kubernetes.io&#x2F;hostname标签的节点上。</p><h2 id="Pod-Affinity的使用方法"><a href="#Pod-Affinity的使用方法" class="headerlink" title="Pod Affinity的使用方法"></a>Pod Affinity的使用方法</h2><h3 id="定义Pod-Affinity"><a href="#定义Pod-Affinity" class="headerlink" title="定义Pod Affinity"></a>定义Pod Affinity</h3><p>要使用Pod Affinity，首先需要在Pod的定义中配置Affinity。以下是一个具有多个标签匹配条件的Pod Affinity的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: complex-affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: complex-affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: complex-affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;app&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - complex-affinity-app</span><br><span class="line">              - key: &quot;env&quot;</span><br><span class="line">                operator: NotIn</span><br><span class="line">                values:</span><br><span class="line">                - production</span><br><span class="line">            topologyKey: &quot;kubernetes.io/hostname&quot;</span><br><span class="line">          preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - weight: 100</span><br><span class="line">            podAffinityTerm:</span><br><span class="line">              labelSelector:</span><br><span class="line">                matchExpressions:</span><br><span class="line">                - key: &quot;app&quot;</span><br><span class="line">                  operator: In</span><br><span class="line">                  values:</span><br><span class="line">                  - complex-affinity-app</span><br><span class="line">              topologyKey: &quot;failure-domain.beta.kubernetes.io/zone&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: complex-affinity-container</span><br><span class="line">        image: complex-affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为complex-affinity-deployment的Deployment，其中的Pod被标记为app: complex-affinity-app。通过Pod Affinity的设置，我们要求这些Pod在调度时具有亲和性：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution条件表示，这些Pod必须被调度到具有相同kubernetes.io&#x2F;hostname标签且不在production环境的节点上。</li><li>preferredDuringSchedulingIgnoredDuringExecution条件表示，如果可能，这些Pod更喜欢被调度到具有相同failure-domain.beta.kubernetes.io&#x2F;zone标签的节点上，并设置了100的权重。</li></ul><h3 id="应用Pod-Affinity"><a href="#应用Pod-Affinity" class="headerlink" title="应用Pod Affinity"></a>应用Pod Affinity</h3><p>将定义好的Pod Affinity应用于实际的应用场景。以下是一个示例，演示了如何在一个具有多个故障区域的集群中使用Pod Affinity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: zone-affinity-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zone-affinity-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zone-affinity-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;app&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - zone-affinity-app</span><br><span class="line">            topologyKey: &quot;failure-domain.beta.kubernetes.io/zone&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: zone-affinity-container</span><br><span class="line">        image: zone-affinity-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为zone-affinity-deployment的Deployment，其中的Pod被标记为app: zone-affinity-app。通过Pod Affinity的设置，我们要求这些Pod在调度时具有亲和性，即它们应该被调度到具有相同failure-domain.beta.kubernetes.io&#x2F;zone标签的节点上。</p><h3 id="验证Pod-Affinity"><a href="#验证Pod-Affinity" class="headerlink" title="验证Pod Affinity"></a>验证Pod Affinity</h3><p>通过查看Pod的描述，我们可以验证Pod Affinity是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与Pod Affinity中定义的标签和条件相对应的信息，确认Pod是否按照预期被调度到了正确的节点上。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个具有多个故障区域（Zone）的Kubernetes集群，我们希望某个应用程序的Pod在调度时具有故障区域感知的亲和性。通过Pod Affinity，我们可以实现这一需求。</p><p>以下是一个示例，演示了如何在一个具有三个故障区域的集群中使用Pod Affinity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: zone-aware-app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zone-aware-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zone-aware-app</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: &quot;app&quot;</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - zone-aware-app</span><br><span class="line">            topologyKey: &quot;failure-domain.beta.kubernetes.io/zone&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: zone-aware-app-container</span><br><span class="line">        image: zone-aware-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为zone-aware-app-deployment的Deployment，其中的Pod被标记为app: zone-aware-app。通过Pod Affinity的设置，我们要求这些Pod在调度时具有故障区域感知的亲和性，即它们应该被调度到具有相同failure-domain.beta.kubernetes.io&#x2F;zone标签的节点上。</p><p>通过这样的方式，我们可以确保同一应用程序的Pod分散在不同的故障区域，提高应用程序的高可用性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Pod Affinity是Kubernetes中非常有用的调度特性，通过定义Pod之间的关系来影响它们的调度位置。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s调度之NodeSelector</title>
      <link href="/posts/4a17b611.html"/>
      <url>/posts/4a17b611.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款用于容器编排的开源平台，其强大的调度系统能够智能地将容器化应用程序部署到集群中的节点。NodeSelector是Kubernetes调度器的一个重要特性，它允许开发者通过标签（Labels）来指定Pod应该调度到哪些节点上。本文将深入探讨NodeSelector的概念、用法，并通过详细的示例演示如何在实际场景中应用NodeSelector。</p><h2 id="什么是NodeSelector？"><a href="#什么是NodeSelector？" class="headerlink" title="什么是NodeSelector？"></a>什么是NodeSelector？</h2><p>NodeSelector是Kubernetes调度器的一部分，它允许开发者根据节点的标签，精确地控制Pod在集群中的调度位置。通过在Pod的定义中设置NodeSelector，可以确保Pod只会被调度到具有特定标签的节点上。</p><p>NodeSelector的主要用途包括：</p><ul><li>资源隔离： 将不同类型的应用程序或服务调度到专门标记的节点上，以便更好地隔离资源。</li><li>硬件约束： 根据节点的硬件特性（如GPU、CPU架构）将Pod调度到特定的节点上。</li><li>地理位置： 在多地域集群中，通过NodeSelector将Pod调度到特定地理位置的节点上，以降低网络延迟。</li><li>版本控制： 将Pod调度到具有特定软件版本或配置的节点上，以便更好地控制应用程序的版本。</li></ul><h2 id="NodeSelector的基本结构"><a href="#NodeSelector的基本结构" class="headerlink" title="NodeSelector的基本结构"></a>NodeSelector的基本结构</h2><p>在使用NodeSelector之前，我们首先需要了解其基本结构。NodeSelector是通过Pod的标签和节点的标签之间的匹配来实现的。以下是一个简单的NodeSelector示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example-container</span><br><span class="line">    image: nginx</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为example-pod的Pod，它包含一个名为example-container的容器，使用了Nginx镜像。关键部分是nodeSelector字段，其中我们指定了一个标签disktype: ssd。这表示该Pod应该被调度到具有标签disktype&#x3D;ssd的节点上。</p><h2 id="NodeSelector的使用方法"><a href="#NodeSelector的使用方法" class="headerlink" title="NodeSelector的使用方法"></a>NodeSelector的使用方法</h2><h3 id="定义NodeSelector"><a href="#定义NodeSelector" class="headerlink" title="定义NodeSelector"></a>定义NodeSelector</h3><p>要使用NodeSelector，首先需要定义节点的标签，以及需要在Pod中匹配的标签。以下是一个包含NodeSelector的Pod和节点的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: node-1</span><br><span class="line">  labels:</span><br><span class="line">    disktype: ssd</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: node-2</span><br><span class="line">  labels:</span><br><span class="line">    disktype: hdd</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example-container</span><br><span class="line">    image: nginx</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了两个节点（node-1和node-2），它们分别被标记为disktype&#x3D;ssd和disktype&#x3D;hdd。然后，我们创建了一个Pod（example-pod），并通过NodeSelector指定了标签disktype: ssd。这意味着该Pod只会被调度到disktype&#x3D;ssd的节点上。</p><h3 id="应用NodeSelector"><a href="#应用NodeSelector" class="headerlink" title="应用NodeSelector"></a>应用NodeSelector</h3><p>将定义好的NodeSelector应用于实际的应用场景。以下是一个更为复杂的示例，演示了如何在一个应用中使用NodeSelector来实现资源隔离：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: frontend-container</span><br><span class="line">        image: frontend-app:latest</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disktype: ssd</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: backend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: backend-container</span><br><span class="line">        image: backend-app:latest</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disktype: hdd</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个Deployment（frontend-deployment和backend-deployment），分别属于frontend和backend两个应用程序。每个Deployment中的Pod都有自己的NodeSelector，分别指定了disktype: ssd和disktype: hdd。这样一来，frontend应用程序的Pod将只会被调度到disktype&#x3D;ssd的节点上，而backend应用程序的Pod将只会被调度到disktype&#x3D;hdd的节点上，实现了资源的隔离。</p><h3 id="验证NodeSelector"><a href="#验证NodeSelector" class="headerlink" title="验证NodeSelector"></a>验证NodeSelector</h3><p>通过查看Pod的描述，我们可以验证NodeSelector是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与NodeSelector中定义的标签相对应的信息，确认Pod是否按照预期被调度到了正确的节点上。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个具有不同硬件配置的Kubernetes集群，其中包含既有SSD又有HDD的节点。我们有两类应用程序，一类需要高性能的SSD，另一类则对存储容量更为敏感，需要调度到HDD上。通过NodeSelector，我们可以轻松实现这一资源分配策略。</p><p>以下是一个示例，演示了如何在一个具有不同硬件配置的集群中使用NodeSelector：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: ssd-node-1</span><br><span class="line">  labels:</span><br><span class="line">    disktype: ssd</span><br><span class="line">    cpu: high-performance</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: ssd-node-2</span><br><span class="line">  labels:</span><br><span class="line">    disktype: ssd</span><br><span class="line">    cpu: high-performance</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: hdd-node-1</span><br><span class="line">  labels:</span><br><span class="line">    disktype: hdd</span><br><span class="line">    cpu: standard</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Node</span><br><span class="line">metadata:</span><br><span class="line">  name: hdd-node-2</span><br><span class="line">  labels:</span><br><span class="line">    disktype: hdd</span><br><span class="line">    cpu: standard</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: high-performance-app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: high-performance-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: high-performance-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: high-performance-app-container</span><br><span class="line">        image: high-performance-app:latest</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disktype: ssd</span><br><span class="line">        cpu: high-performance</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: standard-app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: standard-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: standard-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: standard-app-container</span><br><span class="line">        image: standard-app:latest</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disktype: hdd</span><br><span class="line">        cpu: standard</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了四个节点，其中两个节点被标记为disktype&#x3D;ssd，另外两个节点被标记为disktype&#x3D;hdd。每类节点都有相应的CPU性能标签。然后，我们创建了两个Deployment，分别属于high-performance-app和standard-app两个应用程序。每个Deployment中的Pod都有自己的NodeSelector，分别指定了适合自己的硬件和CPU配置。这样一来，high-performance-app将只会被调度到disktype&#x3D;ssd且cpu&#x3D;high-performance的节点上，而standard-app将只会被调度到disktype&#x3D;hdd且cpu&#x3D;standard的节点上。</p><p>通过这样的方式，我们可以灵活地控制不同类型应用程序的资源分配，更好地利用集群中不同节点的硬件特性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>NodeSelector是Kubernetes中非常有用的调度特性，能够通过标签的匹配关系实现对Pod的精细控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s资源管理对象LimitRange</title>
      <link href="/posts/4a17b610.html"/>
      <url>/posts/4a17b610.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）是一款开源的容器编排平台，被广泛应用于容器化应用的部署和管理。在Kubernetes中，资源管理是一个至关重要的方面，它确保集群中的各个应用程序得到适当的资源分配，以保障系统的性能和稳定性。LimitRange（资源限制范围）是Kubernetes中用于定义容器资源限制的一种机制。本文将详细介绍LimitRange的概念、使用方法以及通过示例演示其在实际场景中的应用。</p><h2 id="什么是LimitRange？"><a href="#什么是LimitRange？" class="headerlink" title="什么是LimitRange？"></a>什么是LimitRange？</h2><p>在Kubernetes中，LimitRange是一种资源管理对象，用于设置容器的资源限制。通过LimitRange，可以限制容器在运行时可以使用的资源，如CPU和内存。这有助于防止应用程序无限制地消耗系统资源，避免因为某个应用程序占用过多资源而影响其他应用程序的正常运行。</p><p>LimitRange的主要作用包括：</p><ul><li>限制资源使用量： 可以设置每个容器可以使用的CPU和内存的最大值。</li><li>默认值设置： 可以为容器设置默认的资源限制，确保即使未显式指定资源限制的容器也不会无限制地占用资源。</li><li>防止资源浪费： 通过设置资源的最小值，可以确保应用程序不会过度请求资源，从而避免资源浪费。</li></ul><h2 id="LimitRange的基本结构"><a href="#LimitRange的基本结构" class="headerlink" title="LimitRange的基本结构"></a>LimitRange的基本结构</h2><p>在使用LimitRange之前，我们首先需要了解其基本结构。一个LimitRange对象通常包含以下几个主要字段：</p><ul><li>type： 定义资源限制的类型，通常包括Container、Pod等。</li><li>defaultRequest： 设置默认的资源请求值。</li><li>defaultLimit： 设置默认的资源限制值。</li><li>min： 设置资源的最小值。</li><li>max： 设置资源的最大值。</li></ul><h2 id="LimitRange的使用方法"><a href="#LimitRange的使用方法" class="headerlink" title="LimitRange的使用方法"></a>LimitRange的使用方法</h2><h3 id="定义LimitRange"><a href="#定义LimitRange" class="headerlink" title="定义LimitRange"></a>定义LimitRange</h3><p>要使用LimitRange，首先需要在Kubernetes中定义一个LimitRange对象。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: LimitRange</span><br><span class="line">metadata:</span><br><span class="line">  name: example-limitrange</span><br><span class="line">spec:</span><br><span class="line">  limits:</span><br><span class="line">  - type: Container</span><br><span class="line">    defaultRequest:</span><br><span class="line">      memory: 64Mi</span><br><span class="line">      cpu: 250m</span><br><span class="line">    defaultLimit:</span><br><span class="line">      memory: 128Mi</span><br><span class="line">      cpu: 500m</span><br><span class="line">    min:</span><br><span class="line">      memory: 32Mi</span><br><span class="line">      cpu: 100m</span><br><span class="line">    max:</span><br><span class="line">      memory: 256Mi</span><br><span class="line">      cpu: 1</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为example-limitrange的LimitRange对象。它应用于容器（type为Container），并设置了默认的资源请求和资源限制，以及资源的最小和最大值。</p><h3 id="应用LimitRange"><a href="#应用LimitRange" class="headerlink" title="应用LimitRange"></a>应用LimitRange</h3><p>将定义好的LimitRange应用于Pod或Namespace。以下是一个将LimitRange应用于Namespace的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: example-namespace</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: LimitRange</span><br><span class="line">metadata:</span><br><span class="line">  name: example-limitrange</span><br><span class="line">spec:</span><br><span class="line">  limits:</span><br><span class="line">  - type: Container</span><br><span class="line">    defaultRequest:</span><br><span class="line">      memory: 64Mi</span><br><span class="line">      cpu: 250m</span><br><span class="line">    defaultLimit:</span><br><span class="line">      memory: 128Mi</span><br><span class="line">      cpu: 500m</span><br><span class="line">    min:</span><br><span class="line">      memory: 32Mi</span><br><span class="line">      cpu: 100m</span><br><span class="line">    max:</span><br><span class="line">      memory: 256Mi</span><br><span class="line">      cpu: 1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">  namespace: example-namespace</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example-container</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个名为example-namespace的Namespace，并在其中定义了前面提到的LimitRange对象。然后，我们创建了一个Pod（example-pod），它位于example-namespace命名空间中。这个Pod中包含一个名为example-container的容器，它使用了Nginx镜像。</p><p>由于我们在Namespace中定义了LimitRange，该Pod中的容器将受到LimitRange中定义的资源限制。</p><h3 id="检查资源限制"><a href="#检查资源限制" class="headerlink" title="检查资源限制"></a>检查资源限制</h3><p>通过查看Pod的描述，我们可以验证资源限制是否被正确应用。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">kubectl describe pod example-pod -n example-namespace</span><br></pre></td></tr></table></figure><p>在输出中，你应该能够看到与LimitRange中定义的资源请求和资源限制相对应的信息。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>假设我们有一个包含多个应用程序的Kubernetes集群，这些应用程序具有不同的资源需求。为了确保每个应用程序都能获得适当的资源，并且不会无限制地占用资源，我们可以使用LimitRange进行资源管理。</p><p>以下是一个更为复杂的LimitRange示例，用于一个Namespace中的多个应用程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: app-namespace</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: LimitRange</span><br><span class="line">metadata:</span><br><span class="line">  name: app-limitrange</span><br><span class="line">spec:</span><br><span class="line">  limits:</span><br><span class="line">  - type: Container</span><br><span class="line">    defaultRequest:</span><br><span class="line">      memory: 128Mi</span><br><span class="line">      cpu: 250m</span><br><span class="line">    defaultLimit:</span><br><span class="line">      memory: 256Mi</span><br><span class="line">      cpu: 500m</span><br><span class="line">    min:</span><br><span class="line">      memory: 64Mi</span><br><span class="line">      cpu: 100m</span><br><span class="line">    max:</span><br><span class="line">      memory: 512Mi</span><br><span class="line">      cpu: 1</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend-deployment</span><br><span class="line">  namespace: app-namespace</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: frontend-container</span><br><span class="line">        image: frontend-app:latest</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-deployment</span><br><span class="line">  namespace: app-namespace</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: backend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: backend-container</span><br><span class="line">        image: backend-app:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为app-namespace的Namespace，并定义了一个LimitRange对象（app-limitrange）。该LimitRange适用于容器，并设置了默认的资源请求和资源限制，以及资源的最小和最大值。</p><p>然后，我们创建了两个Deployment（frontend-deployment和backend-deployment），它们分别属于frontend和backend两个应用程序。由于这些Deployment属于app-namespace命名空间，它们将受到app-limitrange中定义的资源限制。</p><p>通过这样的方式，我们可以确保不同应用程序在运行时得到适当的资源分配，防止资源浪费和不合理的资源占用。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过LimitRange，Kubernetes提供了一种灵活而强大的机制，用于管理容器的资源。通过定义资源请求、资源限制以及默认值，可以确保集群中的应用程序在运行时得到适当的资源分配。在实际应用中，结合Namespace和Deployment等其他Kubernetes对象，LimitRange能够更好地满足复杂应用场景中的资源管理需求。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理对象PodSecurity-admission-webhook</title>
      <link href="/posts/4a17b609.html"/>
      <url>/posts/4a17b609.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，PodSecurity Admission Webhook是一种高级权限管理机制，用于在Pod创建或更新时对安全策略进行动态审查和控制。通过PodSecurity Admission Webhook，集群管理员可以实现更灵活、个性化的安全控制，以适应不同场景和业务需求。本文将深入研究Kubernetes中的PodSecurity Admission Webhook，包括其基本概念、工作原理、创建方式以及详细示例。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>PodSecurity Admission Webhook是Kubernetes中的一种自定义的准入控制（Admission Control）插件，用于对Pod的安全策略进行动态审核和控制。它允许管理员定义自己的安全规则，并在Pod创建或更新时对这些规则进行验证。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PodSecurity Admission Webhook的主要作用是增强Kubernetes的准入控制能力，通过自定义的安全策略对Pod进行审查。它可以检查Pod的特权状态、容器镜像、资源限制等，并根据定义的规则拒绝或允许Pod的创建或更新。</p><h3 id="与其他权限管理对象的关系"><a href="#与其他权限管理对象的关系" class="headerlink" title="与其他权限管理对象的关系"></a>与其他权限管理对象的关系</h3><p>PodSecurity Admission Webhook通常与其他权限管理对象如PodSecurityPolicy、RBAC等结合使用，以实现综合性的权限管理。通过PodSecurity Admission Webhook，可以更灵活地定义和执行特定场景下的安全策略。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="Webhook注册"><a href="#Webhook注册" class="headerlink" title="Webhook注册"></a>Webhook注册</h3><p>首先，管理员需要在Kubernetes集群中注册PodSecurity Admission Webhook。这涉及到创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration资源，用于定义Webhook的配置信息。</p><h3 id="Pod创建或更新触发Webhook"><a href="#Pod创建或更新触发Webhook" class="headerlink" title="Pod创建或更新触发Webhook"></a>Pod创建或更新触发Webhook</h3><p>当用户尝试创建或更新Pod时，Kubernetes Admission Controller会触发Webhook。这时，请求将被发送到Webhook的端点，并等待Webhook的响应。</p><h3 id="Webhook处理请求"><a href="#Webhook处理请求" class="headerlink" title="Webhook处理请求"></a>Webhook处理请求</h3><p>Webhook接收到请求后，执行定义的安全策略检查，包括但不限于对特权容器、容器镜像、挂载卷等的检查。根据策略的结果，Webhook返回允许或拒绝的决定。</p><h3 id="Admission-Controller处理Webhook的响应"><a href="#Admission-Controller处理Webhook的响应" class="headerlink" title="Admission Controller处理Webhook的响应"></a>Admission Controller处理Webhook的响应</h3><p>Kubernetes Admission Controller接收到Webhook的响应后，根据允许或拒绝的决定来决定是否允许该Pod的创建或更新。</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><h3 id="编写Webhook-Server"><a href="#编写Webhook-Server" class="headerlink" title="编写Webhook Server"></a>编写Webhook Server</h3><p>首先，需要编写一个符合Kubernetes Admission Webhook规范的Webhook Server。这通常包括定义处理逻辑、验证请求、生成响应等功能。</p><h3 id="创建证书和私钥"><a href="#创建证书和私钥" class="headerlink" title="创建证书和私钥"></a>创建证书和私钥</h3><p>为Webhook Server创建TLS证书和私钥，以确保通信的安全性。</p><h3 id="创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration"><a href="#创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration" class="headerlink" title="创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration"></a>创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration</h3><p>根据Webhook Server的配置信息，创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration资源，并将Webhook的地址和证书信息填入配置中。</p><h3 id="部署Webhook-Server"><a href="#部署Webhook-Server" class="headerlink" title="部署Webhook Server"></a>部署Webhook Server</h3><p>将编写好的Webhook Server以及相关证书和私钥部署到Kubernetes集群中。</p><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><p>在示例中，我们将演示如何创建一个简单的PodSecurity Admission Webhook，以检查Pod的特权状态，并拒绝特权容器的创建。</p><h3 id="步骤一：编写Webhook-Server"><a href="#步骤一：编写Webhook-Server" class="headerlink" title="步骤一：编写Webhook Server"></a>步骤一：编写Webhook Server</h3><p>编写一个简单的Webhook Server，用于检查Pod的特权状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type AdmissionReview struct &#123;</span><br><span class="line">Response AdmissionResponse `json:&quot;response&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AdmissionResponse struct &#123;</span><br><span class="line">Allowed bool   `json:&quot;allowed&quot;`</span><br><span class="line">Result  Result `json:&quot;result&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Result struct &#123;</span><br><span class="line">Message string `json:&quot;message&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">var review AdmissionReview</span><br><span class="line">err := json.NewDecoder(r.Body).Decode(&amp;review)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">http.Error(w, &quot;Error decoding admission review&quot;, http.StatusBadRequest)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check if the pod is privileged</span><br><span class="line">if review.Response.Allowed &#123;</span><br><span class="line">for _, container := range r.Response.PodSpec.Containers &#123;</span><br><span class="line">if container.SecurityContext.Privileged &#123;</span><br><span class="line">review.Response.Allowed = false</span><br><span class="line">review.Response.Result.Message = &quot;Privileged containers are not allowed&quot;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := json.Marshal(review)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">http.Error(w, &quot;Error encoding admission response&quot;, http.StatusInternalServerError)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line">w.Write(resp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">http.HandleFunc(&quot;/&quot;, handler)</span><br><span class="line">fmt.Println(&quot;Webhook server listening on :443&quot;)</span><br><span class="line">err := http.ListenAndServeTLS</span><br><span class="line">if err != nil &#123; fmt.Printf(&quot;Error starting server: %v\n&quot;, err) &#125; &#125;</span><br></pre></td></tr></table></figure><p>perl</p><h3 id="步骤二：创建证书和私钥"><a href="#步骤二：创建证书和私钥" class="headerlink" title="步骤二：创建证书和私钥"></a>步骤二：创建证书和私钥</h3><p>使用openssl等工具创建Webhook Server的TLS证书和私钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout server.key -out server.crt -days 365</span><br></pre></td></tr></table></figure><h3 id="步骤三：创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration"><a href="#步骤三：创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration" class="headerlink" title="步骤三：创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration"></a>步骤三：创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration</h3><p>创建MutatingWebhookConfiguration和ValidatingWebhookConfiguration资源，定义Webhook的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># mutatingwebhook.yaml</span><br><span class="line">apiVersion: admissionregistration.k8s.io/v1</span><br><span class="line">kind: MutatingWebhookConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: example-mutating-webhook</span><br><span class="line">webhooks:</span><br><span class="line">- name: mutating.webhook.example.com</span><br><span class="line">  clientConfig:</span><br><span class="line">    service:</span><br><span class="line">      name: webhook-service</span><br><span class="line">      namespace: default</span><br><span class="line">      path: &quot;/&quot;</span><br><span class="line">      port: 443</span><br><span class="line">  rules:</span><br><span class="line">  - operations: [&quot;CREATE&quot;]</span><br><span class="line">    apiGroups: [&quot;&quot;]</span><br><span class="line">    apiVersions: [&quot;v1&quot;]</span><br><span class="line">    resources: [&quot;pods&quot;]</span><br><span class="line"></span><br><span class="line"># validatingwebhook.yaml</span><br><span class="line">apiVersion: admissionregistration.k8s.io/v1</span><br><span class="line">kind: ValidatingWebhookConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: example-validating-webhook</span><br><span class="line">webhooks:</span><br><span class="line">- name: validating.webhook.example.com</span><br><span class="line">  clientConfig:</span><br><span class="line">    service:</span><br><span class="line">      name: webhook-service</span><br><span class="line">      namespace: default</span><br><span class="line">      path: &quot;/&quot;</span><br><span class="line">      port: 443</span><br><span class="line">  rules:</span><br><span class="line">  - operations: [&quot;CREATE&quot;]</span><br><span class="line">    apiGroups: [&quot;&quot;]</span><br><span class="line">    apiVersions: [&quot;v1&quot;]</span><br><span class="line">    resources: [&quot;pods&quot;]</span><br></pre></td></tr></table></figure><h3 id="步骤四：部署Webhook-Server"><a href="#步骤四：部署Webhook-Server" class="headerlink" title="步骤四：部署Webhook Server"></a>步骤四：部署Webhook Server</h3><p>将编写好的Webhook Server以及相关证书和私钥部署到Kubernetes集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f mutatingwebhook.yaml</span><br><span class="line">kubectl apply -f validatingwebhook.yaml</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理对象PodSecurity Admission Webhook的基本概念、工作原理、创建方式，并通过详细的示例演示了如何创建一个简单的PodSecurity Admission Webhook。PodSecurity Admission Webhook作为一种高级权限管理机制，为集群管理员提供了更灵活、个性化的安全控制手段。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理对象PodSecurityPolicy</title>
      <link href="/posts/4a17b608.html"/>
      <url>/posts/4a17b608.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，PodSecurityPolicy（PSP）是一种重要的权限管理对象，用于定义和控制Pod的安全策略。通过PodSecurityPolicy，集群管理员可以强制执行安全标准，确保Pod在运行时遵循安全最佳实践。本文将深入研究Kubernetes中的PodSecurityPolicy，包括其基本概念、创建方式以及详细示例。</p><h2 id="PodSecurityPolicy基本概念"><a href="#PodSecurityPolicy基本概念" class="headerlink" title="PodSecurityPolicy基本概念"></a>PodSecurityPolicy基本概念</h2><h3 id="PodSecurityPolicy是什么？"><a href="#PodSecurityPolicy是什么？" class="headerlink" title="PodSecurityPolicy是什么？"></a>PodSecurityPolicy是什么？</h3><p>PodSecurityPolicy是Kubernetes中的一种资源对象，用于定义Pod的安全策略。它允许集群管理员规定Pod的安全要求，例如容器的权限、文件系统访问权限等。</p><h3 id="PodSecurityPolicy的作用"><a href="#PodSecurityPolicy的作用" class="headerlink" title="PodSecurityPolicy的作用"></a>PodSecurityPolicy的作用</h3><p>PodSecurityPolicy的主要作用是确保Pod在运行时不会执行不安全的操作，提高集群的整体安全性。它可以限制Pod使用的特权、文件系统挂载、主机网络访问等。</p><h3 id="与RBAC的关系"><a href="#与RBAC的关系" class="headerlink" title="与RBAC的关系"></a>与RBAC的关系</h3><p>PodSecurityPolicy通常与RBAC（Role-Based Access Control）结合使用，通过ClusterRole和ClusterRoleBinding定义的规则来控制哪些用户或服务账户可以使用哪些PodSecurityPolicy。</p><h2 id="PodSecurityPolicy的创建方式"><a href="#PodSecurityPolicy的创建方式" class="headerlink" title="PodSecurityPolicy的创建方式"></a>PodSecurityPolicy的创建方式</h2><h3 id="手动创建PodSecurityPolicy"><a href="#手动创建PodSecurityPolicy" class="headerlink" title="手动创建PodSecurityPolicy"></a>手动创建PodSecurityPolicy</h3><p>可以手动创建PodSecurityPolicy，并在集群中为其配置相应的安全规则。以下是手动创建PodSecurityPolicy的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: restricted-psp</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  seLinux:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: MustRunAsNonRoot</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: MustRunAs</span><br><span class="line">  volumes:</span><br><span class="line">  - &#x27;*&#x27;</span><br><span class="line">  hostNetwork: false</span><br><span class="line">  hostIPC: false</span><br><span class="line">  hostPID: false</span><br><span class="line">  allowPrivilegeEscalation: false</span><br></pre></td></tr></table></figure><p>上述示例中，创建了一个名为restricted-psp的PodSecurityPolicy，定义了一系列安全规则，包括不允许特权容器、禁止使用主机网络等。</p><h3 id="使用PSP-Template"><a href="#使用PSP-Template" class="headerlink" title="使用PSP Template"></a>使用PSP Template</h3><p>可以使用PSP Template来定义一组通用的安全规则，并在创建PodSecurityPolicy时引用该Template。以下是使用PSP Template的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: my-psp</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  allowPrivilegeEscalation: false</span><br><span class="line">  volumes:</span><br><span class="line">  - &#x27;*&#x27;</span><br><span class="line">yamlapiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicyList</span><br><span class="line">items:</span><br><span class="line">- metadata:</span><br><span class="line">    name: psp-template</span><br><span class="line">  spec:</span><br><span class="line">    privileged: false</span><br><span class="line">    allowPrivilegeEscalation: false</span><br><span class="line">    volumes:</span><br><span class="line">    - &#x27;*&#x27;</span><br></pre></td></tr></table></figure><p>上述示例中，创建了一个名为psp-template的PSP Template，然后在另一个PodSecurityPolicy中引用了这个Template。</p><h2 id="PodSecurityPolicy示例演示"><a href="#PodSecurityPolicy示例演示" class="headerlink" title="PodSecurityPolicy示例演示"></a>PodSecurityPolicy示例演示</h2><p>在示例中，我们将演示如何手动创建一个PodSecurityPolicy，并将其与集群中的Role和RoleBinding关联，以实现对Pod的安全控制。</p><h3 id="步骤一：创建PodSecurityPolicy"><a href="#步骤一：创建PodSecurityPolicy" class="headerlink" title="步骤一：创建PodSecurityPolicy"></a>步骤一：创建PodSecurityPolicy</h3><p>创建一个名为restricted-psp的PodSecurityPolicy：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: restricted-psp</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  seLinux:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: MustRunAsNonRoot</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: MustRunAs</span><br><span class="line">  volumes:</span><br><span class="line">  - &#x27;*&#x27;</span><br><span class="line">  hostNetwork: false</span><br><span class="line">  hostIPC: false</span><br><span class="line">  hostPID: false</span><br><span class="line">  allowPrivilegeEscalation: false</span><br></pre></td></tr></table></figure><h3 id="步骤二：创建Role和RoleBinding"><a href="#步骤二：创建Role和RoleBinding" class="headerlink" title="步骤二：创建Role和RoleBinding"></a>步骤二：创建Role和RoleBinding</h3><p>创建一个名为pod-editor的Role，定义对Pod资源的编辑权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-editor</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]</span><br></pre></td></tr></table></figure><p>创建一个RoleBinding，将ServiceAccount default与pod-editor Role关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: default-pod-editor</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-editor</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h3 id="步骤三：关联PodSecurityPolicy和RoleBinding"><a href="#步骤三：关联PodSecurityPolicy和RoleBinding" class="headerlink" title="步骤三：关联PodSecurityPolicy和RoleBinding"></a>步骤三：关联PodSecurityPolicy和RoleBinding</h3><p>将PodSecurityPolicy restricted-psp与RoleBinding default-pod-editor关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: restricted-psp</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  seLinux:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: MustRunAsNonRoot</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: MustRunAs</span><br><span class="line">  volumes:</span><br><span class="line">  - &#x27;*&#x27;</span><br><span class="line">  hostNetwork: false</span><br><span class="line">  hostIPC: false</span><br><span class="line">  hostPID: false</span><br><span class="line">  allowPrivilegeEscalation: false</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: default-pod-editor</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: restricted-psp</span><br><span class="line">  apiGroup: policy</span><br></pre></td></tr></table></figure><h3 id="步骤四：验证PodSecurityPolicy"><a href="#步骤四：验证PodSecurityPolicy" class="headerlink" title="步骤四：验证PodSecurityPolicy"></a>步骤四：验证PodSecurityPolicy</h3><p>尝试创建一个使用特权容器的Pod，验证PodSecurityPolicy是否生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: privileged-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: privileged-container</span><br><span class="line">    image: nginx</span><br><span class="line">    securityContext:</span><br><span class="line">      privileged: true</span><br></pre></td></tr></table></figure><p>上述Pod创建应该因为不符合restricted-psp的安全规则而被拒绝。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理对象PodSecurityPolicy的基本概念、创建方式，并通过详细的示例演示了如何手动创建PodSecurityPolicy，并将其与Role和RoleBinding关联，以实现对Pod的安全控制。PodSecurityPolicy作为Kubernetes中的安全机制之一，能够帮助集群管理员强制执行安全标准，确保Pod在运行时遵循安全最佳实践。在实际使用中，需要根据业务需求和安全要求定义合适的PodSecurityPolicy，并结合RBAC进行细粒度的权限控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/posts/4a17c501.html"/>
      <url>/posts/4a17c501.html</url>
      
        <content type="html"><![CDATA[<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示docker的版本信息</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"># 显示docker的系统信息(包括镜像和容器数量)</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># 帮助命令</span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>查看所有镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地主机所有的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   12 months ago   13.3kB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">REPOSITORY镜像仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的ID</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE镜像大小</span><br><span class="line"></span><br><span class="line">#可选项</span><br><span class="line">--all , -a列出所有镜像</span><br><span class="line">--quiet , -q只显示镜像ID</span><br></pre></td></tr></table></figure><p>搜索镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 搜索镜像</span><br><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10414     [OK]       </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3865      [OK]       </span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   762                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   524       [OK]       </span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   87                   </span><br><span class="line">mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   79                   </span><br><span class="line">centurylink/mysql                 Image containing mysql. Optimized to be link…   59                   [OK]</span><br><span class="line">bitnami/mysql                     Bitnami MySQL Docker Image                      47                   [OK]</span><br><span class="line">deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                   [OK]</span><br><span class="line">databack/mysql-backup             Back up mysql databases to... anywhere!         37                   </span><br><span class="line">prom/mysqld-exporter                                                              37                   [OK]</span><br><span class="line">tutum/mysql                       Base docker image to run a MySQL database se…   35                   </span><br><span class="line">schickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   29                   [OK]</span><br><span class="line">linuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   27                   </span><br><span class="line">circleci/mysql                    MySQL is a widely used, open-source relation…   20                   </span><br><span class="line">centos/mysql-56-centos7           MySQL 5.6 SQL database server                   20                   </span><br><span class="line">arey/mysql-client                 Run a MySQL client from a docker container      17                   [OK]</span><br><span class="line">mysql/mysql-router                MySQL Router provides transparent routing be…   17                   </span><br><span class="line">fradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   10                   [OK]</span><br><span class="line">yloeffler/mysql-backup            This image runs mysqldump to backup data usi…   7                    [OK]</span><br><span class="line">openshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6                    </span><br><span class="line">devilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   3                    </span><br><span class="line">ansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                2                    [OK]</span><br><span class="line">jelastic/mysql                    An image of the MySQL database server mainta…   1                    </span><br><span class="line">widdpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   1                    [OK]</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-f, --filter filter   根据提供的条件过滤输出</span><br><span class="line"># 例如搜索STARS大于3000的</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker search mysql -f STARS=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10414     [OK]       </span><br><span class="line">mariadb   MariaDB is a community-developed fork of MyS…   3865      [OK]   </span><br></pre></td></tr></table></figure><p>下载镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载镜像</span><br><span class="line">docker pull 镜像名[:tag]</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 不指定版本号默认下载最新版latest</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a076a628af6f: Pull complete#分层下载,docker image的核心:联合文件系统</span><br><span class="line">f6c208f3f991: Pull complete </span><br><span class="line">88a9455a9165: Pull complete </span><br><span class="line">406c9b8427c6: Pull complete </span><br><span class="line">7c88599c0b25: Pull complete </span><br><span class="line">25b5c6debdaf: Pull complete </span><br><span class="line">43a5816f1617: Pull complete </span><br><span class="line">1a8c919e89bf: Pull complete </span><br><span class="line">9f3cf4bd1a07: Pull complete </span><br><span class="line">80539cea118d: Pull complete </span><br><span class="line">201b3cad54ce: Pull complete </span><br><span class="line">944ba37e1c06: Pull complete </span><br><span class="line">Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest#真实地址</span><br><span class="line"></span><br><span class="line"># 指定版本号下载</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">a076a628af6f: Already exists </span><br><span class="line">f6c208f3f991: Already exists </span><br><span class="line">88a9455a9165: Already exists </span><br><span class="line">406c9b8427c6: Already exists </span><br><span class="line">7c88599c0b25: Already exists </span><br><span class="line">25b5c6debdaf: Already exists </span><br><span class="line">43a5816f1617: Already exists </span><br><span class="line">1831ac1245f4: Pull complete </span><br><span class="line">37677b8c1f79: Pull complete </span><br><span class="line">27e4ac3b0f6e: Pull complete </span><br><span class="line">7227baa8c445: Pull complete </span><br><span class="line">Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除镜像</span><br><span class="line">docker rmi</span><br><span class="line"> `docker rmi -f 镜像id`：删除指定镜像</span><br><span class="line"> `docker rmi -f 镜像id 镜像id 镜像id`：删除指定多个镜像</span><br><span class="line"> `docker rmi -f $(docker images -aq)`：删除全部镜像</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         5.7       a70d36bc331a   5 days ago      449MB</span><br><span class="line">mysql         latest    c8562eaf9d81   5 days ago      546MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   12 months ago   13.3kB</span><br><span class="line">#删除指定镜像</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker rmi -f a70d36bc331a </span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df</span><br><span class="line">Deleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5</span><br><span class="line">Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7</span><br><span class="line">Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6</span><br><span class="line">Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3c</span><br><span class="line">Deleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         latest    c8562eaf9d81   5 days ago      546MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   12 months ago   13.3kB</span><br><span class="line">#删除所有镜像</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker rmi -f $(docker images -aq)</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c</span><br><span class="line">Deleted: sha256:c8562eaf9d81c779cbfc318d6e01b8e6f86907f1d41233268a2ed83b2f34e748</span><br><span class="line">Deleted: sha256:1b649b85960473808c6b812fc30c3f6a3ff1c0ffdcba5c9435daf01cf7d5373a</span><br><span class="line">Deleted: sha256:19cc889447050c16c797fd209fa114ee219de23facb37c00d4137a4ed4aad922</span><br><span class="line">Deleted: sha256:3c793c06a026d276cf56a6a6a75527026ed9eafa7a7d21a438f7d5ed2314148e</span><br><span class="line">Deleted: sha256:1e1cd89a2bc183a7fea3dab0b543e9924278321ad0921c22cc088adbf3c2e77b</span><br><span class="line">Deleted: sha256:83b2015dfd000588c7c947b2d89b3be7a8e5a3abc6ab562668c358033aa779ec</span><br><span class="line">Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312</span><br><span class="line">Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38</span><br><span class="line">Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109de</span><br><span class="line">Deleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42a</span><br><span class="line">Deleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1d</span><br><span class="line">Deleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37</span><br><span class="line">Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9</span><br><span class="line">Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID   CREATED   SIZE</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有了镜像才能够创建容器，这里下载一个centos镜像为以下测试做准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete </span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure><p>新建容器并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 新建容器并启动</span><br><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name=&quot;Name&quot; 容器名字,用于区分容器</span><br><span class="line">-d后台方式运行</span><br><span class="line">-it使用交互方式运行,进入容器查看内容</span><br><span class="line">-p指定容器端口(小写)</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口(最常用)</span><br><span class="line">-P 容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P随机执行端口(大写)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#测试,启动进入容器</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@22d0484830c9 /]# ls查看容器内的centos,基础版本,很多命令不完善</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">#退出容器到主机</span><br><span class="line">[root@22d0484830c9 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# ls</span><br><span class="line">3000  cp  cp.tar.gz  f.sh  hello.c  install.sh  login.sh  read.sh  time.sh</span><br></pre></td></tr></table></figure><p>列出所有运行的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有运行的容器</span><br><span class="line">docker ps [可选参数]</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">-a列出当前正在运行以及历史运行过的容器</span><br><span class="line">-n=?显示最近创建的容器</span><br><span class="line">-q只显示容器编号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED              STATUS                          PORTS     NAMES</span><br><span class="line">22d0484830c9   centos         &quot;/bin/bash&quot;   About a minute ago   Exited (0) About a minute ago             condescending_mcnulty</span><br><span class="line">3efe49d28bdd   bf756fb1ae65   &quot;/hello&quot;      7 hours ago          Exited (0) 7 hours ago                    confident_babbage</span><br><span class="line">40fc94e7b0a4   bf756fb1ae65   &quot;/hello&quot;      7 months ago         Exited (0) 7 months ago                   inspiring_lovelace</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -n=1</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">22d0484830c9   centos    &quot;/bin/bash&quot;   4 minutes ago   Exited (0) 3 minutes ago             condescending_mcnulty</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -aq</span><br><span class="line">22d0484830c9</span><br><span class="line">3efe49d28bdd</span><br><span class="line">40fc94e7b0a4</span><br></pre></td></tr></table></figure><p>退出容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 容器停止并退出</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 容器不停止退出</span><br><span class="line">Ctrl+p+q</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定容器,不能删除正在运行的容器,强制删除用rm -f</span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"># 删除所有容器</span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line">docker ps -a -q|xargs docker rm</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -aq</span><br><span class="line">6518909c5fb2</span><br><span class="line">3dfd73738e3b</span><br><span class="line">22d0484830c9</span><br><span class="line">3efe49d28bdd</span><br><span class="line">40fc94e7b0a4</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker rm 6518909c5fb2</span><br><span class="line">6518909c5fb2</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -aq</span><br><span class="line">3dfd73738e3b</span><br><span class="line">22d0484830c9</span><br><span class="line">3efe49d28bdd</span><br><span class="line">40fc94e7b0a4</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker rm -f $(docker ps -aq)</span><br><span class="line">3dfd73738e3b</span><br><span class="line">22d0484830c9</span><br><span class="line">3efe49d28bdd</span><br><span class="line">40fc94e7b0a4</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -aq</span><br></pre></td></tr></table></figure><p>启动停止容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id# 重启容器</span><br><span class="line">docker stop 容器id# 停止正在运行的容器</span><br><span class="line">docker kill 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure><h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p>后台启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 后台启动容器</span><br><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker run -d centos</span><br><span class="line">9606d8980f73ff313c64388f5f82e036072cc7191c3305ab80b371e37d8b1ad7</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">9606d8980f73   centos    &quot;/bin/bash&quot;   54 seconds ago   Exited (0) 53 seconds ago             youthful_dubinsky</span><br></pre></td></tr></table></figure><ul><li>问题：后台启动容器，再用 docker ps 查看发现容器停止</li><li>原因：docker 容器使用后台运行，就必须有一个前台进程；如果仅仅后台启动，没有应用来提供服务，就会自动停止</li></ul><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs [可选参数] 容器ID</span><br><span class="line">      --details        显示提供给日志的其他详细信息</span><br><span class="line">  -f, --follow         跟踪日志输出</span><br><span class="line">  -n, --tail string    指定要显示的日志条数 (默认为全部)</span><br><span class="line">  -t, --timestamps     显示时间戳</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 后台启动容器,同时执行脚本不停打印zsr</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker run -d centos /bin/bash -c &quot;while true;do echo zsr;sleep 1;done&quot;</span><br><span class="line">980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02</span><br><span class="line"># 查看运行的容器,此时可以查看到</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">980daf06de58   centos    &quot;/bin/bash -c &#x27;while…&quot;   6 seconds ago   Up 6 seconds             distracted_germain</span><br><span class="line"># 查看日志信息,显示时间戳,指定显示10条日志</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker logs -t -n 10 980daf06de58 </span><br><span class="line">2021-01-25T04:53:47.619357189Z zsr</span><br><span class="line">2021-01-25T04:53:48.621476433Z zsr</span><br><span class="line">2021-01-25T04:53:49.623833490Z zsr</span><br><span class="line">2021-01-25T04:53:50.626253957Z zsr</span><br><span class="line">2021-01-25T04:53:51.628526460Z zsr</span><br><span class="line">2021-01-25T04:53:52.630878536Z zsr</span><br><span class="line">2021-01-25T04:53:53.633046201Z zsr</span><br><span class="line">2021-01-25T04:53:54.635296632Z zsr</span><br><span class="line">2021-01-25T04:53:55.637614256Z zsr</span><br><span class="line">2021-01-25T04:53:56.640358130Z zsr</span><br></pre></td></tr></table></figure><p>查看容器中的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看容器中的进程</span><br><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker top 980daf06de58</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                28359               28339               0                   12:52               ?                   00:00:00            /bin/bash -c while true;do echo zsr;sleep 1;done</span><br><span class="line">root                29065               28359               0                   12:58               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br></pre></td></tr></table></figure><p>查看镜像元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看镜像元数据</span><br><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker inspect 980daf06de58</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-01-25T04:52:46.079489883Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo zsr;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 28359,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2021-01-25T04:52:46.469990116Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02/980daf06de5878e2d3e5c048c7de92817e09e92f20d2d6242ecb15b9b7a5bd02-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/distracted_germain&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/c836c661b72e93a97b704d62711facfd82b4f080359405a4382a8dca3f7ce2ed-init/diff:/var/lib/docker/overlay2/e7eaf7928b9265d758185f4ac2e84ab99cb6146cbf37d10a9d9b3ce1ad30ab3e/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/c836c661b72e93a97b704d62711facfd82b4f080359405a4382a8dca3f7ce2ed/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/c836c661b72e93a97b704d62711facfd82b4f080359405a4382a8dca3f7ce2ed/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/c836c661b72e93a97b704d62711facfd82b4f080359405a4382a8dca3f7ce2ed/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;980daf06de58&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo zsr;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;6a7fa868d1b07689ed1307cd6eaffa3d102c13440bddf41b7eedd526a328f03e&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/6a7fa868d1b0&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;ab462efd8637f15fd7aabe6250429571db2f4dc22e3248278dbe513af5e47e38&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;0524bfb4e90c798594ceca6e4099d5b1407f7dcef80435f023f4a1963a35fbb4&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;ab462efd8637f15fd7aabe6250429571db2f4dc22e3248278dbe513af5e47e38&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>进入当前正在运行的容器</p><p>容器通常都是使用后台方式运行的，这时候可能需要进入容器，修改一些配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 方式一: 进入容器后开启一个新的终端,可在里面进行操作(常用)</span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"></span><br><span class="line"># 方式二: 进入容器正在执行的终端,不会启动新的进程</span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 测试方式一</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class="line">980daf06de58   centos    &quot;/bin/bash -c &#x27;while…&quot;   2 hours ago   Up 2 hours             distracted_germain</span><br><span class="line"># 进入到容器</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker exec -it 980daf06de58 /bin/bash</span><br><span class="line">[root@980daf06de58 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line"># 测试方式二</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class="line">980daf06de58   centos    &quot;/bin/bash -c &#x27;while…&quot;   2 hours ago   Up 2 hours             distracted_germain</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ ~]# docker attach 980daf06de58</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">zsr</span><br><span class="line">#进入死循环...</span><br></pre></td></tr></table></figure><p>从容器内拷贝文件到主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从容器内拷贝文件到主机</span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# docker run -it centos /bin/bash</span><br><span class="line">[root@64b40f051756 /]# cd /home</span><br><span class="line">[root@64b40f051756 home]# ls</span><br><span class="line"># 在容器内部新建一个文件</span><br><span class="line">[root@64b40f051756 home]# touch 1.txt</span><br><span class="line">[root@64b40f051756 home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">64b40f051756   centos    &quot;/bin/bash&quot;              4 minutes ago    Exited (0) 59 seconds ago               beautiful_ganguly</span><br><span class="line">c1b3f151ae12   centos    &quot;/bin/bash&quot;              7 minutes ago    Exited (127) 4 minutes ago              nervous_lamarr</span><br><span class="line">60b1f058de74   centos    &quot;/bin/bash&quot;              14 minutes ago   Exited (0) 12 minutes ago               vibrant_jemison</span><br><span class="line">980daf06de58   centos    &quot;/bin/bash -c &#x27;while…&quot;   2 hours ago      Exited (137) 14 minutes ago             distracted_germain</span><br><span class="line">d77c3cdfb7e2   centos    &quot;/bin/bash -c &#x27;while…&quot;   3 hours ago      Exited (137) 2 hours ago                relaxed_meninsky</span><br><span class="line">7706ccced225   centos    &quot;/bin/bash -c &#x27;whilr…&quot;   3 hours ago      Exited (1) 3 hours ago                  romantic_hopper</span><br><span class="line">6eebf828ab4c   centos    &quot;/bin/bash -c &#x27;whilr…&quot;   3 hours ago      Exited (1) 3 hours ago                  brave_goldberg</span><br><span class="line">df422d73861f   centos    &quot;/bin/bash&quot;              3 hours ago      Exited (0) 3 hours ago                  frosty_panini</span><br><span class="line">744b9b044715   centos    &quot;/bin/bash&quot;              3 hours ago      Exited (127) 3 hours ago                amazing_cori</span><br><span class="line">9606d8980f73   centos    &quot;/bin/bash&quot;              3 hours ago      Exited (0) 3 hours ago                  youthful_dubinsky</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# cd /home</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# ls</span><br><span class="line">redis  www  zsr</span><br><span class="line"># 将容器内创建的1.txt拷贝到主机</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# docker cp 64b40f051756:/home/1.txt /home</span><br><span class="line">[root@iZ2ze3zdx4jq8v6hetjjuxZ home]# ls</span><br><span class="line">1.txt  redis  www  zsr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的概述</title>
      <link href="/posts/4a17c500.html"/>
      <url>/posts/4a17c500.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h2><p>一款产品的开发往往需要多套环境，比如开发环境、测试环境以及最终的上线环境；环境的配置是时分麻烦的，每一个机器都要部署环境（Redis、ES、Hadoop集群…），尤其是各种集群的部署特别浪费时间，常常会遇到 ”在我电脑上可以运行，在你电脑上不能运行“、”版本更新导致服务不用“、”不能跨平台“ 等等大量问题，这对运维人员来说就十分棘手。</p><p>在以前，开发人员发开完成就发布一个jar或者war包，其他的都交给运维人员来做；而现在，开发即运维，打包部署上线一套流程走完：开发人员会将项目及其附带的环境一起打包jar+(Redis Jdk ES MySQL)成一整套发布，称为镜像，这样就不再需要再配置环境，直接执行一整套即可，省去环境配置的麻烦且保证了一致性；</p><p>Docker的出现就是为了解决以上问题，类似于安卓应用：</p><ul><li>java – apk – 发布到应用商店 – 下载即可使用</li><li>java – jar(环境) – 打包项目+环境(镜像) – 发布到Docker仓库 – 下载镜像即可直接运行</li></ul><p>Docker 的思想来源于集装箱，打包装箱，每个箱子互相隔离</p><p>Docker 通过隔离机制，可以将服务器运行到极致</p><h2 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h2><p>2010 年，几个搞 IT 的年轻人，在美国旧金山成立了一家名叫 dotCloud 的公司。dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。底层技术上，dotCloud 平台利用了 Linux 的 LXC 容器技术。</p><p>为了方便创建和管理这些容器，dotCloud 基于 Google 公司推出的 Go 语言开发了一套内部工具，之后被命名为 Docker。Docker 就是这样诞生的。</p><p>如同 Docker 的 Logo 一样，Docker 的思想来源于集装箱。集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来，并且各种各样的货物被集装箱标准化，集装箱与集装箱之间互不影响。那么就不需要专门运送水果的船和专门运送化学用品的船了。只要这些货物封装在不同的集装箱里，就可以用一艘大船把它们都运走。</p><p>Docker 技术诞生之后，并没有引起行业的关注。而 dotCloud 公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p>有的软件一开始就是开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。2013 年 3 月，dotCloud 公司的创始人之一，Docker 之父，28 岁的 「Solomon Hykes」 正式决定，将 Docker 项目开源。<br>img</p><p>不开则已，一开惊人。越来越多的 IT 工程师发现了 Docker 的优点，然后蜂拥而至，加入 Docker 开源社区。Docker 的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月， Docker 0.1 版本发布。此后的每一个月， Docker 都会发布一个版本。到 2014 年 6 月 9 日， Docker 1.0 版本正式发布。</p><p>此时的 Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像 Google、微软、Amazon、 VMware 这样的巨头们都对它青睐有加，表示将全力支持。</p><p>Docker 火了之后， dotCloud 公司干脆把公司名字也改成了 Docker Inc.</p><h2 id="对比虚拟化技术"><a href="#对比虚拟化技术" class="headerlink" title="对比虚拟化技术"></a>对比虚拟化技术</h2><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>资源占用十分大</li><li>冗余步骤多</li><li>启动慢</li></ul><h3 id="差异："><a href="#差异：" class="headerlink" title="差异："></a>差异：</h3><ul><li>传统虚拟机技术，虚拟出一套硬件，运行一个完整的操作系统，在这个系统上安装和运行软件</li><li>容器内的应用直接运行在宿主机的内核上，容器没有自己的内核，也没有虚拟硬件，轻便快速，</li><li>每个容器互相隔离，每个容器都有一个自己的文件系统，互不影响</li></ul><h2 id="为什么选择Docker"><a href="#为什么选择Docker" class="headerlink" title="为什么选择Docker"></a>为什么选择Docker</h2><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成（Continuous Integration）系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery&#x2F;Deployment）系统进行自动部署。</p><p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的在生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="应用更快速的交付和部署"><a href="#应用更快速的交付和部署" class="headerlink" title="应用更快速的交付和部署"></a>应用更快速的交付和部署</h3><ul><li><p>传统：一堆帮助文档，安装程序</p></li><li><p>Docker：打包镜像发布测试，一键运行</p></li></ul><h3 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h3><ul><li>使用Docker之后，部署应用就和搭积木一样</li><li>项目打包成一个镜像，比如服务器A出现性能瓶颈，水平拓展，在服务器B上一键运行镜像</li></ul><h3 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h3><ul><li>容器化之后，开发、测试环境高度一致</li></ul><h3 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h3><ul><li>Docker是内核级别的虚拟化，可以在一个物理机上运行很多容器实例，服务器性能可以被压榨到极致</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装</title>
      <link href="/posts/4a17b500.html"/>
      <url>/posts/4a17b500.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Docker 是一种流行的容器化平台，能够简化应用程序的开发、部署和管理。本文将深入介绍在 Windows、Ubuntu 和 CentOS 系统中安装 Docker 的详细步骤，同时讨论在安装过程中可能遇到的一些注意事项。</p><h1 id="Windows-系统中安装-Docker"><a href="#Windows-系统中安装-Docker" class="headerlink" title="Windows 系统中安装 Docker"></a>Windows 系统中安装 Docker</h1><h2 id="确认系统要求"><a href="#确认系统要求" class="headerlink" title="确认系统要求"></a>确认系统要求</h2><p>在安装 Docker 之前，请确保 Windows 符合以下基本要求：</p><ul><li>Windows 10 专业版或企业版，64 位。</li><li>启用虚拟化技术（VT-x）和 Hyper-V。</li><li>至少 4 GB 的系统内存。</li></ul><h2 id="下载-Docker-Desktop"><a href="#下载-Docker-Desktop" class="headerlink" title="下载 Docker Desktop"></a>下载 Docker Desktop</h2><p>访问 Docker 官方网站（<a href="https://www.docker.com/products/docker-desktop%EF%BC%89%E4%B8%8B%E8%BD%BD">https://www.docker.com/products/docker-desktop）下载</a> Docker Desktop 的最新版本。</p><h2 id="安装-Docker-Desktop"><a href="#安装-Docker-Desktop" class="headerlink" title="安装 Docker Desktop"></a>安装 Docker Desktop</h2><p>运行下载的安装程序，按照提示进行安装。安装期间可能需要系统重启。</p><h2 id="配置-Docker-Desktop"><a href="#配置-Docker-Desktop" class="headerlink" title="配置 Docker Desktop"></a>配置 Docker Desktop</h2><p>安装完成后，打开 Docker Desktop。在系统托盘中，你会看到 Docker 图标，表示 Docker 已成功安装并正在运行。</p><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>打开命令提示符或 PowerShell，运行以下命令验证 Docker 是否正确安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如果一切正常，将显示 Docker 版本信息和一则欢迎消息。</p><h1 id="Ubuntu-系统中安装-Docker"><a href="#Ubuntu-系统中安装-Docker" class="headerlink" title="Ubuntu 系统中安装 Docker"></a>Ubuntu 系统中安装 Docker</h1><h2 id="更新包列表"><a href="#更新包列表" class="headerlink" title="更新包列表"></a>更新包列表</h2><p>在 Ubuntu 系统上，首先确保包列表是最新的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>安装 Docker 所需的一些基本依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><h2 id="添加-Docker-GPG-密钥"><a href="#添加-Docker-GPG-密钥" class="headerlink" title="添加 Docker GPG 密钥"></a>添加 Docker GPG 密钥</h2><p>添加 Docker 官方 GPG 密钥，以确保下载的软件包的完整性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><h2 id="添加-Docker-APT-仓库"><a href="#添加-Docker-APT-仓库" class="headerlink" title="添加 Docker APT 仓库"></a>添加 Docker APT 仓库</h2><p>添加 Docker APT 仓库到系统源列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>安装 Docker Engine：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h2 id="添加用户到-docker-组"><a href="#添加用户到-docker-组" class="headerlink" title="添加用户到 docker 组"></a>添加用户到 docker 组</h2><p>将当前用户添加到 docker 用户组，以避免使用 sudo 运行 Docker 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><p>使用户组更改生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h2 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h2><p>运行以下命令验证 Docker 是否正确安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如果一切正常，将显示 Docker 版本信息和一则欢迎消息。</p><h1 id="CentOS-系统中安装-Docker"><a href="#CentOS-系统中安装-Docker" class="headerlink" title="CentOS 系统中安装 Docker"></a>CentOS 系统中安装 Docker</h1><h2 id="安装依赖包-1"><a href="#安装依赖包-1" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在 CentOS 系统上，首先安装一些基本依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h2 id="设置-Docker-CE-仓库"><a href="#设置-Docker-CE-仓库" class="headerlink" title="设置 Docker CE 仓库"></a>设置 Docker CE 仓库</h2><p>配置 Docker CE 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="安装-Docker-1"><a href="#安装-Docker-1" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>安装 Docker Engine：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h2 id="启动-Docker-服务"><a href="#启动-Docker-服务" class="headerlink" title="启动 Docker 服务"></a>启动 Docker 服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="设置-Docker-为开机启动"><a href="#设置-Docker-为开机启动" class="headerlink" title="设置 Docker 为开机启动"></a>设置 Docker 为开机启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="添加用户到-docker-组-1"><a href="#添加用户到-docker-组-1" class="headerlink" title="添加用户到 docker 组"></a>添加用户到 docker 组</h2><p>将当前用户添加到 docker 用户组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h2 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h2><p>运行以下命令验证 Docker 是否正确安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如果一切正常，将显示 Docker 版本信息和一则欢迎消息。</p><h2 id="安装过程中的注意事项"><a href="#安装过程中的注意事项" class="headerlink" title="安装过程中的注意事项"></a>安装过程中的注意事项</h2><p>在安装 Docker 过程中，可能会遇到一些常见问题，以下是一些注意事项和解决方法：</p><h2 id="Hyper-V-启用失败"><a href="#Hyper-V-启用失败" class="headerlink" title="Hyper-V 启用失败"></a>Hyper-V 启用失败</h2><p>如果在 Windows 安装 Docker Desktop 时出现 Hyper-V 启用失败的问题，可能是因为系统 BIOS 中未启用虚拟化技术。解决方法是进入系统 BIOS 设置，启用虚拟化技术选项（VT-x）。</p><h2 id="Windows-版本不兼容"><a href="#Windows-版本不兼容" class="headerlink" title="Windows 版本不兼容"></a>Windows 版本不兼容</h2><p>Docker Desktop 对 Windows 10 的版本有要求，确保你的 Windows 10 版本为专业版或企业版，并且更新至最新版本。</p><h2 id="安装期间网络问题"><a href="#安装期间网络问题" class="headerlink" title="安装期间网络问题"></a>安装期间网络问题</h2><p>在安装期间，Docker 需要从互联网下载一些组件。如果在安装过程中遇到网络问题，可以尝试使用代理或确保系统能够访问互联网。</p><h2 id="安装完成后无法启动-Docker"><a href="#安装完成后无法启动-Docker" class="headerlink" title="安装完成后无法启动 Docker"></a>安装完成后无法启动 Docker</h2><p>如果安装完成后无法启动 Docker，可以尝试重新安装 Docker Desktop，并确保没有其他虚拟化工具冲突。</p><h2 id="安装过程中占用存储空间"><a href="#安装过程中占用存储空间" class="headerlink" title="安装过程中占用存储空间"></a>安装过程中占用存储空间</h2><p>Docker 镜像和容器会占用一定的存储空间。在安装 Docker 时，确保系统有足够的可用存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理对象Grop</title>
      <link href="/posts/4a17b607.html"/>
      <url>/posts/4a17b607.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，Group（用户组）是一种重要的权限管理对象，用于对一组用户进行集中管理，并在Role（角色）和RoleBinding（角色绑定）等授权机制中进行关联。本文将深入研究Kubernetes中的Group对象，包括其基本概念、创建方式以及详细示例。</p><h2 id="Group基本概念"><a href="#Group基本概念" class="headerlink" title="Group基本概念"></a>Group基本概念</h2><h3 id="Group是什么？"><a href="#Group是什么？" class="headerlink" title="Group是什么？"></a>Group是什么？</h3><p>在Kubernetes中，Group是指一组具有相似角色或权限的用户集合。通过Group，可以更方便地对一组用户进行统一的授权管理，减少冗余配置和提高集中管理的效率。</p><h3 id="Group的作用"><a href="#Group的作用" class="headerlink" title="Group的作用"></a>Group的作用</h3><p>Group的主要作用是在Kubernetes中对一组用户进行标识和分类，以便在授权机制中进行更细粒度的权限分配。它通常与RBAC（Role-Based Access Control）结合使用，将一组用户与具体的角色关联。</p><h3 id="与用户的关系"><a href="#与用户的关系" class="headerlink" title="与用户的关系"></a>与用户的关系</h3><p>Group通常与用户（User）关联，一个用户可以属于多个Group，而一个Group也可以包含多个用户。这种关系使得用户的授权管理更加灵活。</p><h2 id="Group的创建方式"><a href="#Group的创建方式" class="headerlink" title="Group的创建方式"></a>Group的创建方式</h2><h3 id="手动创建Group"><a href="#手动创建Group" class="headerlink" title="手动创建Group"></a>手动创建Group</h3><p>可以手动创建Group，并在集群中为其配置相应的访问权限。以下是手动创建Group的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Group</span><br><span class="line">metadata:</span><br><span class="line">  name: developers</span><br></pre></td></tr></table></figure><p>上述示例中，创建了一个名为developers的Group。</p><h3 id="用户创建Group"><a href="#用户创建Group" class="headerlink" title="用户创建Group"></a>用户创建Group</h3><p>在Kubernetes中，Group通常是由用户身份提供者（如LDAP、OIDC等）通过用户信息同步到Kubernetes集群中的。以下是通过用户创建Group的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Group</span><br><span class="line">metadata:</span><br><span class="line">  name: team-a</span><br></pre></td></tr></table></figure><p>上述示例中，通过用户创建了一个名为team-a的Group。</p><h2 id="Group示例演示"><a href="#Group示例演示" class="headerlink" title="Group示例演示"></a>Group示例演示</h2><p>在示例中，我们将演示如何手动创建一个Group，并将其与集群中的Role和RoleBinding关联，以实现对资源的访问权限。</p><h3 id="步骤一：创建Group"><a href="#步骤一：创建Group" class="headerlink" title="步骤一：创建Group"></a>步骤一：创建Group</h3><p>创建一个名为dev-team的Group：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Group</span><br><span class="line">metadata:</span><br><span class="line">  name: dev-team</span><br></pre></td></tr></table></figure><h3 id="步骤二：创建Role和RoleBinding"><a href="#步骤二：创建Role和RoleBinding" class="headerlink" title="步骤二：创建Role和RoleBinding"></a>步骤二：创建Role和RoleBinding</h3><p>创建一个名为pod-editor的Role，定义对Pod资源的编辑权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-editor</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]</span><br></pre></td></tr></table></figure><p>创建一个RoleBinding，将Group dev-team与pod-editor Role关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: dev-team-pod-editor</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: dev-team</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-editor</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h3 id="步骤三：验证Group权限"><a href="#步骤三：验证Group权限" class="headerlink" title="步骤三：验证Group权限"></a>步骤三：验证Group权限</h3><p>通过kubectl命令验证Group dev-team是否具有对Pod资源的编辑权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i create pods --as system:group:dev-team</span><br><span class="line">kubectl auth can-i delete pods --as system:group:dev-team</span><br></pre></td></tr></table></figure><p>根据Role和RoleBinding的配置，第一个命令应返回true，而第二个命令应返回false。</p><p>上述步骤演示了如何手动创建一个Group，并通过Role和RoleBinding为其分配资源的访问权限。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理对象Group的基本概念、创建方式，并通过详细的示例演示了如何手动创建Group，并为其配置访问权限。Group作为Kubernetes中的重要身份实体，通过合理的配置和关联，能够实现对一组用户的权限控制。在实际使用中，需要根据业务需求和安全要求选择合适的Group创建方式，并通过RBAC进行精细的权限管理。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理对象ServiceAccount</title>
      <link href="/posts/4a17b606.html"/>
      <url>/posts/4a17b606.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，ServiceAccount是一种用于为Pod中的应用程序提供身份的重要权限管理对象。通过ServiceAccount，可以实现对Pod的身份验证，确保它们能够正确地与Kubernetes API Server交互，并获取所需的权限。本文将深入探讨Kubernetes中的ServiceAccount，包括其基本概念、使用方法以及详细示例。</p><h2 id="ServiceAccount基本概念"><a href="#ServiceAccount基本概念" class="headerlink" title="ServiceAccount基本概念"></a>ServiceAccount基本概念</h2><h3 id="ServiceAccount是什么？"><a href="#ServiceAccount是什么？" class="headerlink" title="ServiceAccount是什么？"></a>ServiceAccount是什么？</h3><p>ServiceAccount是Kubernetes中的一种资源对象，用于定义Pod中应用程序的身份。每个Pod都可以与一个ServiceAccount关联，以便在与API Server通信时获得身份验证和授权。</p><h3 id="ServiceAccount的作用"><a href="#ServiceAccount的作用" class="headerlink" title="ServiceAccount的作用"></a>ServiceAccount的作用</h3><p>ServiceAccount的主要作用是为Pod提供身份，使得Pod可以在Kubernetes集群中被唯一标识，并通过身份验证和授权机制获取访问API Server的权限。</p><h3 id="默认ServiceAccount"><a href="#默认ServiceAccount" class="headerlink" title="默认ServiceAccount"></a>默认ServiceAccount</h3><p>每个命名空间都有一个默认的ServiceAccount，如果用户不指定ServiceAccount，Pod将自动关联到该默认的ServiceAccount上。</p><h2 id="ServiceAccount使用方法"><a href="#ServiceAccount使用方法" class="headerlink" title="ServiceAccount使用方法"></a>ServiceAccount使用方法</h2><h3 id="创建ServiceAccount"><a href="#创建ServiceAccount" class="headerlink" title="创建ServiceAccount"></a>创建ServiceAccount</h3><p>要创建ServiceAccount，可以使用YAML文件定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service-account</span><br><span class="line">  namespace: default</span><br></pre></td></tr></table></figure><p>上述示例定义了一个名为my-service-account的ServiceAccount，并将其关联到default命名空间。</p><h3 id="关联ServiceAccount到Pod"><a href="#关联ServiceAccount到Pod" class="headerlink" title="关联ServiceAccount到Pod"></a>关联ServiceAccount到Pod</h3><p>通过在Pod的定义中添加serviceAccountName字段，将ServiceAccount关联到Pod。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  serviceAccountName: my-service-account</span><br><span class="line">  containers:</span><br><span class="line">    - name: my-container</span><br><span class="line">      image: nginx</span><br></pre></td></tr></table></figure><p>上述示例中，Pod my-pod 与 my-service-account ServiceAccount关联。</p><h3 id="ServiceAccount的使用"><a href="#ServiceAccount的使用" class="headerlink" title="ServiceAccount的使用"></a>ServiceAccount的使用</h3><p>Pod中的应用程序可以使用ServiceAccount提供的令牌（Token）进行身份验证，以便与Kubernetes API Server通信。令牌通常存储在 &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token 路径下。</p><h2 id="ServiceAccount示例演示"><a href="#ServiceAccount示例演示" class="headerlink" title="ServiceAccount示例演示"></a>ServiceAccount示例演示</h2><p>在示例中，我们将创建一个ServiceAccount，并将其关联到一个简单的Pod，演示Pod如何使用ServiceAccount提供的令牌进行身份验证。</p><h3 id="步骤一：创建ServiceAccount"><a href="#步骤一：创建ServiceAccount" class="headerlink" title="步骤一：创建ServiceAccount"></a>步骤一：创建ServiceAccount</h3><p>创建一个名为example-service-account的ServiceAccount：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: example-service-account</span><br></pre></td></tr></table></figure><h3 id="步骤二：创建关联ServiceAccount的Pod"><a href="#步骤二：创建关联ServiceAccount的Pod" class="headerlink" title="步骤二：创建关联ServiceAccount的Pod"></a>步骤二：创建关联ServiceAccount的Pod</h3><p>创建一个Pod，将其与上述ServiceAccount关联，并输出ServiceAccount提供的令牌：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line">  serviceAccountName: example-service-account</span><br><span class="line">  containers:</span><br><span class="line">    - name: my-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /var/run/secrets/kubernetes.io/serviceaccount/token&quot;]</span><br></pre></td></tr></table></figure><h3 id="步骤三：验证令牌"><a href="#步骤三：验证令牌" class="headerlink" title="步骤三：验证令牌"></a>步骤三：验证令牌</h3><p>查看Pod的输出，确认ServiceAccount提供的令牌已成功注入到Pod中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs example-pod</span><br></pre></td></tr></table></figure><p>上述步骤演示了如何创建ServiceAccount，并将其与Pod关联，以便在Pod中获取ServiceAccount提供的令牌进行身份验证。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理对象ServiceAccount的基本概念、使用方法，并通过详细的示例演示了如何创建ServiceAccount，并将其与Pod关联，以实现身份验证。ServiceAccount在Kubernetes中扮演着关键的角色，确保了Pod能够与API Server正确地交互，并获取所需的权限。在实际使用中，根据业务需求，可以创建不同的ServiceAccount，并将其关联到不同的Pod，以实现更精细的权限控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础概念</title>
      <link href="/posts/ba02eb10.html"/>
      <url>/posts/ba02eb10.html</url>
      
        <content type="html"><![CDATA[<p>Docker的操作围绕镜像、容器、仓库三大核心概念。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是什么呢？通俗地讲，它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。所以你想启动一个容器，那首先必须要有一个镜像。<strong>镜像是 Docker 容器启动的先决条件。</strong></p><p>如果你想使用一个镜像，你可以使用这种方式：</p><ul><li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，你可以在基础镜像上添加一些用户自定义的内容。例如你可以基于<code>centos</code>镜像制作你自己的业务镜像，首先安装<code>nginx</code>服务，然后部署你的应用程序，最后做一些自定义配置，这样一个业务镜像就做好了。</li><li>从功能镜像仓库拉取别人制作好的镜像。一些常用的软件或者系统都会有官方已经制作好的镜像，例如<code>nginx</code>、<code>ubuntu</code>、<code>centos</code>、<code>mysql</code>等，你可以到 <a href="https://hub.docker.com/">Docker Hub</a> 搜索并下载它们。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是什么呢？容器是 Docker 的另一个核心概念。通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即<strong>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。</strong></p><p>虽然容器的本质是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。镜像仓库分为公共镜像仓库和私有镜像仓库。</p><p>目前，<a href="https://hub.docker.com/">Docker Hub</a> 是 Docker 官方的公开镜像仓库，它不仅有很多应用或者操作系统的官方镜像，还有很多组织或者个人开发的镜像供我们免费存放、下载、研究和使用。除了公开镜像仓库，你也可以构建自己的私有镜像仓库。</p><h2 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h2><p>镜像是容器的基石，容器是由镜像创建的。一个镜像可以创建多个容器，容器是镜像运行的实体。仓库就非常好理解了，就是用来存放和分发镜像的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理模型webhook</title>
      <link href="/posts/4a17b605.html"/>
      <url>/posts/4a17b605.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（K8s）作为一个强大的容器编排系统，拥有丰富的权限管理机制，其中Webhook是一种灵活且可扩展的权限管理模型。Webhook通过允许集群管理员使用自定义的外部服务进行权限决策，为用户提供了更细粒度的访问控制。本文将深入研究Kubernetes中Webhook的基本概念、核心组件，以及通过详细的示例演示如何实现基于Webhook的权限管理。</p><h2 id="Webhook基本概念"><a href="#Webhook基本概念" class="headerlink" title="Webhook基本概念"></a>Webhook基本概念</h2><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>Webhook是一个HTTP回调，当某个事件发生时，Kubernetes会向预定义的外部服务发送HTTP请求，以实现自定义逻辑。在权限管理中，Webhook用于对访问请求进行验证和授权。</p><h3 id="Admission-Controller"><a href="#Admission-Controller" class="headerlink" title="Admission Controller"></a>Admission Controller</h3><p>Admission Controller是Kubernetes API Server的一部分，负责处理请求前和请求后的逻辑。通过Webhook，Admission Controller可以调用外部服务进行权限决策，以决定是否接受或拒绝请求。</p><h2 id="Webhook核心组件"><a href="#Webhook核心组件" class="headerlink" title="Webhook核心组件"></a>Webhook核心组件</h2><h3 id="Admission-Controller配置"><a href="#Admission-Controller配置" class="headerlink" title="Admission Controller配置"></a>Admission Controller配置</h3><p>要启用Webhook，需要对Kubernetes API Server的Admission Controller进行配置。在kube-apiserver的启动参数中添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--enable-admission-plugins=...,MutatingAdmissionWebhook,ValidatingAdmissionWebhook</span><br><span class="line">--admission-control-config-file=/path/to/admission-config.yaml</span><br></pre></td></tr></table></figure><h3 id="Admission-Controller配置文件"><a href="#Admission-Controller配置文件" class="headerlink" title="Admission Controller配置文件"></a>Admission Controller配置文件</h3><p>创建一个Admission Controller的配置文件，指定Webhook的地址和相关参数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: admissionregistration.k8s.io/v1</span><br><span class="line">kind: MutatingWebhookConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: mutating-webhook.example.com</span><br><span class="line">webhooks:</span><br><span class="line">- name: mutating.example.com</span><br><span class="line">  clientConfig:</span><br><span class="line">    url: &quot;https://webhook-service.example.com/mutate&quot;</span><br><span class="line">  rules:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="Webhook的使用方法"><a href="#Webhook的使用方法" class="headerlink" title="Webhook的使用方法"></a>Webhook的使用方法</h2><h3 id="创建Webhook服务"><a href="#创建Webhook服务" class="headerlink" title="创建Webhook服务"></a>创建Webhook服务</h3><p>首先，创建一个Webhook服务，该服务负责处理来自Kubernetes的请求。示例Webhook服务可以使用任何支持HTTP的语言和框架。以下是一个简单的示例使用Python Flask框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/mutate&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def mutate():</span><br><span class="line">    # 处理来自Kubernetes的请求</span><br><span class="line">    admission_review = request.get_json()</span><br><span class="line">    # 执行自定义逻辑，修改Pod定义等</span><br><span class="line">    # ...</span><br><span class="line">    # 返回AdmissionReview响应</span><br><span class="line">    return &#123;&quot;response&quot;: &#123;&quot;allowed&quot;: True&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="注册Webhook"><a href="#注册Webhook" class="headerlink" title="注册Webhook"></a>注册Webhook</h3><p>在Kubernetes中注册Webhook，将其与Admission Controller关联。使用先前创建的配置文件，通过kubectl命令注册Webhook：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f webhook-config.yaml</span><br></pre></td></tr></table></figure><h3 id="验证Webhook生效"><a href="#验证Webhook生效" class="headerlink" title="验证Webhook生效"></a>验证Webhook生效</h3><p>创建一个Pod并观察Webhook是否被调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>查看Webhook服务的日志，确认是否收到了来自Kubernetes的请求并执行了自定义逻辑。</p><h2 id="Webhook示例演示"><a href="#Webhook示例演示" class="headerlink" title="Webhook示例演示"></a>Webhook示例演示</h2><p>在示例中，我们将创建一个简单的Webhook服务，用于验证Pod的名称是否符合特定的命名规范。Webhook将拒绝不符合规范的Pod创建请求。</p><h3 id="步骤一：创建Webhook服务"><a href="#步骤一：创建Webhook服务" class="headerlink" title="步骤一：创建Webhook服务"></a>步骤一：创建Webhook服务</h3><p>创建一个Python Flask应用，监听&#x2F;mutate端点，验证Pod的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/mutate&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def mutate():</span><br><span class="line">    admission_review = request.get_json()</span><br><span class="line">    pod_name = admission_review[&quot;request&quot;][&quot;object&quot;][&quot;metadata&quot;][&quot;name&quot;]</span><br><span class="line">    if not pod_name.startswith(&quot;valid-prefix-&quot;):</span><br><span class="line">        response = &#123;&quot;response&quot;: &#123;&quot;allowed&quot;: False, &quot;status&quot;: &#123;&quot;reason&quot;: &quot;InvalidPodName&quot;&#125;&#125;&#125;</span><br><span class="line">        return jsonify(response)</span><br><span class="line">    return &#123;&quot;response&quot;: &#123;&quot;allowed&quot;: True&#125;&#125;</span><br></pre></td></tr></table></figure><p>保存为webhook.py。</p><h3 id="步骤二：启动Webhook服务"><a href="#步骤二：启动Webhook服务" class="headerlink" title="步骤二：启动Webhook服务"></a>步骤二：启动Webhook服务</h3><p>使用以下命令启动Webhook服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">python webhook.py</span><br></pre></td></tr></table></figure><h3 id="步骤三：创建Webhook配置文件"><a href="#步骤三：创建Webhook配置文件" class="headerlink" title="步骤三：创建Webhook配置文件"></a>步骤三：创建Webhook配置文件</h3><p>创建一个Admission Controller的配置文件，指定Webhook的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: admissionregistration.k8s.io/v1</span><br><span class="line">kind: MutatingWebhookConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-name-validator</span><br><span class="line">webhooks:</span><br><span class="line">- name: pod-name-validator.example.com</span><br><span class="line">  clientConfig:</span><br><span class="line">    url: &quot;http://localhost:5000/mutate&quot;</span><br><span class="line">  rules:</span><br><span class="line">  - operations: [&quot;CREATE&quot;]</span><br><span class="line">    apiGroups: [&quot;&quot;]</span><br><span class="line">    apiVersions: [&quot;v1&quot;]</span><br><span class="line">    resources: [&quot;pods&quot;]</span><br><span class="line">  namespaceSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      environment: &quot;production&quot;</span><br></pre></td></tr></table></figure><p>保存为webhook-config.yaml。</p><h3 id="步骤四：注册Webhook"><a href="#步骤四：注册Webhook" class="headerlink" title="步骤四：注册Webhook"></a>步骤四：注册Webhook</h3><p>使用以下命令注册Webhook：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f webhook-config.yaml</span><br></pre></td></tr></table></figure><h3 id="步骤五：创建不符合规范的Pod"><a href="#步骤五：创建不符合规范的Pod" class="headerlink" title="步骤五：创建不符合规范的Pod"></a>步骤五：创建不符合规范的Pod</h3><p>创建一个不符合规范的Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: invalid-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>你会发现该Pod的创建请求被拒绝，因为它的名称不符合规范。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理模型Webhook的基本概念、核心组件，并通过详细的示例演示了如何创建一个简单的Webhook服务，以及如何使用Webhook实现对Pod创建请求的权限控制。Webhook为Kubernetes提供了一种可扩展且灵活的权限管理方式，能够满足各种复杂的权限控制需求。在实际使用中，可以根据业务需求，定义和注册不同的Webhook服务，以实现更细粒度的权限控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理模型ABAC</title>
      <link href="/posts/4a17b604.html"/>
      <url>/posts/4a17b604.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，权限管理是确保集群安全性和合规性的重要组成部分。Attribute-Based Access Control（ABAC）是K8s中的一种权限管理模型，它通过基于属性的规则来定义和控制对资源的访问权限。本文将深入研究K8s中的ABAC模型，包括其基本概念、核心组件、使用方法以及详细示例。</p><h2 id="ABAC基本概念"><a href="#ABAC基本概念" class="headerlink" title="ABAC基本概念"></a>ABAC基本概念</h2><h3 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h3><p>在ABAC中，属性是指用于定义访问权限规则的特征或条件。这些特征可以包括用户、组、命名空间等。</p><h3 id="策略（Policy）"><a href="#策略（Policy）" class="headerlink" title="策略（Policy）"></a>策略（Policy）</h3><p>策略是一组基于属性的规则，用于决定用户或实体是否有权访问某个资源。</p><h3 id="主体（Subject）"><a href="#主体（Subject）" class="headerlink" title="主体（Subject）"></a>主体（Subject）</h3><p>主体是指发起访问请求的实体，可以是用户、服务账户或其他身份。</p><h3 id="资源（Resource）"><a href="#资源（Resource）" class="headerlink" title="资源（Resource）"></a>资源（Resource）</h3><p>资源是主体试图访问的对象，如Pod、Service等K8s中的资源。</p><h2 id="ABAC核心组件"><a href="#ABAC核心组件" class="headerlink" title="ABAC核心组件"></a>ABAC核心组件</h2><h3 id="ABAC模块"><a href="#ABAC模块" class="headerlink" title="ABAC模块"></a>ABAC模块</h3><p>ABAC模块是K8s中负责实施ABAC策略的组件。它会解析访问请求中的属性，与定义的策略进行匹配，从而决定是否允许访问。</p><h3 id="ABAC策略文件"><a href="#ABAC策略文件" class="headerlink" title="ABAC策略文件"></a>ABAC策略文件</h3><p>ABAC策略文件包含了一组策略规则，定义了在何种情况下主体可以访问资源。策略文件是一个JSON文件，可以通过API服务器的启动参数进行指定。</p><h2 id="ABAC的使用方法"><a href="#ABAC的使用方法" class="headerlink" title="ABAC的使用方法"></a>ABAC的使用方法</h2><h3 id="创建ABAC策略文件"><a href="#创建ABAC策略文件" class="headerlink" title="创建ABAC策略文件"></a>创建ABAC策略文件</h3><p>首先，创建一个ABAC策略文件。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apiVersion&quot;: &quot;abac.authorization.k8s.io/v1beta1&quot;,</span><br><span class="line">  &quot;kind&quot;: &quot;Policy&quot;,</span><br><span class="line">  &quot;spec&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &quot;john&quot;,</span><br><span class="line">    &quot;namespace&quot;: &quot;default&quot;,</span><br><span class="line">    &quot;resource&quot;: &quot;pods&quot;,</span><br><span class="line">    &quot;readonly&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述策略规定用户john在default命名空间中对pods资源具有只读权限。</p><h3 id="启用ABAC模块"><a href="#启用ABAC模块" class="headerlink" title="启用ABAC模块"></a>启用ABAC模块</h3><p>在K8s API服务器的启动参数中指定ABAC策略文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--authorization-mode=ABAC</span><br><span class="line">--authorization-policy-file=/path/to/abac-policy-file.json</span><br></pre></td></tr></table></figure><h3 id="验证访问权限"><a href="#验证访问权限" class="headerlink" title="验证访问权限"></a>验证访问权限</h3><p>通过kubectl命令验证用户对资源的访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i get pods --as john</span><br><span class="line">kubectl auth can-i create pods --as john</span><br></pre></td></tr></table></figure><p>根据上述策略文件，第一个命令应返回true，而第二个命令应返回false。</p><h2 id="ABAC示例演示"><a href="#ABAC示例演示" class="headerlink" title="ABAC示例演示"></a>ABAC示例演示</h2><p>在示例中，我们将创建一个ABAC策略文件，定义用户john对default命名空间中的pods资源有读写权限。</p><h3 id="步骤一：创建ABAC策略文件"><a href="#步骤一：创建ABAC策略文件" class="headerlink" title="步骤一：创建ABAC策略文件"></a>步骤一：创建ABAC策略文件</h3><p>创建一个JSON文件，例如abac-policy.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apiVersion&quot;: &quot;abac.authorization.k8s.io/v1beta1&quot;,</span><br><span class="line">  &quot;kind&quot;: &quot;Policy&quot;,</span><br><span class="line">  &quot;spec&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &quot;john&quot;,</span><br><span class="line">    &quot;namespace&quot;: &quot;default&quot;,</span><br><span class="line">    &quot;resource&quot;: &quot;pods&quot;,</span><br><span class="line">    &quot;readonly&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二：启用ABAC模块"><a href="#步骤二：启用ABAC模块" class="headerlink" title="步骤二：启用ABAC模块"></a>步骤二：启用ABAC模块</h3><p>在K8s API服务器的启动参数中指定ABAC策略文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--authorization-mode=ABAC</span><br><span class="line">--authorization-policy-file=/path/to/abac-policy.json</span><br></pre></td></tr></table></figure><h3 id="步骤三：验证访问权限"><a href="#步骤三：验证访问权限" class="headerlink" title="步骤三：验证访问权限"></a>步骤三：验证访问权限</h3><p>使用kubectl命令验证用户john对default命名空间中的pods资源的访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i get pods --as john</span><br><span class="line">kubectl auth can-i create pods --as john</span><br></pre></td></tr></table></figure><p>根据策略文件，第一个命令应返回true，而第二个命令应返回true。</p><p>通过以上示例，我们演示了如何使用ABAC在Kubernetes中定义和控制用户对资源的访问权限。ABAC通过属性的方式定义访问规则，提供了一种相对简单而直观的权限管理模型。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理模型ABAC的基本概念、核心组件，并通过详细的示例演示了如何创建ABAC策略文件、启用ABAC模块以及验证用户对资源的访问权限。ABAC作为Kubernetes中的一种权限管理模型，相对直观易懂，适用于一些简单的权限控制场景。在实际使用中，需要根据集群规模和业务需求，选择最合适的权限管理模型，以达到最佳的安全实践。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s权限管理模型RBAC</title>
      <link href="/posts/4a17b603.html"/>
      <url>/posts/4a17b603.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes（K8s）中，权限管理是确保集群安全性和合规性的关键组成部分。Role-Based Access Control（RBAC）是K8s中使用最广泛的权限管理模型之一，它允许管理员定义和控制用户、服务账户等实体对于资源的访问权限。本文将深入探讨K8s中的RBAC模型，包括其基本概念、核心组件、使用方法以及详细示例。</p><h2 id="RBAC基本概念"><a href="#RBAC基本概念" class="headerlink" title="RBAC基本概念"></a>RBAC基本概念</h2><h3 id="角色（Role）"><a href="#角色（Role）" class="headerlink" title="角色（Role）"></a>角色（Role）</h3><p>角色是RBAC的基本单元，用于定义对资源的一组权限。角色是独立于命名空间的，可以在整个集群范围内使用。</p><h3 id="角色绑定（RoleBinding）"><a href="#角色绑定（RoleBinding）" class="headerlink" title="角色绑定（RoleBinding）"></a>角色绑定（RoleBinding）</h3><p>角色绑定用于将角色与用户、服务账户等实体绑定在一起，赋予其相应的权限。通过角色绑定，可以实现将某个用户或服务账户与特定的权限关联起来。</p><h3 id="集群角色（ClusterRole）"><a href="#集群角色（ClusterRole）" class="headerlink" title="集群角色（ClusterRole）"></a>集群角色（ClusterRole）</h3><p>集群角色与角色类似，但作用于整个集群，而不是单个命名空间。它允许定义对集群级别资源的权限。</p><h3 id="集群角色绑定（ClusterRoleBinding）"><a href="#集群角色绑定（ClusterRoleBinding）" class="headerlink" title="集群角色绑定（ClusterRoleBinding）"></a>集群角色绑定（ClusterRoleBinding）</h3><p>与角色绑定类似，集群角色绑定用于将集群角色与用户、服务账户等实体绑定在一起，赋予其在整个集群中的权限。</p><h2 id="RBAC核心组件"><a href="#RBAC核心组件" class="headerlink" title="RBAC核心组件"></a>RBAC核心组件</h2><h3 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h3><p>以下是一个简单的Role定义的示例，该Role允许用户对Pod进行get和list操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure><h3 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h3><p>创建RoleBinding将用户绑定到上述Role：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: &quot;john&quot;</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h3 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h3><p>以下是一个简单的ClusterRole定义的示例，该ClusterRole允许用户对Nodes进行get操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: node-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;nodes&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br></pre></td></tr></table></figure><h3 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h3><p>创建ClusterRoleBinding将用户绑定到上述ClusterRole：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-nodes</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: &quot;john&quot;</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: node-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h2 id="RBAC的使用方法"><a href="#RBAC的使用方法" class="headerlink" title="RBAC的使用方法"></a>RBAC的使用方法</h2><h3 id="创建Role和RoleBinding"><a href="#创建Role和RoleBinding" class="headerlink" title="创建Role和RoleBinding"></a>创建Role和RoleBinding</h3><p>首先，创建一个Role，定义资源和权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure><p>接下来，创建一个RoleBinding，将用户绑定到上述Role：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: &quot;john&quot;</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h3 id="创建ClusterRole和ClusterRoleBinding"><a href="#创建ClusterRole和ClusterRoleBinding" class="headerlink" title="创建ClusterRole和ClusterRoleBinding"></a>创建ClusterRole和ClusterRoleBinding</h3><p>创建一个ClusterRole，定义对Nodes资源的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: node-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;nodes&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br></pre></td></tr></table></figure><p>创建一个ClusterRoleBinding，将用户绑定到上述ClusterRole：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: read-nodes</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: &quot;john&quot;</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: node-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h2 id="RBAC示例演示"><a href="#RBAC示例演示" class="headerlink" title="RBAC示例演示"></a>RBAC示例演示</h2><p>假设我们有一个Pod，其定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pod</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>使用上述创建的Role和RoleBinding，用户john将具有get和list的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用用户john的身份验证</span><br><span class="line">kubectl auth can-i get pods --as john</span><br><span class="line">kubectl auth can-i list pods --as john</span><br></pre></td></tr></table></figure><p>同样，使用创建的ClusterRole和ClusterRoleBinding，用户john将具有对Nodes资源的get权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用用户john的身份验证</span><br><span class="line">kubectl auth can-i get nodes --as john</span><br></pre></td></tr></table></figure><p>通过以上示例，我们演示了如何使用RBAC在Kubernetes中定义和控制用户对资源的权限。RBAC通过细粒度的访问控制，有力地保护了Kubernetes集群中的资源，确保了集群的安全性和合规性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes中权限管理模型RBAC的基本概念、核心组件，并通过详细的示例演示了如何创建Role、RoleBinding、ClusterRole和ClusterRoleBinding，以及如何验证用户对资源的权限。RBAC是Kubernetes中一个强大而灵活的权限管理工具，可以根据实际需求为不同用户和服务账户分配适当的权限，确保了集群的安全性。在实际使用中，需要根据集群规模和业务需求，合理设计和配置RBAC规则，以达到最佳的安全实践。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络插件cilium</title>
      <link href="/posts/4a17b602.html"/>
      <url>/posts/4a17b602.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着Kubernetes在容器编排领域的广泛应用，网络插件的选择对集群的性能、安全性和可管理性有着重要的影响。Cilium是一款强大的Kubernetes网络插件，以其灵活的功能、高性能和先进的安全特性而受到关注。本文将深入研究Cilium的特点、优势、劣势，并通过详细的示例演示在Kubernetes集群中使用Cilium进行网络管理的过程。</p><h2 id="Cilium的特点"><a href="#Cilium的特点" class="headerlink" title="Cilium的特点"></a>Cilium的特点</h2><h3 id="eBPF技术"><a href="#eBPF技术" class="headerlink" title="eBPF技术"></a>eBPF技术</h3><p>Cilium采用eBPF（extended Berkeley Packet Filter）技术，这是一种在Linux内核中执行代码的机制。通过eBPF，Cilium能够在数据包经过内核网络栈的不同阶段注入自定义的逻辑，实现更高效的网络过滤和管理。</p><h3 id="Service-Identity和加密"><a href="#Service-Identity和加密" class="headerlink" title="Service Identity和加密"></a>Service Identity和加密</h3><p>Cilium支持Service Identity，即通过密钥和证书为每个服务创建唯一的标识。此外，Cilium还支持对服务之间的通信进行加密，提高了集群中的通信安全性。</p><h3 id="Layer-7应用层代理"><a href="#Layer-7应用层代理" class="headerlink" title="Layer 7应用层代理"></a>Layer 7应用层代理</h3><p>Cilium具备Layer 7应用层代理的能力，可以直接理解和处理HTTP、gRPC等应用层协议，实现更精细的流量控制和路由。</p><h3 id="Distributed-Stateful-Firewall"><a href="#Distributed-Stateful-Firewall" class="headerlink" title="Distributed Stateful Firewall"></a>Distributed Stateful Firewall</h3><p>Cilium引入了分布式的有状态防火墙，使得在整个集群中对网络流量进行安全控制变得更为灵活和高效。</p><h2 id="Cilium的优势"><a href="#Cilium的优势" class="headerlink" title="Cilium的优势"></a>Cilium的优势</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>由于采用了eBPF技术，Cilium在网络过滤和管理方面表现出色，能够处理大规模集群的高并发流量。</p><h3 id="丰富的安全特性"><a href="#丰富的安全特性" class="headerlink" title="丰富的安全特性"></a>丰富的安全特性</h3><p>Cilium的Service Identity、加密通信以及分布式有状态防火墙等安全特性，使得集群中的网络通信更加安全可控。</p><h3 id="应用层代理"><a href="#应用层代理" class="headerlink" title="应用层代理"></a>应用层代理</h3><p>Cilium不仅仅是一个网络插件，还提供了强大的应用层代理功能，能够更智能地理解和处理应用层协议。</p><h3 id="灵活的路由与负载均衡"><a href="#灵活的路由与负载均衡" class="headerlink" title="灵活的路由与负载均衡"></a>灵活的路由与负载均衡</h3><p>Cilium支持灵活的路由和负载均衡配置，使得服务之间的通信更为灵活可控。</p><h2 id="Cilium的劣势"><a href="#Cilium的劣势" class="headerlink" title="Cilium的劣势"></a>Cilium的劣势</h2><h3 id="学习曲线相对陡峭"><a href="#学习曲线相对陡峭" class="headerlink" title="学习曲线相对陡峭"></a>学习曲线相对陡峭</h3><p>相较于一些传统的网络插件，Cilium的学习曲线较为陡峭，特别是对于不熟悉eBPF技术的用户来说可能需要花费一些时间来适应。</p><h3 id="对Linux内核版本的要求"><a href="#对Linux内核版本的要求" class="headerlink" title="对Linux内核版本的要求"></a>对Linux内核版本的要求</h3><p>由于Cilium使用了eBPF技术，对Linux内核版本有一定要求，需要确保在支持eBPF的版本上运行。</p><h2 id="在Kubernetes中部署Cilium的示例"><a href="#在Kubernetes中部署Cilium的示例" class="headerlink" title="在Kubernetes中部署Cilium的示例"></a>在Kubernetes中部署Cilium的示例</h2><p>接下来，我们将通过一个实际的示例演示如何在Kubernetes集群中部署Cilium。</p><h3 id="步骤一：下载Cilium-YAML清单文件"><a href="#步骤一：下载Cilium-YAML清单文件" class="headerlink" title="步骤一：下载Cilium YAML清单文件"></a>步骤一：下载Cilium YAML清单文件</h3><p>首先，从Cilium官方GitHub仓库中下载Cilium的YAML清单文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64</span><br><span class="line">sudo mv cilium-linux-amd64 /usr/local/bin/cilium</span><br><span class="line">sudo chmod +x /usr/local/bin/cilium</span><br><span class="line">cilium install</span><br></pre></td></tr></table></figure><h3 id="步骤二：验证Cilium的部署"><a href="#步骤二：验证Cilium的部署" class="headerlink" title="步骤二：验证Cilium的部署"></a>步骤二：验证Cilium的部署</h3><p>运行以下命令，确保Cilium的所有组件都处于运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n cilium</span><br></pre></td></tr></table></figure><h3 id="步骤三：测试Cilium的网络功能"><a href="#步骤三：测试Cilium的网络功能" class="headerlink" title="步骤三：测试Cilium的网络功能"></a>步骤三：测试Cilium的网络功能</h3><p>创建两个简单的Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-a</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do sleep 3600; done&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-b</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do sleep 3600; done&quot;]</span><br></pre></td></tr></table></figure><p>然后，在Pod-a中ping Pod-b：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it pod-a -- /bin/sh</span><br><span class="line">ping pod-b</span><br></pre></td></tr></table></figure><p>确保网络通信正常，这样就验证了Cilium的成功部署和网络通信功能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes网络插件Cilium的特点、优势和劣势，并通过详细的示例演示了如何在Kubernetes集群中安装和配置Cilium。Cilium以其先进的eBPF技术、高性能、强大的安全特性和应用层代理功能在Kubernetes社区中备受瞩目。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络插件calico</title>
      <link href="/posts/4a17b601.html"/>
      <url>/posts/4a17b601.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes是当今容器编排领域的翘楚，而网络插件则是确保Kubernetes集群中各个Pod之间正常通信的核心组件。Calico（Project Calico）是一款广受欢迎的Kubernetes网络插件，以其灵活性、高性能和强大的特性而闻名。本文将深入探讨Calico的特点、优势、劣势，并通过详细的示例演示如何在Kubernetes集群中使用Calico进行网络管理。</p><h2 id="Calico的特点"><a href="#Calico的特点" class="headerlink" title="Calico的特点"></a>Calico的特点</h2><h3 id="纯Layer-3架构"><a href="#纯Layer-3架构" class="headerlink" title="纯Layer 3架构"></a>纯Layer 3架构</h3><p>Calico采用纯Layer 3架构，即每个节点上的Pod都拥有唯一的IP地址。这种设计简化了网络管理，同时提供了更直观的网络拓扑。</p><h3 id="BGP路由"><a href="#BGP路由" class="headerlink" title="BGP路由"></a>BGP路由</h3><p>Calico使用BGP（Border Gateway Protocol）进行路由，实现了高效的IP路由和负载均衡。BGP的使用使得Calico适用于大规模的集群和复杂的网络环境。</p><h3 id="ACL（Access-Control-List）"><a href="#ACL（Access-Control-List）" class="headerlink" title="ACL（Access Control List）"></a>ACL（Access Control List）</h3><p>Calico支持ACL，允许对网络流量进行精细的访问控制。通过定义ACL规则，可以实现对Pod之间和Pod与外部网络之间的流量进行安全控制。</p><h3 id="网络流量加密"><a href="#网络流量加密" class="headerlink" title="网络流量加密"></a>网络流量加密</h3><p>Calico支持使用IPSec对跨节点的网络流量进行加密，提高了集群的安全性。</p><h2 id="Calico的优势"><a href="#Calico的优势" class="headerlink" title="Calico的优势"></a>Calico的优势</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>由于采用纯Layer 3架构和BGP路由，Calico在网络性能方面表现出色。它适用于需要高吞吐量和低延迟的应用场景，如大数据处理和机器学习工作负载。</p><h3 id="易于管理"><a href="#易于管理" class="headerlink" title="易于管理"></a>易于管理</h3><p>Calico的设计简单且易于理解，对于运维人员来说，部署和管理都相对轻松。Calico的网络拓扑直观，便于排查和解决问题。</p><h3 id="强大的安全性"><a href="#强大的安全性" class="headerlink" title="强大的安全性"></a>强大的安全性</h3><p>通过ACL和IPSec的支持，Calico提供了灵活且强大的安全控制机制。管理员可以根据实际需求定义细粒度的访问规则，确保集群中的网络流量安全可控。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>Calico的架构天生支持横向扩展，适用于大型集群。它能够适应不断增长的网络规模，确保在规模扩大时仍能保持良好的性能和稳定性。</p><h2 id="Calico的劣势"><a href="#Calico的劣势" class="headerlink" title="Calico的劣势"></a>Calico的劣势</h2><h3 id="对Underlay网络的依赖"><a href="#对Underlay网络的依赖" class="headerlink" title="对Underlay网络的依赖"></a>对Underlay网络的依赖</h3><p>Calico对底层网络有一定的依赖，尤其是对BGP路由器的需求。在某些云服务商的环境中，可能需要更多的配置来适配Calico。</p><h3 id="相对复杂的部署"><a href="#相对复杂的部署" class="headerlink" title="相对复杂的部署"></a>相对复杂的部署</h3><p>相较于一些更简单的网络插件，Calico的部署相对复杂一些，特别是对于初学者来说可能需要更多的学习和配置。</p><h2 id="在Kubernetes中部署Calico的示例"><a href="#在Kubernetes中部署Calico的示例" class="headerlink" title="在Kubernetes中部署Calico的示例"></a>在Kubernetes中部署Calico的示例</h2><p>接下来，我们将通过一个实际的示例演示如何在Kubernetes集群中部署Calico。</p><h3 id="步骤一：下载Calico-YAML清单文件"><a href="#步骤一：下载Calico-YAML清单文件" class="headerlink" title="步骤一：下载Calico YAML清单文件"></a>步骤一：下载Calico YAML清单文件</h3><p>首先，下载Calico的YAML清单文件，可以从Calico官方GitHub仓库中获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br></pre></td></tr></table></figure><h3 id="步骤二：部署Calico"><a href="#步骤二：部署Calico" class="headerlink" title="步骤二：部署Calico"></a>步骤二：部署Calico</h3><p>使用kubectl命令将Calico清单文件应用到Kubernetes集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>等待一段时间，直到Calico组件全部部署完成。</p><h3 id="步骤三：验证Calico的部署"><a href="#步骤三：验证Calico的部署" class="headerlink" title="步骤三：验证Calico的部署"></a>步骤三：验证Calico的部署</h3><p>运行以下命令，确保Calico的所有组件都处于运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -l k8s-app=calico-node</span><br></pre></td></tr></table></figure><p>步骤四：测试网络通信</p><p>创建两个简单的Pod，分别属于不同的命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-a</span><br><span class="line">  namespace: ns-a</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do sleep 3600; done&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-b</span><br><span class="line">  namespace: ns-b</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do sleep 3600; done&quot;]</span><br></pre></td></tr></table></figure><p>然后，尝试在Pod-a中ping Pod-b：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it pod-a -n ns-a -- /bin/sh</span><br><span class="line">ping pod-b.ns-b</span><br></pre></td></tr></table></figure><p>确保网络通信正常，这样就验证了Calico的成功部署和网络通信功能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入了解了Kubernetes网络插件Calico的特点、优势和劣势，并通过详细的示例演示了如何在Kubernetes集群中安装和配置Calico。Calico以其高性能、易管理性和强大的安全特性在Kubernetes社区中备受推崇。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络插件flannel</title>
      <link href="/posts/4a17b530.html"/>
      <url>/posts/4a17b530.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Kubernetes集群中，网络插件（Network Plugin）是连接Pod之间、以及Pod与外部网络通信的关键组件之一。Flannel是一款常用的Kubernetes网络插件，它通过简单而高效的方式提供了跨节点的网络通信。本文将深入研究Flannel的原理、架构，并通过详细的示例演示如何在Kubernetes集群中使用Flannel实现高效的网络通信。</p><h2 id="Flannel的基本原理"><a href="#Flannel的基本原理" class="headerlink" title="Flannel的基本原理"></a>Flannel的基本原理</h2><p>Flannel是一种虚拟网络解决方案，它为每个Kubernetes Pod分配唯一的IP地址，并通过底层网络设备（如VXLAN、UDP等）实现跨节点的通信。其基本原理包括以下几个关键概念：</p><ul><li>Overlay网络：Flannel使用Overlay网络技术，在底层网络之上创建一个逻辑网络，使得各个节点上的Pod可以通过这个逻辑网络进行通信，而无需考虑底层网络的细节。</li><li>Subnet管理：Flannel使用子网（Subnet）来为每个节点分配一组IP地址。每个节点上的Pod将从其分配的子网中获得IP地址，确保整个集群中的IP地址唯一性。</li><li>路由规则：Flannel会在节点之间创建路由规则，以确保跨节点的Pod之间的通信正常。这些规则使得每个节点都能够通过Overlay网络找到其他节点上的Pod。</li></ul><h2 id="Flannel的架构"><a href="#Flannel的架构" class="headerlink" title="Flannel的架构"></a>Flannel的架构</h2><p>Flannel的架构主要包括两个关键组件：etcd和flanneld。</p><ul><li>etcd：作为Flannel的后端存储，存储着整个集群的网络配置信息，包括每个节点的子网分配情况等。</li><li>flanneld：在每个节点上运行的代理程序，负责与etcd交互、获取子网信息、维护路由规则，并通过底层网络设备实现Overlay网络。</li></ul><h2 id="Flannel的安装"><a href="#Flannel的安装" class="headerlink" title="Flannel的安装"></a>Flannel的安装</h2><h3 id="安装Flannel"><a href="#安装Flannel" class="headerlink" title="安装Flannel"></a>安装Flannel</h3><p>接下来，在所有节点上安装Flannel：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span><br></pre></td></tr></table></figure><h2 id="Flannel的使用示例"><a href="#Flannel的使用示例" class="headerlink" title="Flannel的使用示例"></a>Flannel的使用示例</h2><h3 id="示例一：基本Pod通信"><a href="#示例一：基本Pod通信" class="headerlink" title="示例一：基本Pod通信"></a>示例一：基本Pod通信</h3><p>首先，我们创建一个简单的Pod，并通过Flannel实现跨节点通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pod-1.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pod-2.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>创建这两个Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pod-1.yaml</span><br><span class="line">kubectl apply -f pod-2.yaml</span><br></pre></td></tr></table></figure><p>在Pod-1中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it pod-1 -- /bin/sh</span><br></pre></td></tr></table></figure><p>在Pod-1的Shell中，执行以下命令ping Pod-2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping pod-2</span><br></pre></td></tr></table></figure><p>这将演示Flannel成功建立的Overlay网络，使得Pod-1能够通过Pod名称访问Pod-2。</p><h3 id="示例二：Service之间的通信"><a href="#示例二：Service之间的通信" class="headerlink" title="示例二：Service之间的通信"></a>示例二：Service之间的通信</h3><p>接下来，我们创建两个Service，并通过Flannel实现它们之间的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># service-1.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-1</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: backend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># service-2.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-2</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: frontend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>创建这两个Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f service-1.yaml</span><br><span class="line">kubectl apply -f service-2.yaml</span><br></pre></td></tr></table></figure><p>在Service-1对应的Pod中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it &lt;pod-1-pod-id&gt; -- /bin/sh</span><br></pre></td></tr></table></figure><p>在Pod-1的Shell中，执行以下命令访问Service-2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl service-2</span><br></pre></td></tr></table></figure><p>这将演示Flannel成功建立的Overlay网络，使得Service-1能够通过Service名称访问Service-2。</p><h2 id="Flannel的高级用法"><a href="#Flannel的高级用法" class="headerlink" title="Flannel的高级用法"></a>Flannel的高级用法</h2><p>除了基本的示例外，Flannel还支持一些高级用法，如VXLAN和Host-GW（Host Gateway）模式。以下是这些模式的简要说明：</p><h3 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h3><p>在Flannel中，VXLAN模式使用VXLAN封装网络包，通过UDP协议进行通信。这种模式适用于需要跨越多个网络的复杂部署场景。</p><h3 id="Host-GW模式"><a href="#Host-GW模式" class="headerlink" title="Host-GW模式"></a>Host-GW模式</h3><p>Host-GW模式直接使用主机网络，不使用Overlay网络。这种模式适用于不需要Overlay网络而希望直接使用主机网络的场景，可以提高性能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入研究了Kubernetes网络插件Flannel的原理、架构，并通过详细的示例演示了如何在Kubernetes集群中安装、配置和使用Flannel。Flannel作为一个高效且易于使用的网络解决方案，在Kubernetes集群中具有广泛的应用。通过合理配置Flannel，可以实现集群中Pod之间和Pod与Service之间的高效通信，提高整体系统的稳定性和性能。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络对象NetworkPolicy</title>
      <link href="/posts/4a17b529.html"/>
      <url>/posts/4a17b529.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着容器编排平台Kubernetes的广泛应用，网络管理变得愈发重要。在Kubernetes中，NetworkPolicy是一项关键功能，它允许开发者定义和控制Pod之间的网络通信。本文将深入研究Kubernetes中的NetworkPolicy，详细介绍其原理、用途，并通过实际示例演示如何使用NetworkPolicy来确保集群中的网络安全。</p><h2 id="什么是NetworkPolicy？"><a href="#什么是NetworkPolicy？" class="headerlink" title="什么是NetworkPolicy？"></a>什么是NetworkPolicy？</h2><p>NetworkPolicy是Kubernetes中用于定义Pod之间网络通信规则的资源对象。通过NetworkPolicy，开发者可以控制哪些Pod可以与另外哪些Pod通信，以及使用何种方式进行通信。这种细粒度的网络控制有助于提高集群的安全性，防止未经授权的访问和通信。</p><h2 id="NetworkPolicy的基本原理"><a href="#NetworkPolicy的基本原理" class="headerlink" title="NetworkPolicy的基本原理"></a>NetworkPolicy的基本原理</h2><p>NetworkPolicy的工作原理基于以下几个核心概念：</p><ul><li>Pod选择器（PodSelector）：NetworkPolicy使用标签选择器来选择特定的Pod。通过标签，可以将网络策略应用于特定的Pod群体。</li><li>Ingress规则：定义了允许从其他Pod进入被选中Pod的规则，包括允许的协议、端口范围等。</li><li>Egress规则：定义了允许被选中Pod访问其他Pod或外部网络的规则。</li><li>Peer Pod：NetworkPolicy中的规则是基于Peer Pod（对等Pod）的。通过选择Peer Pod，可以精确定义通信策略。</li></ul><h2 id="NetworkPolicy的示例"><a href="#NetworkPolicy的示例" class="headerlink" title="NetworkPolicy的示例"></a>NetworkPolicy的示例</h2><h3 id="示例一：允许相同Namespace下的Pod通信"><a href="#示例一：允许相同Namespace下的Pod通信" class="headerlink" title="示例一：允许相同Namespace下的Pod通信"></a>示例一：允许相同Namespace下的Pod通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-same-namespace</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          project: myproject</span><br><span class="line">  egress:</span><br><span class="line">  - to:</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          project: myproject</span><br></pre></td></tr></table></figure><p>在上述清单文件中，我们创建了一个名为”allow-same-namespace”的NetworkPolicy，指定了Pod选择器为app: myapp。该策略允许来自同一命名空间下标签为project: myproject的Pod的Ingress和Egress通信。</p><h3 id="示例二：限制外部访问"><a href="#示例二：限制外部访问" class="headerlink" title="示例二：限制外部访问"></a>示例二：限制外部访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: deny-external-traffic</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: sensitive-app</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br><span class="line">  ingress: []</span><br><span class="line">  egress:</span><br><span class="line">  - to:</span><br><span class="line">    - podSelector: &#123;&#125;</span><br><span class="line">  - to:</span><br><span class="line">    - ipBlock:</span><br><span class="line">        cidr: 0.0.0.0/0</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为”deny-external-traffic”的NetworkPolicy，限制了标签为app: sensitive-app的Pod的Ingress和Egress。该策略允许Pod之间的通信，但不允许访问任何外部网络，包括0.0.0.0&#x2F;0范围的IP地址。</p><h3 id="示例三：指定端口范围"><a href="#示例三：指定端口范围" class="headerlink" title="示例三：指定端口范围"></a>示例三：指定端口范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: allow-specific-ports</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  ingress:</span><br><span class="line">  - ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">    - protocol: UDP</span><br><span class="line">      port: 53</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为”allow-specific-ports”的NetworkPolicy，指定了标签为app: frontend的Pod的Ingress规则。该规则允许从其他Pod进入的流量，其中包括TCP端口80和UDP端口53。</p><h2 id="NetworkPolicy的高级用法"><a href="#NetworkPolicy的高级用法" class="headerlink" title="NetworkPolicy的高级用法"></a>NetworkPolicy的高级用法</h2><p>除了基本的示例外，NetworkPolicy还支持一些高级用法，如网络策略的继承、Peer Pod选择器的高级匹配等。以下是一些高级用法的示例：</p><h3 id="网络策略的继承"><a href="#网络策略的继承" class="headerlink" title="网络策略的继承"></a>网络策略的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: parent-policy</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      role: parent</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          role: child</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: child-policy</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      role: child</span><br><span class="line">  policyTypes:</span><br><span class="line">  - Ingress</span><br><span class="line">  - Egress</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个NetworkPolicy。”parent-policy”用于选择标签为role: parent的Pod，并定义了一个Ingress规则，允许来自标签为role: child的Pod的通信。”child-policy”选择标签为role: child的Pod，并定义了Ingress和Egress规则。这样，”child-policy”继承了”parent-policy”的规则。</p><h3 id="高级Peer-Pod选择器匹配"><a href="#高级Peer-Pod选择器匹配" class="headerlink" title="高级Peer Pod选择器匹配"></a>高级Peer Pod选择器匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: advanced-selector-matching</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - podSelector:</span><br><span class="line">        matchExpressions:</span><br><span class="line">        - &#123;key: role, operator: In, values: [frontend, middleware]&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过matchExpressions定义了更复杂的Peer Pod选择器匹配条件。该规则选择标签为app: backend的Pod，并定义了一个Ingress规则，允许来自标签为role为frontend或middleware的Pod的通信。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入探讨了Kubernetes中的NetworkPolicy，详细介绍了其原理、基本用法，并通过丰富的示例演示了如何在实际场景中使用NetworkPolicy来实现网络策略的定义和控制。对于使用Kubernetes的开发者和运维人员来说，深入理解NetworkPolicy是确保集群网络安全的关键一步。通过合理使用NetworkPolicy，可以有效地控制Pod之间的通信，提高整体系统的安全性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s存储对象Storage-Classes</title>
      <link href="/posts/4a17b528.html"/>
      <url>/posts/4a17b528.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着云原生技术的飞速发展，Kubernetes（简称K8s）已成为容器编排的事实标准，为开发者提供了一个强大而灵活的平台。在Kubernetes中，存储管理是一个至关重要的方面，而Storage Classes（存储类）则是其中一个关键概念。本文将深入探讨K8s中的Storage Classes，详细介绍其原理、用途以及通过实际示例演示如何使用Storage Classes来管理持久化存储。</p><h2 id="什么是Storage-Classes？"><a href="#什么是Storage-Classes？" class="headerlink" title="什么是Storage Classes？"></a>什么是Storage Classes？</h2><p>在Kubernetes中，Storage Classes是用于定义不同存储配置的资源。它们允许开发者抽象存储的物理细节，使其更易于管理和使用。通过Storage Classes，可以定义存储的类型、性能、卷大小等参数，使得应用程序能够根据需求选择合适的存储。</p><h2 id="Storage-Classes的工作原理"><a href="#Storage-Classes的工作原理" class="headerlink" title="Storage Classes的工作原理"></a>Storage Classes的工作原理</h2><p>Storage Classes工作的基本原理是通过定义标准化的存储配置，使得开发者可以在不关心底层实现的情况下请求和使用存储资源。以下是Storage Classes的基本工作流程：</p><ul><li>Storage Class的定义：管理员通过Kubernetes资源清单文件定义Storage Class，指定存储的类型、Provisioner（负责实际创建存储卷的组件）、参数等信息。</li><li>动态Provisioning：当应用程序请求动态创建持久卷（Persistent Volume，简称PV）时，Storage Class会根据定义的规则，选择合适的Provisioner，并调用其接口创建相应的存储资源。</li><li>绑定和使用：创建成功的PV会被绑定到应用程序的Persistent Volume Claim（PVC）上。应用程序通过PVC使用存储资源，而不需要关心具体的存储实现细节。</li></ul><h2 id="Storage-Classes的示例"><a href="#Storage-Classes的示例" class="headerlink" title="Storage Classes的示例"></a>Storage Classes的示例</h2><h3 id="示例一：定义Storage-Class"><a href="#示例一：定义Storage-Class" class="headerlink" title="示例一：定义Storage Class"></a>示例一：定义Storage Class</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: fast</span><br><span class="line">provisioner: kubernetes.io/aws-ebs</span><br><span class="line">parameters:</span><br><span class="line">  type: gp2</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为”fast”的Storage Class，使用AWS EBS（Elastic Block Store）作为Provisioner，并指定了存储类型为gp2，即通用型SSD。</p><h3 id="示例二：创建Persistent-Volume-Claim"><a href="#示例二：创建Persistent-Volume-Claim" class="headerlink" title="示例二：创建Persistent Volume Claim"></a>示例二：创建Persistent Volume Claim</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mypvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: fast</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 10Gi</span><br></pre></td></tr></table></figure><p>上述清单文件创建了一个名为”mypvc”的Persistent Volume Claim，指定了访问模式为ReadWriteOnce、使用的Storage Class为”fast”，并请求10GB的存储空间。</p><h3 id="示例三：应用程序中使用Persistent-Volume-Claim"><a href="#示例三：应用程序中使用Persistent-Volume-Claim" class="headerlink" title="示例三：应用程序中使用Persistent Volume Claim"></a>示例三：应用程序中使用Persistent Volume Claim</h3><p>在应用程序的Pod中，可以通过Volume挂载的方式使用上述创建的PVC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mycontainer</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &quot;/data&quot;</span><br><span class="line">      name: myvolume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: myvolume</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: mypvc</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为”mypod”的Pod，其中的Nginx容器将会在&#x2F;data路径下使用之前创建的PVC（“mypvc”）提供的存储空间。</p><p>通过这三个示例，我们演示了如何定义Storage Class、创建Persistent Volume Claim以及在应用程序中使用这些资源。这种动态的存储管理方式使得开发者能够更加灵活地应对不同的存储需求。</p><h2 id="Storage-Classes的高级用法"><a href="#Storage-Classes的高级用法" class="headerlink" title="Storage Classes的高级用法"></a>Storage Classes的高级用法</h2><p>除了基本的示例外，Storage Classes还支持一些高级用法，如Volume Snapshot（存储卷快照）、Topology（拓扑感知存储）等。这些功能进一步提升了Kubernetes在存储管理方面的能力。</p><h3 id="Volume-Snapshot"><a href="#Volume-Snapshot" class="headerlink" title="Volume Snapshot"></a>Volume Snapshot</h3><p>Storage Classes允许创建存储卷的快照，以便后续可以还原到先前的状态。以下是一个Volume Snapshot的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: snapshot.storage.k8s.io/v1</span><br><span class="line">kind: VolumeSnapshot</span><br><span class="line">metadata:</span><br><span class="line">  name: mysnapshot</span><br><span class="line">spec:</span><br><span class="line">  source:</span><br><span class="line">    persistentVolumeClaimName: mypvc</span><br></pre></td></tr></table></figure><p>上述清单文件创建了一个名为”mysnapshot”的存储卷快照，基于之前创建的PVC（“mypvc”）。</p><h3 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h3><p>Topology是一种允许存储资源与物理节点之间关联的机制。通过Topology，可以确保应用程序的Pod能够使用最接近它们的存储资源，提高性能和可靠性。以下是一个Topology的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: regional</span><br><span class="line">provisioner: kubernetes.io/aws-ebs</span><br><span class="line">allowedTopologies:</span><br><span class="line">- matchLabelExpressions:</span><br><span class="line">  - key: failure-domain.beta.kubernetes.io/region</span><br><span class="line">    values:</span><br><span class="line">    - us-west-1</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为”regional”的Storage Class，并通过allowedTopologies指定了只允许在us-west-1地区创建存储资源。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文，我们深入探讨了Kubernetes中的Storage Classes，介绍了它们的工作原理，并通过详细的示例演示了如何定义、创建和使用Storage Classes。此外，我们还提及了Storage Classes的一些高级用法，如Volume Snapshot和Topology，进一步展示了Kubernetes在存储管理方面的强大功能。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s存储机制Persistent-Volume-Claim</title>
      <link href="/posts/4a17b527.html"/>
      <url>/posts/4a17b527.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）作为一个容器编排平台，提供了强大的存储管理功能，其中的Persistent Volume Claim（PVC）是一个关键的概念。PVC允许Pod声明对持久化存储的需求，使得存储资源的使用变得灵活而可控。本文将深入研究K8s中的Persistent Volume Claim，包括其基本结构、工作原理，并通过详细的示例演示如何使用和配置Persistent Volume Claim。</p><h2 id="什么是Persistent-Volume-Claim？"><a href="#什么是Persistent-Volume-Claim？" class="headerlink" title="什么是Persistent Volume Claim？"></a>什么是Persistent Volume Claim？</h2><p>在容器编排中，Pod的生命周期是短暂的，当Pod终止时，其中的数据通常也会被销毁。为了解决这个问题，Kubernetes引入了Persistent Volume（PV）和Persistent Volume Claim（PVC）的概念。</p><p>PVC是对PV的一种声明，它定义了Pod对存储资源的需求。Pod通过PVC来请求PV，而PV则提供了实际的存储资源。PVC的引入使得开发者无需关心底层存储的细节，能够更灵活地使用和管理存储。</p><h2 id="Persistent-Volume-Claim的基本结构"><a href="#Persistent-Volume-Claim的基本结构" class="headerlink" title="Persistent Volume Claim的基本结构"></a>Persistent Volume Claim的基本结构</h2><p>PVC有一些基本的属性和状态，这些属性决定了PVC的行为和与PV的关联。</p><h3 id="Access-Modes（访问模式）"><a href="#Access-Modes（访问模式）" class="headerlink" title="Access Modes（访问模式）"></a>Access Modes（访问模式）</h3><p>PVC支持与PV相同的访问模式，用于定义Pod如何与PV进行交互。主要有以下三种访问模式：</p><ul><li>ReadWriteOnce（RWO）： 读写模式，只能被单个Pod挂载为读写模式。</li><li>ReadOnlyMany（ROX）： 只读模式，可以被多个Pod挂载为只读模式。</li><li>ReadWriteMany（RWX）： 读写模式，可以被多个Pod挂载为读写模式。</li></ul><h3 id="Storage-Class（存储类）"><a href="#Storage-Class（存储类）" class="headerlink" title="Storage Class（存储类）"></a>Storage Class（存储类）</h3><p>PVC可以选择性地指定Storage Class，用于指导Kubernetes动态地创建PV。Storage Class定义了PV的属性，包括存储类型、访问模式等。</p><h3 id="Resources（资源需求）"><a href="#Resources（资源需求）" class="headerlink" title="Resources（资源需求）"></a>Resources（资源需求）</h3><p>PVC可以定义对存储资源的需求，包括容量和访问模式。这决定了K8s为Pod提供的PV的选择。</p><h3 id="Status（状态）"><a href="#Status（状态）" class="headerlink" title="Status（状态）"></a>Status（状态）</h3><p>PVC的状态包括当前的Phase，表示PVC的生命周期阶段，可能包括Pending、Bound、Lost等。</p><h2 id="Persistent-Volume-Claim的使用示例"><a href="#Persistent-Volume-Claim的使用示例" class="headerlink" title="Persistent Volume Claim的使用示例"></a>Persistent Volume Claim的使用示例</h2><p>为了更好地理解Persistent Volume Claim的使用，以下是一个详细的示例，涉及PVC的创建、Pod的声明和与PV的关联。</p><h3 id="步骤1：创建Persistent-Volume"><a href="#步骤1：创建Persistent-Volume" class="headerlink" title="步骤1：创建Persistent Volume"></a>步骤1：创建Persistent Volume</h3><p>首先，我们创建一个PV，作为实际的存储资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  hostPath:</span><br><span class="line">    path: &quot;/mnt/data&quot;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个1Gi容量的PV，使用了ReadWriteOnce的访问模式，并指定了Retain的回收策略。PV的存储类为manual，表示这是一个手动创建的PV。PV的存储路径为&#x2F;mnt&#x2F;data。</p><h3 id="步骤2：创建Persistent-Volume-Claim"><a href="#步骤2：创建Persistent-Volume-Claim" class="headerlink" title="步骤2：创建Persistent Volume Claim"></a>步骤2：创建Persistent Volume Claim</h3><p>接下来，我们创建一个PVC，用于声明对存储资源的需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个PVC，请求1Gi容量，并指定了ReadWriteOnce的访问模式和manual的存储类。</p><h3 id="步骤3：创建Pod"><a href="#步骤3：创建Pod" class="headerlink" title="步骤3：创建Pod"></a>步骤3：创建Pod</h3><p>最后，我们创建一个Pod，并将PVC挂载到Pod的路径中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: my-container</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: my-storage</span><br><span class="line">      mountPath: &quot;/usr/share/nginx/html&quot;</span><br><span class="line">  volumes:</span><br><span class="line">  - name: my-storage</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: my-pvc</span><br></pre></td></tr></table></figure><p>这个Pod使用了Nginx镜像，并将PVC挂载到了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html路径。这样，Pod就能够访问并写入PV中的持久化数据。</p><h3 id="步骤4：验证"><a href="#步骤4：验证" class="headerlink" title="步骤4：验证"></a>步骤4：验证</h3><p>通过访问Pod中挂载的路径，我们可以验证数据是否能够持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it my-pod -- /bin/sh</span><br><span class="line"># 在Pod中执行以下命令</span><br><span class="line">echo &quot;Hello, Persistent Volume Claim!&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>通过访问PV的存储路径，我们也可以验证数据是否持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /mnt/data/index.html</span><br></pre></td></tr></table></figure><h2 id="Persistent-Volume-Claim的优势"><a href="#Persistent-Volume-Claim的优势" class="headerlink" title="Persistent Volume Claim的优势"></a>Persistent Volume Claim的优势</h2><ul><li>抽象存储细节： PVC允许Pod声明对存储的需求，而无需关心底层存储的细节。这使得应用程序更加灵活和可移植。</li><li>动态存储： 通过Storage Class，PVC可以实现动态地创建PV，使得存储的管理更加灵活，无需手动创建和管理PV。</li><li>持久化存储： PVC可以确保应用程序的数据在Pod重启或迁移时得以保留，提供了持久化存储的解决方案。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的详细介绍和示例演示，我们深入了解了Kubernetes中的Persistent Volume Claim。PVC作为K8s中存储管理的关键组件，提供了一种声明式的方式来使用和管理持久化存储资源。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s存储机制Persistent-Volume</title>
      <link href="/posts/4a17b526.html"/>
      <url>/posts/4a17b526.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）是一个强大的容器编排平台，为容器化应用程序提供了许多关键功能，包括持久化存储。在K8s中，Persistent Volume（PV）是一个核心对象，用于抽象和管理集群中的持久化存储资源。本文将深入研究K8s中的Persistent Volume的概念、工作原理，并通过详细的示例演示如何配置和使用Persistent Volume。</p><h2 id="什么是Persistent-Volume？"><a href="#什么是Persistent-Volume？" class="headerlink" title="什么是Persistent Volume？"></a>什么是Persistent Volume？</h2><p>在容器化应用中，Pod的生命周期是短暂的，当Pod终止时，其中的数据通常也会被销毁。为了解决这个问题，Kubernetes引入了Persistent Volume（PV）的概念。PV是集群中的一块持久化存储，它独立于Pod存在，可以被多个Pod共享，并且在Pod终止后仍然保留数据。</p><p>PV允许开发者将数据存储和Pod解耦，提供了一种灵活且可靠的存储解决方案。PV的生命周期与Pod无关，可以手动配置也可以使用动态存储类（StorageClass）来动态创建。<br>Persistent Volume的基本结构</p><p>PV有一些基本的属性和状态，这些属性决定了PV的可用性和使用方式。</p><h3 id="Access-Modes（访问模式）"><a href="#Access-Modes（访问模式）" class="headerlink" title="Access Modes（访问模式）"></a>Access Modes（访问模式）</h3><p>PV支持不同的访问模式，它定义了Pod如何与PV进行交互。主要有以下三种访问模式：</p><ul><li>ReadWriteOnce（RWO）： 读写模式，只能被单个Pod挂载为读写模式。</li><li>ReadOnlyMany（ROX）： 只读模式，可以被多个Pod挂载为只读模式。</li><li>ReadWriteMany（RWX）： 读写模式，可以被多个Pod挂载为读写模式。</li></ul><h3 id="Storage-Class（存储类）"><a href="#Storage-Class（存储类）" class="headerlink" title="Storage Class（存储类）"></a>Storage Class（存储类）</h3><p>Storage Class是一种动态创建PV的机制，它定义了PV的属性，包括存储类型、访问模式等。Storage Class可以根据需求动态地创建PV，使得存储的管理更加灵活。</p><h3 id="Capacity（容量）"><a href="#Capacity（容量）" class="headerlink" title="Capacity（容量）"></a>Capacity（容量）</h3><p>PV的容量定义了可以存储的数据量，以GiB或TiB为单位。Pod可以使用PV上的所有容量，但不会超过PV的限制。</p><h3 id="Reclaim-Policy（回收策略）"><a href="#Reclaim-Policy（回收策略）" class="headerlink" title="Reclaim Policy（回收策略）"></a>Reclaim Policy（回收策略）</h3><p>Reclaim Policy定义了当PV释放后的行为。主要有以下三种策略：</p><ul><li>Retain： 保留，PV的数据会被保留，需要手动清理。</li><li>Recycle： 回收，PV的数据会被清空，重新变为可用状态。</li><li>Delete： 删除，PV的数据会被删除，PV也会被删除。</li></ul><h2 id="Persistent-Volume的使用示例"><a href="#Persistent-Volume的使用示例" class="headerlink" title="Persistent Volume的使用示例"></a>Persistent Volume的使用示例</h2><p>为了更好地理解Persistent Volume的使用，以下是一个详细的示例，涉及PV的手动创建和使用。</p><h3 id="步骤1：创建Persistent-Volume"><a href="#步骤1：创建Persistent-Volume" class="headerlink" title="步骤1：创建Persistent Volume"></a>步骤1：创建Persistent Volume</h3><p>首先，我们创建一个PV，指定其访问模式、容量、回收策略等属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  hostPath:</span><br><span class="line">    path: &quot;/mnt/data&quot;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个1Gi容量的PV，使用了ReadWriteOnce的访问模式，并指定了Retain的回收策略。PV的存储类为manual，表示这是一个手动创建的PV。PV的存储路径为&#x2F;mnt&#x2F;data。</p><h3 id="步骤2：创建Persistent-Volume-Claim"><a href="#步骤2：创建Persistent-Volume-Claim" class="headerlink" title="步骤2：创建Persistent Volume Claim"></a>步骤2：创建Persistent Volume Claim</h3><p>PV只是存储资源的定义，要在Pod中使用这些资源，我们需要创建一个Persistent Volume Claim（PVC）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个PVC，请求1Gi容量，并指定了ReadWriteOnce的访问模式和manual的存储类。</p><h3 id="步骤3：创建Pod"><a href="#步骤3：创建Pod" class="headerlink" title="步骤3：创建Pod"></a>步骤3：创建Pod</h3><p>最后，我们创建一个Pod，并将PVC挂载到Pod的路径中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: my-container</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: my-storage</span><br><span class="line">      mountPath: &quot;/usr/share/nginx/html&quot;</span><br><span class="line">  volumes:</span><br><span class="line">  - name: my-storage</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: my-pvc</span><br></pre></td></tr></table></figure><p>这个Pod使用了Nginx镜像，并将PVC挂载到了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html路径。这样，Pod就能够访问并写入PV中的持久化数据。</p><h3 id="步骤4：验证"><a href="#步骤4：验证" class="headerlink" title="步骤4：验证"></a>步骤4：验证</h3><p>通过访问Pod中挂载的路径，我们可以验证数据是否能够持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it my-pod -- /bin/sh</span><br><span class="line"># 在Pod中执行以下命令</span><br><span class="line">echo &quot;Hello, Persistent Volume!&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>通过访问PV的存储路径，我们也可以验证数据是否持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /mnt/data/index.html</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的详细介绍和示例演示，我们深入了解了Kubernetes中的Persistent Volume。PV作为K8s中持久化存储的抽象，提供了一种灵活、可靠的方式来处理容器中的持久性数据。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的服务发现机制</title>
      <link href="/posts/4a17b525.html"/>
      <url>/posts/4a17b525.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）是一个强大的容器编排平台，提供了丰富的功能来简化容器化应用的管理。其中之一重要的特性就是服务发现机制，它使得应用程序能够在K8s集群中动态地发现和访问其他服务。本文将深入研究K8s中的服务发现机制，探讨其原理、使用方法以及通过详细的示例演示其工作过程。</p><h2 id="什么是服务发现？"><a href="#什么是服务发现？" class="headerlink" title="什么是服务发现？"></a>什么是服务发现？</h2><p>服务发现是指系统中的各个组件如何找到并与彼此通信的过程。在容器编排平台中，服务发现变得尤为重要，因为容器化应用通常包含多个微服务，它们可能会以动态的方式进行扩展或缩减。服务发现机制允许这些微服务相互发现和通信，从而构建了弹性、可伸缩的应用。</p><p>Kubernetes通过一系列核心对象和机制提供了强大的服务发现功能，使得容器能够在集群中自动发现其他服务，而不需要硬编码服务的地址和端口。</p><h2 id="Kubernetes服务发现的核心对象"><a href="#Kubernetes服务发现的核心对象" class="headerlink" title="Kubernetes服务发现的核心对象"></a>Kubernetes服务发现的核心对象</h2><p>在Kubernetes中，服务发现主要通过以下几个核心对象实现：</p><h3 id="Service（服务）"><a href="#Service（服务）" class="headerlink" title="Service（服务）"></a>Service（服务）</h3><p>Service是K8s中用于定义服务的对象，它为一组Pod提供一个稳定的网络入口，通过标签选择器将流量引导到这些Pod。Service的IP地址和端口是稳定的，其他服务可以通过该IP地址和端口访问服务。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: backend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>上述Service定义了一个名为backend-service的服务，选择了标签为app&#x3D;backend的所有Pod，并将流量引导到它们的8080端口。</p><h3 id="Endpoint（终端点）"><a href="#Endpoint（终端点）" class="headerlink" title="Endpoint（终端点）"></a>Endpoint（终端点）</h3><p>Endpoint是Service背后真实运行应用程序的Pod的地址和端口的集合。K8s通过Endpoints对象动态地管理Service的后端Pod。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints backend-service</span><br></pre></td></tr></table></figure><p>上述命令的输出可能如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME             ENDPOINTS                     AGE</span><br><span class="line">backend-service   192.168.1.2:8080,192.168.1.3:8080,192.168.1.4:8080   1h</span><br></pre></td></tr></table></figure><p>Endpoints列表了与backend-service相关联的Pod的IP地址和端口号。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>K8s内置了一个DNS服务，允许在集群内使用域名进行服务发现。Service的名称将映射到DNS中，从而允许其他服务使用该域名来访问服务。例如，在一个Pod中，可以通过backend-service.default.svc.cluster.local来访问上述定义的backend-service。</p><h2 id="Kubernetes服务发现的工作原理"><a href="#Kubernetes服务发现的工作原理" class="headerlink" title="Kubernetes服务发现的工作原理"></a>Kubernetes服务发现的工作原理</h2><p>Kubernetes的服务发现机制工作原理如下：</p><ul><li>Pod注册： 当Pod启动时，它会向K8s API服务器注册自己的IP地址和端口号。</li><li>Service创建： 创建一个Service对象时，K8s会为该服务分配一个Cluster IP，并为其创建一个DNS记录。</li><li>Endpoint更新： K8s通过Label Selector将Service与匹配的Pod关联起来，并更新相应的Endpoints对象。</li><li>DNS解析： 其他Pod可以通过Service名称或Endpoint的DNS记录来解析服务的IP地址。</li></ul><h2 id="示例演示：使用Kubernetes服务发现"><a href="#示例演示：使用Kubernetes服务发现" class="headerlink" title="示例演示：使用Kubernetes服务发现"></a>示例演示：使用Kubernetes服务发现</h2><p>为了演示Kubernetes服务发现的工作过程，我们将创建一个简单的Web应用，包含前端（frontend）和后端（backend）服务。</p><h3 id="步骤1：定义后端服务"><a href="#步骤1：定义后端服务" class="headerlink" title="步骤1：定义后端服务"></a>步骤1：定义后端服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: backend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: backend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api-server</span><br><span class="line">        image: my-backend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: backend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>上述YAML文件定义了一个后端服务，包含3个Pod，它们被标记为app&#x3D;backend。Service对象backend-service将流量引导到这些Pod的8080端口。</p><h3 id="步骤2：定义前端服务"><a href="#步骤2：定义前端服务" class="headerlink" title="步骤2：定义前端服务"></a>步骤2：定义前端服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web-server</span><br><span class="line">        image: my-frontend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: frontend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure><p>上述YAML文件定义了一个前端服务，包含3个Pod，它们被标记为app&#x3D;frontend。Service对象frontend-service将流量引导到这些Pod的80端口。</p><h3 id="步骤3：验证服务发现"><a href="#步骤3：验证服务发现" class="headerlink" title="步骤3：验证服务发现"></a>步骤3：验证服务发现</h3><p>在一个Pod中，我们可以通过Service名称和DNS解析来访问后端服务。例如，我们可以在前端Pod中发起HTTP请求到后端服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl run -i --tty --rm debug --image=alpine --restart=Never -- sh</span><br><span class="line"># 在容器中执行以下命令</span><br><span class="line">apk add curl</span><br><span class="line">curl backend-service.default.svc.cluster.local:8080/api</span><br></pre></td></tr></table></figure><p>这个例子演示了在Kubernetes集群中，前端服务通过DNS解析的方式发现并访问了后端服务。</p><h2 id="Kubernetes服务发现的优势"><a href="#Kubernetes服务发现的优势" class="headerlink" title="Kubernetes服务发现的优势"></a>Kubernetes服务发现的优势</h2><p>Kubernetes服务发现机制带来了多重优势：</p><ul><li>弹性和动态扩展： 服务发现使得新的Pod能够动态地加入或离开服务，而其他服务无需修改配置即可感知这些变化。</li><li>解耦服务： 通过Service对象，服务之间的通信不再依赖于具体的IP地址和端口号，而是通过Service名称和DNS解析进行，提高了服务的解耦性。</li><li>负载均衡： Service对象自动提供了负载均衡，将流量分发到后端Pod。这有助于确保各个Pod能够均匀地处理请求。</li><li>DNS解析： Kubernetes内置了DNS服务，使得在集群内部使用域名进行服务发现变得十分方便。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍和示例演示，我们深入了解了Kubernetes中的服务发现机制。服务发现是构建弹性、可伸缩的容器化应用的基础，Kubernetes通过Service对象、Endpoints对象和内置的DNS解析机制提供了强大的服务发现功能。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象IngressController</title>
      <link href="/posts/4a17b524.html"/>
      <url>/posts/4a17b524.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Kubernetes（K8s）中，Ingress Controller是一个关键的组件，用于实现Ingress对象的规则。Ingress Controller通过读取Ingress对象的规则并将其转化为配置，来管理集群内外部服务的访问。本文将深入研究K8s中Ingress Controller的概念、作用以及使用方法，并通过详细的示例来帮助读者更好地理解。</p><h2 id="什么是Ingress-Controller？"><a href="#什么是Ingress-Controller？" class="headerlink" title="什么是Ingress Controller？"></a>什么是Ingress Controller？</h2><p>Ingress Controller是Kubernetes中的一种控制器，用于处理Ingress对象的规则。Ingress对象定义了外部流量如何到达集群内的服务，而Ingress Controller则负责实际地处理这些规则并在负载均衡器上进行配置，以确保流量按照规定的方式流向服务。</p><p>与传统的负载均衡器不同，Ingress Controller是一个软件组件，它可以在Kubernetes集群中运行，并与K8s API服务器交互以获取Ingress对象的信息。通过Ingress Controller，我们可以实现灵活、动态的路由和负载均衡。</p><h2 id="Ingress-Controller的工作原理"><a href="#Ingress-Controller的工作原理" class="headerlink" title="Ingress Controller的工作原理"></a>Ingress Controller的工作原理</h2><p>Ingress Controller的工作流程如下：</p><ul><li>监听Ingress对象变化： Ingress Controller通过K8s API服务器监听Ingress对象的变化。当新的Ingress对象被创建、更新或删除时，Ingress Controller会感知到这些变化。</li><li>解析Ingress规则： Ingress Controller负责解析Ingress对象中定义的规则，包括主机名、路径、后端服务等信息。</li><li>生成配置： Ingress Controller将解析后的规则转化为特定负载均衡器（如Nginx、Traefik等）可以理解的配置。这个配置包括路由规则、TLS设置等。</li><li>应用配置： Ingress Controller将生成的配置应用于负载均衡器，确保外部流量按照Ingress规则进行转发。</li><li>监控： Ingress Controller持续监控负载均衡器的运行状况，并根据需要更新配置。这使得它可以动态地适应集群中服务的变化。</li></ul><h2 id="Ingress-Controller的常见实现"><a href="#Ingress-Controller的常见实现" class="headerlink" title="Ingress Controller的常见实现"></a>Ingress Controller的常见实现</h2><p>在Kubernetes生态系统中，有多个Ingress Controller的实现可供选择。以下是一些常见的Ingress Controller：</p><ul><li>Nginx Ingress Controller： 基于Nginx的Ingress Controller，通过使用Nginx作为负载均衡器，提供了强大的路由和负载均衡功能。</li><li>Traefik Ingress Controller： Traefik是一款现代化的Ingress Controller，支持自动发现服务和动态配置，同时提供了丰富的特性如HTTP&#x2F;2、WebSocket等。</li><li>HAProxy Ingress Controller： 基于HAProxy的Ingress Controller，为Kubernetes提供了高性能的负载均衡和路由功能。</li><li>Contour Ingress Controller： Contour是一个基于Envoy代理的Ingress Controller，通过Envoy实现高性能的负载均衡和流量管理。</li></ul><h2 id="Ingress-Controller的使用示例"><a href="#Ingress-Controller的使用示例" class="headerlink" title="Ingress Controller的使用示例"></a>Ingress Controller的使用示例</h2><p>为了更好地理解Ingress Controller的使用，我们将以Nginx Ingress Controller为例进行演示。</p><h3 id="步骤1：安装Nginx-Ingress-Controller"><a href="#步骤1：安装Nginx-Ingress-Controller" class="headerlink" title="步骤1：安装Nginx Ingress Controller"></a>步骤1：安装Nginx Ingress Controller</h3><p>首先，通过以下命令安装Nginx Ingress Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure><h3 id="步骤2：创建Ingress对象"><a href="#步骤2：创建Ingress对象" class="headerlink" title="步骤2：创建Ingress对象"></a>步骤2：创建Ingress对象</h3><p>创建一个简单的Ingress对象，定义了将流量引导到后端服务的规则。假设我们有一个前端服务和一个后端服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /frontend</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: frontend-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">      - path: /backend</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: backend-service</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br></pre></td></tr></table></figure><h3 id="步骤3：应用配置"><a href="#步骤3：应用配置" class="headerlink" title="步骤3：应用配置"></a>步骤3：应用配置</h3><p>Nginx Ingress Controller会自动感知到新的Ingress对象，并根据规则更新Nginx的配置。无需手动操作。</p><h3 id="步骤4：验证"><a href="#步骤4：验证" class="headerlink" title="步骤4：验证"></a>步骤4：验证</h3><p>通过访问mydomain.com&#x2F;frontend和mydomain.com&#x2F;backend，验证Ingress规则是否生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Host: mydomain.com&quot; http://&lt;Cluster-IP&gt;/frontend</span><br><span class="line">curl -H &quot;Host: mydomain.com&quot; http://&lt;Cluster-IP&gt;/backend</span><br></pre></td></tr></table></figure><h3 id="步骤5：动态更新"><a href="#步骤5：动态更新" class="headerlink" title="步骤5：动态更新"></a>步骤5：动态更新</h3><p>如果需要修改规则，只需更新Ingress对象即可，Nginx Ingress Controller会自动应用新的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /new-path</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: new-service</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们对K8s中Ingress Controller有了深入的了解。Ingress Controller作为连接Ingress对象和实际负载均衡器的桥梁，通过动态地解析和配置，实现了灵活的服务路由和负载均衡。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Ingress</title>
      <link href="/posts/4a17b523.html"/>
      <url>/posts/4a17b523.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）是一个强大的容器编排平台，为容器化应用提供了丰富的功能和资源管理。在K8s中，Ingress是一个重要的核心对象，它允许我们定义对集群内服务的外部访问规则。本文将深入研究K8s中Ingress的概念、作用以及使用方法，并通过详细的示例来帮助读者更好地理解。</p><h2 id="什么是Kubernetes-Ingress？"><a href="#什么是Kubernetes-Ingress？" class="headerlink" title="什么是Kubernetes Ingress？"></a>什么是Kubernetes Ingress？</h2><p>Ingress是K8s中的一个API对象，用于管理和配置外部对集群内服务的访问。它允许我们定义HTTP和HTTPS路由规则，将请求从集群外部的负载均衡器引导到相应的服务。Ingress的灵活性使得我们能够实现高级的应用程序路由、SSL终端和负载均衡等功能。</p><p>通过Ingress，我们可以将集群内的多个服务暴露到外部，并根据需要进行定制化的路由设置。这为应用的扩展和灵活部署提供了便利。</p><h2 id="Ingress的基本结构"><a href="#Ingress的基本结构" class="headerlink" title="Ingress的基本结构"></a>Ingress的基本结构</h2><p>Ingress由以下几个主要组件构成：</p><ul><li>规则（Rules）： 每个Ingress对象可以包含多个规则，每个规则定义了一组路径匹配规则和与之关联的后端服务。</li><li>后端服务（Backend Services）： 规则中指定的后端服务是Ingress路由请求到达时的目标服务。这可以是集群中的Service、Pod或外部服务。</li><li>路径（Paths）： 路径定义了应该如何将请求路由到后端服务。可以使用通配符和正则表达式进行路径匹配。</li><li>TLS（Transport Layer Security）： Ingress还支持TLS，用于启用HTTPS。TLS配置包括证书和密钥，确保数据在传输过程中的安全性。</li></ul><p>下面是一个简单的Ingress对象的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /app</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: my-app-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - mydomain.com</span><br><span class="line">    secretName: my-tls-secret</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个Ingress对象，它将mydomain.com&#x2F;app的请求路由到名为my-app-service的Service，并启用了HTTPS。</p><h2 id="Ingress的使用示例"><a href="#Ingress的使用示例" class="headerlink" title="Ingress的使用示例"></a>Ingress的使用示例</h2><p>为了更好地理解Ingress的使用，让我们通过一个具体的示例来演示。</p><p>假设我们有一个Web应用，包括前端（frontend）和后端（backend）服务。现在，我们希望通过Ingress将这两个服务暴露到外部，并在路径上进行定制化的路由。</p><p>首先，我们创建前端和后端的Deployment和Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web-server</span><br><span class="line">        image: my-frontend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: frontend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">yamlapiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: backend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: backend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api-server</span><br><span class="line">        image: my-backend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: backend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>接下来，我们定义Ingress对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /frontend</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: frontend-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">      - path: /backend</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: backend-service</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - mydomain.com</span><br><span class="line">    secretName: my-tls-secret</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个Ingress对象，它将mydomain.com&#x2F;frontend的请求路由到前端服务，将mydomain.com&#x2F;backend的请求路由到后端服务。此外，我们还启用了HTTPS，并指定了TLS证书的Secret。</p><h2 id="动态更新Ingress规则"><a href="#动态更新Ingress规则" class="headerlink" title="动态更新Ingress规则"></a>动态更新Ingress规则</h2><p>Ingress的一个强大之处在于它支持动态更新。当我们需要调整路由规则时，可以直接修改Ingress对象，而不需要重启应用或重新创建服务。</p><p>让我们通过一个动态更新的例子来演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /frontend</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: frontend-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - mydomain.com</span><br><span class="line">    secretName: my-tls-secret</span><br></pre></td></tr></table></figure><p>在这个例子中，我们仅保留了前端服务的路由规则。然后，通过应用这个更新后的Ingress对象，K8s将自动更新负载均衡器的配置，使得只有mydomain.com&#x2F;frontend的请求能够到达前端服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们对K8s中的Ingress有了深入的了解。Ingress作为连接集群内服务和外部请求的桥梁，提供了灵活的路由和负载均衡功能。了解Ingress的基本结构、使用示例以及动态更新的能力，有助于开发者更好地利用K8s进行应用程序的外部暴露和访问控制。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Endpoint</title>
      <link href="/posts/4a17b522.html"/>
      <url>/posts/4a17b522.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Kubernetes（K8s）中，Endpoint是一个关键的核心对象，它承担着连接Service和后端Pod的重要角色。Endpoint提供了对服务后端的抽象，允许我们在集群中动态地管理服务的网络终端。本文将深入研究K8s中Endpoint的概念、作用以及使用方法，并通过详细的示例来帮助读者更好地理解。</p><h2 id="什么是Kubernetes-Endpoint？"><a href="#什么是Kubernetes-Endpoint？" class="headerlink" title="什么是Kubernetes Endpoint？"></a>什么是Kubernetes Endpoint？</h2><p>Endpoint代表了Service后端的一组IP地址和端口号，用于将流量从Service引导到实际运行应用程序的Pod。每个Service都关联着一个对应的Endpoint，这个Endpoint动态地维护了所有Service所选择的Pod的网络终端信息。</p><p>简而言之，Endpoint是Service的一种实现，是Service背后真实运行的Pod的地址和端口的集合。通过Endpoint，K8s可以实现服务的动态发现和负载均衡。</p><h2 id="Endpoint的结构"><a href="#Endpoint的结构" class="headerlink" title="Endpoint的结构"></a>Endpoint的结构</h2><p>Endpoint主要由以下几个部分组成：</p><ul><li>IP地址： 指定Pod的IP地址，用于标识网络上的唯一位置。</li><li>端口号： 指定Pod中运行应用程序的端口，用于标识应用程序的通信端口。</li></ul><p>一个Endpoint可以包含多个IP地址和端口号的组合，这取决于与Service相关联的Pod的数量。Endpoint的结构使得它能够适应不同Service的需求，实现对多个Pod的动态管理。</p><h2 id="Endpoint与Service的关系"><a href="#Endpoint与Service的关系" class="headerlink" title="Endpoint与Service的关系"></a>Endpoint与Service的关系</h2><p>在K8s中，每个Service都有一个相应的Endpoint。当Service被创建时，K8s会自动创建对应的Endpoint，并将Service选择的Pod的IP地址和端口号添加到Endpoint中。这种关系保证了Service与Pod之间的正确通信。</p><p>在Service和Endpoint之间的关系中，Service充当了一种抽象，为应用程序提供了一个稳定的入口点，而Endpoint则提供了Service后端的真实网络终端。这种分离使得我们能够更加灵活地管理和维护后端Pod的变化，而不需要改变Service的定义。</p><h2 id="Endpoint的使用"><a href="#Endpoint的使用" class="headerlink" title="Endpoint的使用"></a>Endpoint的使用</h2><p>为了更好地理解Endpoint的使用，让我们通过一个具体的示例来演示。</p><p>假设我们有一个简单的Web应用，由多个前端（frontend）和后端（backend）Pod组成。前端提供Web页面，后端处理业务逻辑。我们已经创建了一个名为web-service的Service，现在让我们看看与之关联的Endpoint。</p><p>首先，我们查看web-service的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: frontend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>这个Service选择了标签为app&#x3D;frontend的所有Pod，并将流量引导到它们的80端口。现在，我们来查看与之关联的Endpoint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints web-service</span><br></pre></td></tr></table></figure><p>上述命令的输出可能如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME          ENDPOINTS                     AGE</span><br><span class="line">web-service   192.168.1.2:8080,192.168.1.3:8080,192.168.1.4:8080   1h</span><br></pre></td></tr></table></figure><p>在这个示例中，web-service的Endpoint列举了所有与该Service相关联的Pod的IP地址和端口号。这样，K8s就能够动态地将流量引导到这些具体的Pod，实现负载均衡和服务发现。</p><h2 id="动态管理Endpoint"><a href="#动态管理Endpoint" class="headerlink" title="动态管理Endpoint"></a>动态管理Endpoint</h2><p>在K8s中，Endpoint的管理是动态的。当Service的相关Pod发生变化时，Endpoint会相应地更新。例如，当我们扩展了前端Pod的数量时，Endpoint会自动添加新的IP地址和端口号。</p><p>让我们通过一个扩展Pod数量的例子来演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment frontend --replicas=5</span><br></pre></td></tr></table></figure><p>然后，我们再次查看web-service的Endpoint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">kubectl get endpoints web-service</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME          ENDPOINTS                     AGE</span><br><span class="line">web-service   192.168.1.2:8080,192.168.1.3:8080,192.168.1.4:8080,192.168.1.5:8080,192.168.1.6:8080   5m</span><br></pre></td></tr></table></figure><p>在这个例子中，我们扩展了前端Pod的数量，Endpoint相应地添加了新的IP地址和端口号，确保了与Service相关联的所有Pod都能够被正确地服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们对K8s中的Endpoint有了深入的了解。Endpoint作为连接Service和Pod的关键组件，通过动态地管理Pod的IP地址和端口号，实现了服务的负载均衡和发现。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Service</title>
      <link href="/posts/4a17b521.html"/>
      <url>/posts/4a17b521.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着云原生技术的飞速发展，Kubernetes（简称K8s）已经成为容器编排和管理的事实标准。在K8s中，有许多核心对象，而其中之一就是Service（服务）。Service在K8s中扮演着非常重要的角色，它允许我们将应用程序的不同部分连接在一起，提供可靠的网络访问。本文将深入探讨K8s中Service的概念、作用以及使用方法，并提供详细的示例帮助读者更好地理解。</p><h2 id="什么是Kubernetes-Service？"><a href="#什么是Kubernetes-Service？" class="headerlink" title="什么是Kubernetes Service？"></a>什么是Kubernetes Service？</h2><p>Service是K8s中的一种抽象，它定义了一组Pod的逻辑集合，并为这组Pod提供一个稳定的访问点（Endpoint）。这个访问点可以是一个固定的虚拟IP地址或者一个DNS名称，通过这个访问点，其他的应用或服务可以方便地访问到这组Pod，实现服务发现和负载均衡。</p><p>在K8s中，Pod是最小的可部署单元，而Service则提供了对这些Pod的抽象。使用Service，我们可以将后端Pod组织成一个逻辑单元，而不用担心它们的具体部署细节。这种抽象使得我们可以更加灵活地进行应用的扩展和维护。</p><h2 id="Service的类型"><a href="#Service的类型" class="headerlink" title="Service的类型"></a>Service的类型</h2><p>K8s中的Service有四种类型，分别是ClusterIP、NodePort、LoadBalancer和ExternalName。接下来，我们将详细介绍每种类型的Service以及它们的用途。</p><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><p>ClusterIP是最常用的Service类型之一，它为Pod提供了一个集群内部的虚拟IP地址。这意味着只有集群内部的其他服务可以通过该IP地址访问到这个Service。ClusterIP适用于那些只需要在集群内部访问的服务，例如数据库服务或内部API。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: my-app</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为my-service的ClusterIP Service。它选择了所有标签为app&#x3D;my-app的Pod，并将流量引导到这些Pod的端口80。</p><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>NodePort类型的Service会在每个节点上都暴露一个相同的端口，允许外部流量通过该端口访问Service。NodePort常用于需要从集群外部访问的服务，但不适用于生产环境，因为它暴露的端口范围相对较窄。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-nodeport-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: my-app</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  type: NodePort</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子中，我们创建了一个名为my-nodeport-service的NodePort Service，通过节点上的某个端口（例如30000）可以访问到标签为app&#x3D;my-app的Pod。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>LoadBalancer类型的Service使用云服务提供商的负载均衡器（Load Balancer），将外部流量分发到集群中的Pod。这是一种适用于生产环境的Service类型，可以自动处理负载均衡。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-lb-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: my-app</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  type: LoadBalancer</span><br></pre></td></tr></table></figure><p>在这个例子中，K8s将使用云服务提供商的负载均衡器来将流量引导到标签为app&#x3D;my-app的Pod。</p><h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><p>ExternalName类型的Service允许将K8s Service映射到集群外部的服务，通过这种方式，我们可以使用K8s的Service发现机制来访问外部服务。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-external-service</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: external-service.example.com</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个名为my-external-service的ExternalName Service，它将所有流量重定向到external-service.example.com。</p><h2 id="Service的实践"><a href="#Service的实践" class="headerlink" title="Service的实践"></a>Service的实践</h2><p>了解了Service的基本概念和类型后，让我们通过一个实际的案例来演示如何在K8s中使用Service。</p><p>假设我们有一个简单的Web应用，由多个前端（frontend）和后端（backend）Pod组成。前端提供Web页面，后端处理业务逻辑。我们希望通过一个ClusterIP类型的Service来将前端和后端连接起来。</p><p>首先，我们定义前端和后端的Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web-server</span><br><span class="line">        image: my-frontend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: backend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: backend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: backend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api-server</span><br><span class="line">        image: my-backend-image:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个ClusterIP类型的Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: frontend</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure><p>这个Service选择了标签为app&#x3D;frontend的所有Pod，并将流量引导到它们的80端口。现在，其他的应用或服务只需要通过访问web-service的ClusterIP，就可以与前端Pod通信。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们对K8s中的Service有了深入的了解。Service作为Kubernetes的核心对象之一，为应用程序提供了稳定的访问点，支持服务发现和负载均衡。不同类型的Service适用于不同的使用场景，开发者可以根据需求选择合适的类型。在实践中，通过定义Service，我们可以将后端Pod组织成逻辑单元，实现了更高层次的抽象和灵活的应用部署。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象secret</title>
      <link href="/posts/4a17b520.html"/>
      <url>/posts/4a17b520.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（简称K8s）是一款开源的容器编排系统，被广泛应用于容器化应用的管理和部署。在Kubernetes中，有许多核心对象用于定义、管理和运行容器化应用。其中之一就是Secret（密钥、密码、令牌等的安全对象）。本文将深入探讨Kubernetes中的Secret对象，包括其概念、用途、创建、管理等方面，通过详细的示例演示，使读者更好地理解和应用这一核心对象。</p><h2 id="什么是Secret？"><a href="#什么是Secret？" class="headerlink" title="什么是Secret？"></a>什么是Secret？</h2><p>在Kubernetes中，Secret是一种用于存储敏感信息的对象，如密码、令牌、密钥等。它主要用于将这些敏感信息以安全的方式传递给Pod中的容器。Secret对象通常包含Base64编码的数据，以确保在Kubernetes中的传输过程中保持安全性。</p><p>Secret的作用主要体现在以下几个方面：</p><ul><li>安全存储敏感信息：将密码、令牌等敏感信息存储在Secret对象中，避免明文存储，提高安全性。</li><li>传递给Pod中的容器：通过挂载Secret到Pod中，容器可以读取其中的敏感信息，实现应用程序的安全配置。</li><li>用于TLS证书：Secret可用于存储TLS证书和密钥，用于加密Pod之间的通信。</li><li>与Volume一同使用：可以将Secret与Volume结合使用，将敏感信息以文件的形式提供给Pod。</li></ul><h2 id="Secret的类型"><a href="#Secret的类型" class="headerlink" title="Secret的类型"></a>Secret的类型</h2><p>在Kubernetes中，有多种类型的Secret，每种类型都适用于不同的场景。以下是常见的几种Secret类型：</p><ul><li>Opaque（不透明）Secret：用于存储任意类型的数据，不限于字符串。最常用于存储密码、密钥等。</li><li>Docker Registry Secret：用于存储访问私有Docker Registry所需的认证信息。</li><li>Service Account Token Secret：由Kubernetes自动生成，用于向Pod中的Service Account提供API访问令牌。</li><li>TLS Secret：用于存储TLS证书和私钥，用于加密Pod之间的通信。</li></ul><p>在接下来的内容中，我们将以不透明Secret为例，详细介绍其创建、使用和管理。</p><h2 id="创建Opaque-Secret"><a href="#创建Opaque-Secret" class="headerlink" title="创建Opaque Secret"></a>创建Opaque Secret</h2><p>要创建Opaque Secret，我们需要提前准备好敏感信息，并以Base64编码的形式存储在Secret对象中。下面是一个创建Opaque Secret的示例YAML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: my-secret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: dXNlcm5hbWU=  # Base64编码后的用户名</span><br><span class="line">  password: cGFzc3dvcmQ=  # Base64编码后的密码</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为my-secret的Opaque Secret，其中包含了用户名和密码的Base64编码值。创建Secret后，我们可以通过kubectl将其应用到Kubernetes集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f my-secret.yaml</span><br></pre></td></tr></table></figure><h2 id="在Pod中使用Secret"><a href="#在Pod中使用Secret" class="headerlink" title="在Pod中使用Secret"></a>在Pod中使用Secret</h2><p>创建好Secret后，我们可以将其挂载到Pod中，并通过环境变量或者Volume的方式传递给容器。以下是一个使用Secret的Pod示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: mycontainer</span><br><span class="line">      image: myimage</span><br><span class="line">      env:</span><br><span class="line">        - name: MY_USERNAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: my-secret</span><br><span class="line">              key: username</span><br><span class="line">        - name: MY_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: my-secret</span><br><span class="line">              key: password</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个Pod，并在容器中通过环境变量的方式使用了my-secret中的用户名和密码。这样，容器就能够安全地访问这些敏感信息，而不需要将其硬编码到容器镜像中。</p><h2 id="使用Secret实现TLS加密"><a href="#使用Secret实现TLS加密" class="headerlink" title="使用Secret实现TLS加密"></a>使用Secret实现TLS加密</h2><p>除了存储用户名和密码，Secret还可以用于存储TLS证书和私钥，实现Pod之间的加密通信。以下是一个使用Secret实现TLS加密的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: tls-secret</span><br><span class="line">type: kubernetes.io/tls</span><br><span class="line">data:</span><br><span class="line">  tls.crt: base64-encoded-certificate  # Base64编码后的证书</span><br><span class="line">  tls.key: base64-encoded-private-key  # Base64编码后的私钥</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个类型为kubernetes.io&#x2F;tls的Secret，其中包含了Base64编码的TLS证书和私钥。接下来，我们可以在Pod的配置中引用这个Secret，并使用TLS加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod-tls</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: mycontainer</span><br><span class="line">      image: myimage</span><br><span class="line">  volumes:</span><br><span class="line">    - name: tls-volume</span><br><span class="line">      secret:</span><br><span class="line">        secretName: tls-secret</span><br><span class="line">  volumeMounts:</span><br><span class="line">    - name: tls-volume</span><br><span class="line">      mountPath: &quot;/etc/tls&quot;</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个Pod，并将tls-secret挂载为一个Volume。容器可以通过&#x2F;etc&#x2F;tls路径访问证书和私钥，从而实现TLS加密通信。</p><h2 id="Secret的更新和管理"><a href="#Secret的更新和管理" class="headerlink" title="Secret的更新和管理"></a>Secret的更新和管理</h2><p>Secret在创建后，可能需要进行更新或者删除。在更新Secret时，我们可以通过kubectl命令行工具或者YAML文件进行修改。以下是一个更新Secret的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic my-secret --from-literal=username=newuser --dry-run=client -o yaml | kubectl apply -f -</span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过kubectl命令行工具，从命令行直接指定新的用户名，并将其更新到my-secret中。需要注意的是，这里使用了–dry-run&#x3D;client参数，表示只在本地生成YAML文件而不真正应用更改，以便我们可以在确认无误后再应用更改。</p><p>当我们需要删除一个Secret时，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete secret my-secret</span><br></pre></td></tr></table></figure><p>这将从集群中删除名为my-secret的Secret对象。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文的详细解析和示例演示，我们深入了解了Kubernetes中Secret对象的概念、类型、创建、使用和管理。Secret作为Kubernetes中的核心对象之一，在容器化应用的安全管理中扮演着重要的角色。通过合理使用Secret，我们能够更好地保护敏感信息，确保应用程序的安全性和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象configmap</title>
      <link href="/posts/4a17b519.html"/>
      <url>/posts/4a17b519.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（简称K8s）是当今最流行的容器编排系统之一，用于管理和编排容器化应用程序。在Kubernetes中，ConfigMap是一个核心对象，用于将配置数据与应用程序分离，提高应用的可移植性和可维护性。本文将深入探讨ConfigMap的概念、用途以及通过详细的示例演示如何使用ConfigMap。</p><h2 id="什么是ConfigMap？"><a href="#什么是ConfigMap？" class="headerlink" title="什么是ConfigMap？"></a>什么是ConfigMap？</h2><p>ConfigMap是Kubernetes中的一种资源对象，用于存储非机密性的配置数据，例如键值对、配置文件等。通过将配置数据与应用程序分离，ConfigMap提供了一种解耦的方式，使得应用程序可以更灵活、可配置，并且能够适应不同环境的变化。</p><p>ConfigMap主要包含以下几个要素：</p><ul><li>名称（Name）： ConfigMap的唯一标识符。</li><li>数据（Data）： 存储配置数据的地方，以键值对的形式存在。</li><li>用途（Purpose）： 用于将配置数据注入到Pod中，以供应用程序使用。</li></ul><p>下面通过详细的示例演示ConfigMap的创建和使用。</p><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><h3 id="步骤1：创建ConfigMap"><a href="#步骤1：创建ConfigMap" class="headerlink" title="步骤1：创建ConfigMap"></a>步骤1：创建ConfigMap</h3><p>首先，我们将创建一个简单的ConfigMap，其中包含一些常见的配置数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: my-configmap</span><br><span class="line">data:</span><br><span class="line">  DATABASE_URL: &quot;mysql://username:password@localhost:3306/mydatabase&quot;</span><br><span class="line">  API_KEY: &quot;your_api_key_here&quot;</span><br><span class="line">  LOG_LEVEL: &quot;info&quot;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为my-configmap的ConfigMap，其中包含了数据库连接URL、API密钥和日志级别等配置信息。</p><h3 id="步骤2：在Pod中使用ConfigMap"><a href="#步骤2：在Pod中使用ConfigMap" class="headerlink" title="步骤2：在Pod中使用ConfigMap"></a>步骤2：在Pod中使用ConfigMap</h3><p>接下来，我们将创建一个Pod，并在Pod中使用上面定义的ConfigMap。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: my-container</span><br><span class="line">    image: your-container-image:latest</span><br><span class="line">    envFrom:</span><br><span class="line">    - configMapRef:</span><br><span class="line">        name: my-configmap</span><br></pre></td></tr></table></figure><p>在上述例子中，我们创建了一个Pod，其中的容器引用了my-configmap中定义的配置数据。通过envFrom字段，我们可以将ConfigMap中的键值对注入到Pod的环境变量中，使得应用程序能够方便地读取这些配置信息。</p><h3 id="步骤3：应用变更并验证"><a href="#步骤3：应用变更并验证" class="headerlink" title="步骤3：应用变更并验证"></a>步骤3：应用变更并验证</h3><p>现在，我们可以应用上述定义文件，并验证Pod是否成功获取了ConfigMap中的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f your-configmap-definition.yaml</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl logs my-pod</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看Pod的状态以及日志。确保Pod成功启动，并且能够正确读取ConfigMap中的配置数据。</p><h2 id="高级用法：从文件中创建ConfigMap"><a href="#高级用法：从文件中创建ConfigMap" class="headerlink" title="高级用法：从文件中创建ConfigMap"></a>高级用法：从文件中创建ConfigMap</h2><p>除了直接在YAML文件中定义ConfigMap外，Kubernetes还支持从文件或目录创建ConfigMap。这在需要大量配置文件时非常有用。</p><h3 id="步骤4：从文件创建ConfigMap"><a href="#步骤4：从文件创建ConfigMap" class="headerlink" title="步骤4：从文件创建ConfigMap"></a>步骤4：从文件创建ConfigMap</h3><p>假设我们有一个目录config-files，其中包含了多个配置文件，我们可以使用以下命令将这个目录创建为一个ConfigMap。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap my-configmap-files --from-file=config-files/</span><br></pre></td></tr></table></figure><h3 id="步骤5：在Pod中使用文件类型的ConfigMap"><a href="#步骤5：在Pod中使用文件类型的ConfigMap" class="headerlink" title="步骤5：在Pod中使用文件类型的ConfigMap"></a>步骤5：在Pod中使用文件类型的ConfigMap</h3><p>然后，我们可以在Pod中使用这个文件类型的ConfigMap，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod-files</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: my-container-files</span><br><span class="line">    image: your-container-image:latest</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: config-volume</span><br><span class="line">      mountPath: /etc/config</span><br><span class="line">  volumes:</span><br><span class="line">  - name: config-volume</span><br><span class="line">    configMap:</span><br><span class="line">      name: my-configmap-files</span><br></pre></td></tr></table></figure><p>在上述例子中，我们将my-configmap-files挂载到Pod中，使得Pod中的&#x2F;etc&#x2F;config目录包含了config-files目录中的所有文件。</p><p>通过上述示例，我们展示了ConfigMap的基本用法以及如何从文件中创建ConfigMap，使得Kubernetes中的应用程序可以更灵活地处理配置数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文，我们深入了解了Kubernetes中的ConfigMap对象，学习了如何创建和使用ConfigMap，并通过详细的示例演示了基本用法以及从文件中创建ConfigMap的高级用法。ConfigMap是Kubernetes中非常重要的资源之一，它使得应用程序的配置管理变得更加灵活和可维护。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象CronJob</title>
      <link href="/posts/4a17b518.html"/>
      <url>/posts/4a17b518.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（简称K8s）是一种用于自动部署、扩展和管理容器化应用程序的开源平台。在Kubernetes中，有许多核心对象用于定义、管理和协调容器化应用程序的运行。其中，CronJob是一种强大的对象，用于在集群中定期运行任务。本文将深入探讨CronJob的概念、使用方法以及详细示例。</p><h2 id="什么是CronJob？"><a href="#什么是CronJob？" class="headerlink" title="什么是CronJob？"></a>什么是CronJob？</h2><p>CronJob是Kubernetes中的一个核心对象，用于定期执行任务。它基于类似于Unix系统中的cron表达式的时间表来指定任务的运行时间。CronJob确保在指定的时间间隔内运行容器化的工作负载，以执行特定的任务。这对于需要定期执行的清理、备份、数据同步等任务非常有用。</p><p>CronJob对象的主要组成部分包括：</p><ul><li>schedule（计划）： 一个cron表达式，用于指定任务何时运行。</li><li>jobTemplate： 定义了要运行的任务的模板。</li><li>concurrencyPolicy： 定义当上一次任务还在运行时如何处理新的任务。</li><li>suspend： 用于暂停或恢复CronJob的执行。</li></ul><p>接下来，我们将通过详细的示例演示如何创建和使用CronJob。</p><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><h3 id="步骤1：创建CronJob"><a href="#步骤1：创建CronJob" class="headerlink" title="步骤1：创建CronJob"></a>步骤1：创建CronJob</h3><p>首先，我们将创建一个简单的CronJob，该任务将在每天的固定时间执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: daily-job</span><br><span class="line">spec:</span><br><span class="line">  schedule: &quot;0 1 * * *&quot;</span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: daily-job-container</span><br><span class="line">            image: your-daily-job-image:latest</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为daily-job的CronJob，它的schedule为每天的凌晨1点。该CronJob使用一个名为daily-job-container的容器，其中的image字段指定了要运行的容器镜像。</p><h3 id="步骤2：定义任务模板"><a href="#步骤2：定义任务模板" class="headerlink" title="步骤2：定义任务模板"></a>步骤2：定义任务模板</h3><p>接下来，我们需要定义实际执行的任务。在这个示例中，我们将简单地输出一条日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: daily-job-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: daily-job-container</span><br><span class="line">    image: your-daily-job-image:latest</span><br><span class="line">    command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo &#x27;Running daily job&#x27;&quot;]</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个Pod，其中包含一个名为daily-job-container的容器，该容器执行了一个简单的shell命令，输出一条日志。</p><h3 id="步骤3：部署CronJob"><a href="#步骤3：部署CronJob" class="headerlink" title="步骤3：部署CronJob"></a>步骤3：部署CronJob</h3><p>现在，我们可以使用kubectl命令部署我们的CronJob。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f your-cronjob-definition.yaml</span><br></pre></td></tr></table></figure><p>这将在Kubernetes集群中创建并启动名为daily-job的CronJob。</p><h3 id="步骤4：监视CronJob的执行"><a href="#步骤4：监视CronJob的执行" class="headerlink" title="步骤4：监视CronJob的执行"></a>步骤4：监视CronJob的执行</h3><p>我们可以使用以下命令来监视CronJob的执行情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cronjob</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看CronJob的当前状态以及与其关联的Pods。如果一切正常，您应该能够看到定期运行的Pod。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文，我们深入了解了Kubernetes中的CronJob对象，学习了如何创建和部署CronJob，并演示了一个简单的定期任务的实现。CronJob是Kubernetes中非常实用的功能之一，可用于执行各种定期任务，从而简化了系统管理和维护的工作。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Job</title>
      <link href="/posts/4a17b517.html"/>
      <url>/posts/4a17b517.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）作为领先的容器编排平台，提供了多种核心对象来简化和自动化容器化应用的管理。其中，Job是一个关键的概念，用于在集群中运行独立的任务，并确保任务成功完成。本文将深入研究Job的基本概念、使用场景以及提供详细的示例，以帮助读者更好地理解和应用这一核心对象。</p><h2 id="Job的基本概念"><a href="#Job的基本概念" class="headerlink" title="Job的基本概念"></a>Job的基本概念</h2><h3 id="什么是Job？"><a href="#什么是Job？" class="headerlink" title="什么是Job？"></a>什么是Job？</h3><p>Job是Kubernetes中的一个核心概念，用于在集群中运行独立的任务。与其他控制器（如ReplicaSet和Deployment）不同，Job关注的是执行一次性任务而不是保持指定数量的实例运行。</p><h3 id="Job的主要作用"><a href="#Job的主要作用" class="headerlink" title="Job的主要作用"></a>Job的主要作用</h3><ul><li>独立任务执行：Job确保在集群中运行独立的任务，并在任务成功完成后自动终止。</li><li>任务的重试：Job支持定义任务的重试策略，以应对任务执行失败的情况。</li><li>并行任务：Job允许定义多个并行执行的任务，以提高任务执行效率。</li></ul><h2 id="Job的详细示例"><a href="#Job的详细示例" class="headerlink" title="Job的详细示例"></a>Job的详细示例</h2><p>为了更好地理解和应用Job，我们将通过一个详细的示例来演示Job的创建、任务执行以及重试等功能。</p><h3 id="示例：运行批量处理任务的Job"><a href="#示例：运行批量处理任务的Job" class="headerlink" title="示例：运行批量处理任务的Job"></a>示例：运行批量处理任务的Job</h3><p>考虑一个场景，我们希望运行一个批量处理任务，该任务需要对数据进行处理并生成报告。我们将使用Job来完成这项任务。</p><h3 id="Job的定义"><a href="#Job的定义" class="headerlink" title="Job的定义"></a>Job的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-processing</span><br><span class="line">spec:</span><br><span class="line">  completions: 1</span><br><span class="line">  parallelism: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: batch-processing-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: data-processor</span><br><span class="line">        image: data-processor:latest</span><br><span class="line">  backoffLimit: 2</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li>completions: 1 指定了希望完成的任务次数，这里设置为1表示任务成功完成一次即终止。</li><li>parallelism: 3 指定了同时执行的任务数量，这里设置为3表示允许并行执行3个任务。</li><li>template 定义了Job中运行的Pod的规范，包括使用的镜像、标签等。</li><li>backoffLimit: 2 指定了任务的重试次数，当任务执行失败时将尝试最多2次。</li></ul><h3 id="创建Job"><a href="#创建Job" class="headerlink" title="创建Job"></a>创建Job</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f batch-processing-job.yaml</span><br></pre></td></tr></table></figure><p>以上命令将根据定义的Job创建一个批量处理任务，并开始运行。</p><h3 id="查看Job状态"><a href="#查看Job状态" class="headerlink" title="查看Job状态"></a>查看Job状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get jobs</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看Job和Pod的状态，确保批量处理任务已成功执行。</p><h3 id="查看任务执行日志"><a href="#查看任务执行日志" class="headerlink" title="查看任务执行日志"></a>查看任务执行日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看任务执行的日志，确保任务的处理逻辑和结果符合预期。</p><h3 id="任务的重试"><a href="#任务的重试" class="headerlink" title="任务的重试"></a>任务的重试</h3><p>如果任务在第一次执行时失败，Job将尝试重试，最多重试2次（根据backoffLimit的设置）。</p><h3 id="Job的最佳实践"><a href="#Job的最佳实践" class="headerlink" title="Job的最佳实践"></a>Job的最佳实践</h3><ul><li>谨慎设置completions和parallelism：根据任务的特性，合理设置completions和parallelism，确保任务能够在合适的并行度和次数下成功完成。</li><li>定义合理的重试策略：根据任务的稳定性和执行环境，设置合理的backoffLimit，确保任务在失败时有一定的重试机制。</li><li>日志记录和监控：在任务中添加适当的日志记录，以便后续查看任务执行情况。同时，通过监控系统监视Job和任务的状态。</li><li>考虑持久化存储：如果任务需要处理或生成大量数据，考虑使用持久化存储，以防止数据丢失。</li><li>备份和恢复策略：根据任务的重要性，考虑实施备份和恢复策略，以防止任务执行失败导致的数据丢失或服务中断。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Job作为Kubernetes的核心对象之一，为在集群中运行独立任务提供了便捷的方式。通过声明式的定义，Job能够确保任务在集群中成功完成，并提供了灵活的配置选项以满足不同任务的需求。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象DaemonSet</title>
      <link href="/posts/4a17b516.html"/>
      <url>/posts/4a17b516.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）作为一个领先的容器编排平台，提供了多种核心对象来简化和自动化容器化应用的管理。其中，DaemonSet是一个重要的概念，用于确保集群中的每个节点上都运行一个副本的Pod实例。本文将深入探讨DaemonSet的基本概念、使用场景以及提供详细的示例，以帮助读者更好地理解和应用这一核心对象。</p><h2 id="DaemonSet的基本概念"><a href="#DaemonSet的基本概念" class="headerlink" title="DaemonSet的基本概念"></a>DaemonSet的基本概念</h2><h3 id="什么是DaemonSet？"><a href="#什么是DaemonSet？" class="headerlink" title="什么是DaemonSet？"></a>什么是DaemonSet？</h3><p>DaemonSet是Kubernetes中的一个核心对象，用于确保在集群的每个节点上都运行一个或多个Pod的副本。与其他控制器（如ReplicaSet和Deployment）不同，DaemonSet主要用于在整个集群中的节点上运行系统级别的任务，如日志收集、监控代理等。</p><h3 id="DaemonSet的主要作用"><a href="#DaemonSet的主要作用" class="headerlink" title="DaemonSet的主要作用"></a>DaemonSet的主要作用</h3><ul><li>节点级别任务的部署：DaemonSet确保在每个节点上运行一个或多个Pod的副本，用于执行节点级别的任务。</li><li>自动扩展：当新的节点加入集群时，DaemonSet会自动在新节点上启动Pod实例，确保集群中每个节点都有一个或多个Pod的副本。</li><li>系统服务的运行：DaemonSet常用于运行集群中的系统服务，如日志收集、监控代理等。</li></ul><h2 id="DaemonSet的详细示例"><a href="#DaemonSet的详细示例" class="headerlink" title="DaemonSet的详细示例"></a>DaemonSet的详细示例</h2><p>为了更好地理解和应用DaemonSet，我们将通过一个详细的示例来演示DaemonSet的创建、自动扩展以及节点级别任务的运行。</p><h3 id="示例：运行Fluentd日志收集器的DaemonSet"><a href="#示例：运行Fluentd日志收集器的DaemonSet" class="headerlink" title="示例：运行Fluentd日志收集器的DaemonSet"></a>示例：运行Fluentd日志收集器的DaemonSet</h3><p>考虑一个场景，我们希望在Kubernetes集群的每个节点上运行Fluentd日志收集器，以收集各个节点的容器日志。</p><h3 id="DaemonSet的定义"><a href="#DaemonSet的定义" class="headerlink" title="DaemonSet的定义"></a>DaemonSet的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: fluentd-daemonset</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: fluentd</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: fluentd</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: fluentd-container</span><br><span class="line">        image: fluent/fluentd:latest</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: varlog</span><br><span class="line">          mountPath: /var/log</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">  updateStrategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: fluentd</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: fluentd-container</span><br><span class="line">        image: fluent/fluentd:latest</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: varlog</span><br><span class="line">          mountPath: /var/log</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">  updateStrategy:</span><br><span class="line">    type: RollingUpdate</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li>selector 使用标签选择器选择具有标签 app: fluentd 的节点，以运行DaemonSet中定义的Pod。</li><li>template 定义了创建Pod的规范，包括使用的镜像、标签等。</li><li>volumeMounts 将节点的&#x2F;var&#x2F;log目录挂载到Fluentd容器中，以收集节点的容器日志。</li><li>tolerations 允许DaemonSet在Master节点上运行，这对于一些特殊的集群配置是必要的。</li></ul><h3 id="创建DaemonSet"><a href="#创建DaemonSet" class="headerlink" title="创建DaemonSet"></a>创建DaemonSet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f fluentd-daemonset.yaml</span><br></pre></td></tr></table></figure><p>以上命令将根据定义的DaemonSet在集群的每个节点上启动Fluentd的Pod实例。</p><h3 id="查看DaemonSet状态"><a href="#查看DaemonSet状态" class="headerlink" title="查看DaemonSet状态"></a>查看DaemonSet状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get daemonsets</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看DaemonSet和Pod的状态，确保Fluentd的Pod实例已成功运行。</p><h3 id="自动扩展"><a href="#自动扩展" class="headerlink" title="自动扩展"></a>自动扩展</h3><p>当新的节点加入集群时，DaemonSet会自动在新节点上启动Fluentd的Pod实例，确保每个节点都有一个Fluentd的副本。</p><h3 id="DaemonSet的最佳实践"><a href="#DaemonSet的最佳实践" class="headerlink" title="DaemonSet的最佳实践"></a>DaemonSet的最佳实践</h3><ul><li>谨慎使用tolerations：在使用tolerations时，要注意不要过度使用，确保DaemonSet能够在需要的节点上正常运行。</li><li>合理设置Pod规范：根据具体任务的需求，合理设置DaemonSet中Pod的规范，包括镜像、标签、卷挂载等。</li><li>监控和报警：通过监控DaemonSet和相关的Pod状态，设置相应的报警机制，可以及时发现并解决潜在的问题，确保系统的稳定性。</li><li>考虑持久化存储：在一些场景下，DaemonSet可能需要使用持久化存储来保存状态或数据，要根据具体需求进行配置。</li><li>备份和恢复策略：根据应用的重要性，考虑实施备份和恢复策略，以防止意外数据丢失或服务中断。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>DaemonSet作为Kubernetes的核心对象之一，为在集群中每个节点上运行一个或多个Pod提供了便捷的方式。通过声明式的定义，DaemonSet能够确保系统级别的任务在整个集群中得到执行。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象statefulset</title>
      <link href="/posts/4a17b515.html"/>
      <url>/posts/4a17b515.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）是一种强大的容器编排平台，为容器化应用提供了丰富的管理和编排工具。在Kubernetes中，StatefulSet是一个关键的核心对象，用于管理有状态应用的部署和伸缩。本文将深入研究StatefulSet的概念、使用场景，以及提供详细的示例以帮助读者更好地理解和应用这一核心对象。</p><h2 id="StatefulSet的基本概念"><a href="#StatefulSet的基本概念" class="headerlink" title="StatefulSet的基本概念"></a>StatefulSet的基本概念</h2><h3 id="什么是StatefulSet？"><a href="#什么是StatefulSet？" class="headerlink" title="什么是StatefulSet？"></a>什么是StatefulSet？</h3><p>StatefulSet是Kubernetes中的一个核心概念，用于管理有状态应用的Pod部署和伸缩。相比于ReplicaSet，StatefulSet更适用于需要持久化存储、唯一标识和有序部署的场景，例如数据库和消息队列。</p><h3 id="StatefulSet的主要作用"><a href="#StatefulSet的主要作用" class="headerlink" title="StatefulSet的主要作用"></a>StatefulSet的主要作用</h3><ul><li>有序部署：StatefulSet能够按照定义的顺序，逐个部署Pod实例，确保它们按照固定的命名规则有序启动。</li><li>稳定的网络标识：每个Pod都有一个稳定的网络标识（如DNS名称），使得它们可以方便地被其他应用或服务引用。</li><li>持久化存储：StatefulSet支持使用持久化卷，确保Pod实例的数据可以持久保存，并在Pod重新调度时保留。</li></ul><h2 id="StatefulSet的详细示例"><a href="#StatefulSet的详细示例" class="headerlink" title="StatefulSet的详细示例"></a>StatefulSet的详细示例</h2><p>为了更好地理解和应用StatefulSet，我们将通过一个详细的示例来演示StatefulSet的创建、有序部署以及持久化存储等功能。</p><h3 id="示例：运行MySQL数据库的StatefulSet"><a href="#示例：运行MySQL数据库的StatefulSet" class="headerlink" title="示例：运行MySQL数据库的StatefulSet"></a>示例：运行MySQL数据库的StatefulSet</h3><p>考虑一个运行MySQL数据库的场景，我们将使用StatefulSet来部署和管理多个MySQL实例。</p><h3 id="StatefulSet的定义"><a href="#StatefulSet的定义" class="headerlink" title="StatefulSet的定义"></a>StatefulSet的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-statefulset</span><br><span class="line">spec:</span><br><span class="line">  serviceName: mysql</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: mysql-container</span><br><span class="line">        image: mysql:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306</span><br><span class="line">        env:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: &quot;password&quot;</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: mysql-storage</span><br><span class="line">          mountPath: /var/lib/mysql</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: mysql-storage</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="line">      storageClassName: &quot;standard&quot;</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li>serviceName: mysql 指定了为StatefulSet创建的服务的名称，用于提供稳定的DNS标识。</li><li>replicas: 3 指定我们希望运行3个MySQL实例。</li><li>selector 使用标签选择器选择具有标签 app: mysql 的Pod实例。</li><li>template 定义了创建Pod的规范，包括使用的镜像、标签等。</li><li>volumeClaimTemplates 定义了用于每个Pod的持久化存储。</li></ul><h3 id="创建StatefulSet"><a href="#创建StatefulSet" class="headerlink" title="创建StatefulSet"></a>创建StatefulSet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f mysql-statefulset.yaml</span><br></pre></td></tr></table></figure><p>以上命令将根据定义的StatefulSet创建相应数量的MySQL实例，并开始运行。</p><h3 id="查看StatefulSet状态"><a href="#查看StatefulSet状态" class="headerlink" title="查看StatefulSet状态"></a>查看StatefulSet状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get statefulsets</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看StatefulSet和Pod的状态，确保MySQL实例已成功运行。</p><h3 id="有序部署和稳定网络标识"><a href="#有序部署和稳定网络标识" class="headerlink" title="有序部署和稳定网络标识"></a>有序部署和稳定网络标识</h3><p>StatefulSet会按照指定的顺序逐个部署Pod实例，每个Pod都会获得一个稳定的网络标识，形如<statefulset-name>-<ordinal>.<service-name>。在我们的例子中，每个MySQL实例的DNS名称将会是mysql-statefulset-0.mysql、mysql-statefulset-1.mysql、mysql-statefulset-2.mysql等。</p><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>每个Pod都将通过volumeClaimTemplates定义的持久化存储创建一个独立的持久卷。这确保了数据的持久性，并且在Pod重新调度时能够恢复。</p><h2 id="StatefulSet的最佳实践"><a href="#StatefulSet的最佳实践" class="headerlink" title="StatefulSet的最佳实践"></a>StatefulSet的最佳实践</h2><ul><li>有序部署：利用StatefulSet的有序特性，确保有状态应用按照定义的顺序启动。</li><li>合理设置副本数：根据应用的负载和性能需求，合理设置StatefulSet的副本数，确保足够的实例来处理流量。</li><li>使用稳定的网络标识：通过StatefulSet创建的Pod具有稳定的DNS标识，可方便地被其他应用引用。</li><li>持久化存储：利用volumeClaimTemplates定义持久化存储，确保Pod实例的数据可以持久保存，并在Pod重新调度时保留。</li><li>备份和恢复策略：根据应用的重要性，考虑实施备份和恢复策略，以防止意外数据丢失或服务中断。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>StatefulSet作为Kubernetes的核心对象之一，为有状态应用的部署和伸缩提供了强大的支持。通过声明式的定义，StatefulSet能够确保有状态应用在Kubernetes中的高可用性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Replicaset</title>
      <link href="/posts/4a17b512.html"/>
      <url>/posts/4a17b512.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）是一种领先的容器编排平台，为容器化应用提供了丰富的资源管理和自动化工具。在Kubernetes中，ReplicaSet是一个关键的核心对象，用于确保在集群中运行指定数量的Pod副本。本文将深入研究ReplicaSet的概念、用法以及提供详细示例以加深对这一核心对象的理解。</p><h2 id="ReplicaSet的基本概念"><a href="#ReplicaSet的基本概念" class="headerlink" title="ReplicaSet的基本概念"></a>ReplicaSet的基本概念</h2><h3 id="什么是ReplicaSet？"><a href="#什么是ReplicaSet？" class="headerlink" title="什么是ReplicaSet？"></a>什么是ReplicaSet？</h3><p>ReplicaSet是Kubernetes中的一个核心概念，用于维护指定数量的Pod副本的运行状态。它可以确保在集群中一直存在指定数量的Pod副本，并在Pod出现故障或被删除时进行替换。</p><h3 id="ReplicaSet的主要作用"><a href="#ReplicaSet的主要作用" class="headerlink" title="ReplicaSet的主要作用"></a>ReplicaSet的主要作用</h3><ul><li>副本管理：ReplicaSet负责管理Pod副本的数量，确保在集群中运行指定数量的实例。</li><li>自愈性：当Pod副本发生故障或被手动删除时，ReplicaSet会自动创建新的Pod副本，确保所需数量的实例一直存在。</li><li>扩缩容：通过调整ReplicaSet的副本数，可以实现Pod的自动扩缩容，以适应变化的负载。</li></ul><h2 id="ReplicaSet的详细示例"><a href="#ReplicaSet的详细示例" class="headerlink" title="ReplicaSet的详细示例"></a>ReplicaSet的详细示例</h2><p>为了更好地理解和使用ReplicaSet，我们将通过一个详细的示例来演示ReplicaSet的创建、扩缩容以及自愈能力。</p><h3 id="示例：Nginx应用的ReplicaSet"><a href="#示例：Nginx应用的ReplicaSet" class="headerlink" title="示例：Nginx应用的ReplicaSet"></a>示例：Nginx应用的ReplicaSet</h3><p>考虑一个简单的Nginx应用，我们将使用ReplicaSet来部署和管理它。</p><h3 id="ReplicaSet的定义"><a href="#ReplicaSet的定义" class="headerlink" title="ReplicaSet的定义"></a>ReplicaSet的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-replicaset</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li>replicas: 3 指定我们希望运行3个Pod副本。</li><li>selector 使用标签选择器选择具有标签 app: nginx 的Pod副本。</li><li>template 定义了创建Pod的规范，包括使用的镜像、标签等。</li></ul><h3 id="创建ReplicaSet"><a href="#创建ReplicaSet" class="headerlink" title="创建ReplicaSet"></a>创建ReplicaSet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-replicaset.yaml</span><br></pre></td></tr></table></figure><p>以上命令将根据定义的ReplicaSet创建相应数量的Pod副本，开始运行Nginx应用。</p><h3 id="查看ReplicaSet状态"><a href="#查看ReplicaSet状态" class="headerlink" title="查看ReplicaSet状态"></a>查看ReplicaSet状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get replicasets</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看ReplicaSet和Pod的状态，确保Pod副本集已成功运行。</p><h3 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h3><p>如果我们希望将Nginx的实例数量扩展到5个，我们只需修改ReplicaSet定义文件中的 replicas 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br></pre></td></tr></table></figure><p>然后再次应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-replicaset.yaml</span><br></pre></td></tr></table></figure><p>Kubernetes将根据新的定义逐步创建2个额外的Pod副本，从而将总实例数扩展到5个。</p><h3 id="自愈能力"><a href="#自愈能力" class="headerlink" title="自愈能力"></a>自愈能力</h3><p>假设其中一个Pod副本由于故障被终止，ReplicaSet会自动检测到这一变化并尝试创建新的Pod副本以保持指定数量的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>ReplicaSet会自动创建新的Pod副本来替代被删除的Pod，确保所需数量的实例一直存在。</p><h2 id="ReplicaSet的最佳实践"><a href="#ReplicaSet的最佳实践" class="headerlink" title="ReplicaSet的最佳实践"></a>ReplicaSet的最佳实践</h2><ul><li>合理设置副本数：根据应用的负载和性能需求，合理设置ReplicaSet的副本数，确保足够的实例来处理流量。</li><li>使用标签选择器：合理使用标签选择器，确保ReplicaSet正确选择要管理的Pod副本。</li><li>谨慎进行扩缩容：在进行扩缩容时，要谨慎调整副本数，避免引入不必要的变化。</li><li>备份和恢复策略：根据应用的重要性，考虑实施备份和恢复策略，以防止意外数据丢失或服务中断。</li><li>监控和报警：通过监控ReplicaSet和相关的Pod状态，设置相应的报警机制，可以及时发现并解决潜在的问题，确保应用的可用性和稳定性。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ReplicaSet作为Kubernetes的核心对象之一，为Pod副本的管理提供了重要的功能。通过声明式的定义，ReplicaSet能够确保在集群中一直存在指定数量的Pod副本，从而提高应用的可用性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象Deployment</title>
      <link href="/posts/4a17b510.html"/>
      <url>/posts/4a17b510.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（K8s）作为一个强大的容器编排平台，提供了许多核心对象来简化和自动化容器化应用的部署和管理。其中，Deployment是一个关键的概念，它为应用提供了声明式的方式来定义、更新和管理应用的部署。本文将深入探讨Kubernetes中的核心对象Deployment，包括它的基本概念、使用场景以及详细的示例。</p><h2 id="Deployment的基本概念"><a href="#Deployment的基本概念" class="headerlink" title="Deployment的基本概念"></a>Deployment的基本概念</h2><h3 id="什么是Deployment？"><a href="#什么是Deployment？" class="headerlink" title="什么是Deployment？"></a>什么是Deployment？</h3><p>Deployment是Kubernetes中用于定义Pod副本集的对象，它负责管理应用的部署和更新。通过Deployment，可以实现应用的滚动更新、回滚以及自动修复。</p><h3 id="Deployment的主要组成部分"><a href="#Deployment的主要组成部分" class="headerlink" title="Deployment的主要组成部分"></a>Deployment的主要组成部分</h3><p>一个Deployment主要包含以下几个关键的组成部分：</p><ul><li>模板（Template）：定义了要创建的Pod的规范，包括镜像、环境变量、卷等。</li><li>副本数（Replica Count）：指定了希望运行的Pod副本数量。</li><li>升级策略（Update Strategy）：定义了应用更新的策略，包括滚动更新、Recreate等。</li><li>标签选择器（Label Selector）：用于选择要进行管理的Pod副本集。</li><li>滚动升级（Rolling Update）：一种升级策略，通过逐步替换旧的Pod实例来实现平滑的升级。</li></ul><h2 id="Deployment的使用场景"><a href="#Deployment的使用场景" class="headerlink" title="Deployment的使用场景"></a>Deployment的使用场景</h2><p>Deployment在Kubernetes中扮演着关键的角色，主要用于以下几个方面：</p><ul><li>应用部署和更新：通过Deployment可以方便地部署应用，并支持滚动更新，确保在更新过程中不中断服务。</li><li>副本管理：Deployment负责管理指定数量的Pod副本，确保始终有指定数量的实例在运行。</li><li>自愈性：Deployment可以监控Pod的状态，当Pod发生故障时，会自动替换为新的Pod，确保应用的高可用性。</li><li>版本回滚：Deployment允许用户回滚到先前的应用版本，以应对更新引入的问题。</li></ul><h2 id="Deployment的详细示例"><a href="#Deployment的详细示例" class="headerlink" title="Deployment的详细示例"></a>Deployment的详细示例</h2><p>为了更好地理解和使用Deployment，我们将通过一个详细的示例来演示Deployment的创建、更新和回滚等操作。</p><h3 id="示例：Nginx应用的Deployment"><a href="#示例：Nginx应用的Deployment" class="headerlink" title="示例：Nginx应用的Deployment"></a>示例：Nginx应用的Deployment</h3><p>考虑一个简单的Nginx应用，我们将使用Deployment来部署和管理它。</p><h3 id="Deployment的定义"><a href="#Deployment的定义" class="headerlink" title="Deployment的定义"></a>Deployment的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>在上面的示例中：</p><ul><li>replicas: 3 指定我们希望运行3个Pod副本。</li><li>selector 使用标签选择器选择具有标签 app: nginx 的Pod副本。</li><li>template 定义了创建Pod的规范，包括使用的镜像、标签等。</li></ul><h3 id="创建Deployment"><a href="#创建Deployment" class="headerlink" title="创建Deployment"></a>创建Deployment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p>以上命令将根据定义的Deployment创建相应的Pod副本集，并开始运行Nginx应用。</p><h3 id="查看Deployment状态"><a href="#查看Deployment状态" class="headerlink" title="查看Deployment状态"></a>查看Deployment状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过上述命令，我们可以查看Deployment和Pod的状态，确保Pod副本集已成功运行。</p><h3 id="更新Deployment"><a href="#更新Deployment" class="headerlink" title="更新Deployment"></a>更新Deployment</h3><p>假设我们需要更新Nginx的镜像版本，我们只需修改Deployment定义文件中的image字段，然后再次应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx:1.19.2</span><br><span class="line">bash</span><br><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p>Kubernetes将按照滚动更新的策略逐步替换旧版本的Pod，确保服务的平滑升级。</p><h3 id="回滚到先前版本"><a href="#回滚到先前版本" class="headerlink" title="回滚到先前版本"></a>回滚到先前版本</h3><p>如果新版本引入了问题，我们可以轻松地回滚到先前的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure><p>Kubernetes将自动执行回滚，将Deployment的版本还原到先前的状态。</p><h2 id="Deployment的最佳实践"><a href="#Deployment的最佳实践" class="headerlink" title="Deployment的最佳实践"></a>Deployment的最佳实践</h2><ul><li>合理设置副本数：根据应用的负载和性能需求，合理设置Deployment的副本数，确保足够的实例来处理流量。</li><li>使用标签选择器：合理使用标签选择器，确保Deployment正确选择要管理的Pod副本。</li><li>谨慎进行滚动更新：在进行滚动更新时，要确保新版本的应用经过充分测试，以避免引入潜在问题。</li><li>定期监控Deployment状态：通过监控Deployment和相关的Pod状态，及时发现并解决潜在的问题，确保应用的可用性和稳定性。</li><li>备份和恢复策略：根据应用的重要性，考虑实施备份和恢复策略，以防止意外数据丢失或服务中断。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Deployment作为Kubernetes的核心对象之一，为应用的部署、更新和管理提供了强大的支持。通过声明式的定义，开发者可以方便地描述应用的期望状态，而Kubernetes会负责实现这一状态。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s配置pod的服务质量(QOS)</title>
      <link href="/posts/4a17b509.html"/>
      <url>/posts/4a17b509.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（简称K8s）是一种开源的容器编排平台，用于简化容器化应用的部署、管理和扩展。Pod是Kubernetes中最小的可部署单元，而服务质量（Quality of Service，QoS）的配置是确保Pod稳定性和性能的关键因素之一。本文将深入讨论在Kubernetes中如何配置Pod的服务质量，并提供详细的示例。</p><h2 id="什么是服务质量（QoS）？"><a href="#什么是服务质量（QoS）？" class="headerlink" title="什么是服务质量（QoS）？"></a>什么是服务质量（QoS）？</h2><p>在Kubernetes中，服务质量是指Pod对资源的需求和对资源使用的限制，这直接影响到Pod的调度、资源分配和故障恢复。Kubernetes定义了三种服务质量等级：</p><ul><li>BestEffort（尽力而为）：Pod未设置资源请求和限制，将尽量使用集群中的所有可用资源。</li><li>Burstable（可突发）：Pod设置了资源请求，但未设置资源限制。它可以使用超出请求的资源，但有限制。</li><li>Guaranteed（保证）：Pod设置了资源请求和限制，确保在满足请求的情况下，不会使用超出限制的资源。</li></ul><h2 id="如何配置服务质量？"><a href="#如何配置服务质量？" class="headerlink" title="如何配置服务质量？"></a>如何配置服务质量？</h2><p>在Kubernetes中，通过设置Pod的资源请求和限制来定义服务质量。资源配置主要包括CPU和内存两个方面。</p><h3 id="CPU资源配置"><a href="#CPU资源配置" class="headerlink" title="CPU资源配置"></a>CPU资源配置</h3><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cpu-qos-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: cpu-qos-demo-ctr</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: &quot;0.5&quot;</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;1&quot;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Pod请求至少0.5个CPU核心，同时限制最大使用量为1个CPU核心，这将被认为是Guaranteed级别的服务质量。</p><h3 id="内存资源配置"><a href="#内存资源配置" class="headerlink" title="内存资源配置"></a>内存资源配置</h3><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memory-qos-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: memory-qos-demo-ctr</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Pod请求至少64兆字节的内存，同时限制最大使用量为128兆字节，也属于Guaranteed级别的服务质量。</p><h2 id="服务质量等级的判断"><a href="#服务质量等级的判断" class="headerlink" title="服务质量等级的判断"></a>服务质量等级的判断</h2><p>Kubernetes根据Pod的资源请求和限制来判断服务质量等级。以下是判断的规则：</p><ul><li>BestEffort：未设置资源请求和限制。</li><li>Burstable：设置了资源请求，但未设置资源限制。</li><li>Guaranteed：设置了资源请求和限制。</li></ul><h2 id="服务质量的最佳实践"><a href="#服务质量的最佳实践" class="headerlink" title="服务质量的最佳实践"></a>服务质量的最佳实践</h2><ul><li>合理设置资源请求和限制：根据应用的实际需求，合理设置资源请求和限制。确保设置的值既满足应用正常运行的需求，又不会浪费资源。</li><li>定期评估和调整配置：随着应用的变化，定期评估和调整服务质量配置是必要的。应用的负载可能随时间而变化，因此及时调整可以更好地适应变化。</li><li>监控和报警：通过监控资源使用情况，设置相应的报警机制，可以及时发现并解决潜在的资源问题，确保系统的稳定性。</li><li>使用Horizontal Pod Autoscaler（HPA）：结合服务质量配置和HPA，可以更好地实现自动化资源管理，根据负载情况动态调整Pod的副本数。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在Kubernetes中，通过合理配置Pod的服务质量，可以确保应用在集群中获得足够的资源，提高系统的稳定性和性能。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中为pod分配CPU和内存资源</title>
      <link href="/posts/4a17b508.html"/>
      <url>/posts/4a17b508.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（简称K8s）是一种开源的容器编排平台，广泛用于构建、部署和管理容器化应用。在Kubernetes中，Pod是最小的可部署单元，而资源分配是确保Pod正常运行的关键因素之一。本文将深入探讨如何在Kubernetes中为Pod分配CPU和内存资源，并提供详细的示例。</p><h2 id="为什么需要资源分配？"><a href="#为什么需要资源分配？" class="headerlink" title="为什么需要资源分配？"></a>为什么需要资源分配？</h2><p>在容器化环境中，多个应用可能在同一台主机上运行，共享主机的资源。为了确保各个应用之间不会相互干扰，Kubernetes引入了资源管理机制，允许用户为每个Pod分配一定数量的CPU和内存资源。这有助于避免资源争夺，提高系统的可靠性和性能。</p><h2 id="Pod中的资源配置"><a href="#Pod中的资源配置" class="headerlink" title="Pod中的资源配置"></a>Pod中的资源配置</h2><p>在Kubernetes中，资源配置主要包括两个方面：CPU和内存。</p><h3 id="CPU资源配置"><a href="#CPU资源配置" class="headerlink" title="CPU资源配置"></a>CPU资源配置</h3><p>CPU请求和限制</p><ul><li>CPU请求（CPU Requests）：是Pod所需的CPU资源的最小量。Kubernetes确保Pod获得至少所请求的CPU资源。如果Pod的实际使用量低于请求量，多余的CPU资源将被其他Pod使用。</li><li>CPU限制（CPU Limits）：是Pod所能使用的CPU资源的上限。这个值定义了Pod的CPU使用量的最大值。当Pod尝试使用超出限制的CPU资源时，Kubernetes会限制其使用。</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cpu-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: cpu-demo-ctr</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: &quot;0.5&quot;</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;1&quot;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Pod请求至少0.5个CPU核心，同时限制最大使用量为1个CPU核心。</p><h3 id="内存资源配置"><a href="#内存资源配置" class="headerlink" title="内存资源配置"></a>内存资源配置</h3><p>内存请求和限制</p><ul><li>内存请求（Memory Requests）：是Pod所需的内存资源的最小量。Kubernetes确保Pod获得至少所请求的内存资源。</li><li>内存限制（Memory Limits）：是Pod所能使用的内存资源的上限。这个值定义了Pod的内存使用量的最大值。</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memory-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: memory-demo-ctr</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Pod请求至少64兆字节的内存，同时限制最大使用量为128兆字节。</p><h2 id="如何设置资源配置"><a href="#如何设置资源配置" class="headerlink" title="如何设置资源配置"></a>如何设置资源配置</h2><p>在Kubernetes中，资源配置可以通过Pod的YAML文件进行设置。在Pod的spec字段下的containers字段中，使用resources字段进行配置。<br>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: resource-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: resource-demo-ctr</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: &quot;0.5&quot;</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;1&quot;</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们为Pod中的容器指定了CPU和内存的请求和限制。</p><h2 id="资源分配的最佳实践"><a href="#资源分配的最佳实践" class="headerlink" title="资源分配的最佳实践"></a>资源分配的最佳实践</h2><ul><li>了解应用需求：在为Pod分配资源之前，了解应用的性能和资源需求是至关重要的。监测应用在测试环境中的CPU和内存使用情况，以便更好地配置资源。</li><li>合理设置请求和限制：根据应用的需求，合理设置CPU和内存的请求和限制。确保设置的值既能满足应用正常运行的需求，又不会浪费资源。</li><li>定期调整配置：随着应用的变化，定期评估和调整资源配置是必要的。应用的负载可能随时间而变化，因此及时调整资源配置可以更好地适应变化。</li><li>使用Horizontal Pod Autoscaler（HPA）：Kubernetes提供了HPA来自动调整Pod的副本数，以适应应用负载的变化。结合资源配置和HPA，可以更好地实现自动化资源管理。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在Kubernetes中，为Pod正确配置CPU和内存资源是确保应用正常运行、提高系统性能的关键步骤。通过合理设置资源请求和限制，并根据应用的需求进行调整，可以更好地利用集群中的资源，提高整体系统的可靠性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象init-pod</title>
      <link href="/posts/4a17b507.html"/>
      <url>/posts/4a17b507.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（简称K8s）是一个强大的容器编排平台，为容器化应用提供了灵活的部署和管理机制。在Kubernetes中，Init容器是一种特殊类型的容器，用于在主容器启动之前执行初始化任务。本文将深入研究Kubernetes中的Init容器，包括其定义、使用场景、生命周期以及详细的示例。</p><h2 id="什么是Init容器？"><a href="#什么是Init容器？" class="headerlink" title="什么是Init容器？"></a>什么是Init容器？</h2><p>Init容器是在Pod中运行的一个独立的容器，它负责在主容器启动之前执行初始化任务。这些初始化任务可以包括数据准备、配置检查、网络设置等。一旦Init容器中的任务成功完成，Kubernetes将启动主容器。Init容器的生命周期是独立于主容器的，这使得我们能够在应用程序启动之前执行必要的预处理工作。</p><h2 id="Init容器的使用场景"><a href="#Init容器的使用场景" class="headerlink" title="Init容器的使用场景"></a>Init容器的使用场景</h2><h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>在某些情况下，我们可能需要在主容器启动之前准备数据，比如从持久存储加载配置文件、初始化数据库等。Init容器可以负责在主容器启动之前执行这些数据初始化任务。</p><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>Init容器还可以用于在主容器启动之前进行网络设置。这包括等待其他服务就绪、配置网络策略等。</p><h3 id="等待依赖服务"><a href="#等待依赖服务" class="headerlink" title="等待依赖服务"></a>等待依赖服务</h3><p>如果应用程序依赖于其他服务，我们可以使用Init容器来确保这些服务在主容器启动之前已经可用，从而避免启动过早导致的错误。</p><h2 id="Init容器的生命周期"><a href="#Init容器的生命周期" class="headerlink" title="Init容器的生命周期"></a>Init容器的生命周期</h2><p>Init容器的生命周期包括以下几个阶段：</p><h3 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h3><p>Pod进入Pending状态表示Kubernetes正在创建并初始化Init容器。</p><h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><p>Init容器进入Running状态表示它正在执行初始化任务。一旦任务完成，Init容器将自动终止。</p><h3 id="Terminated"><a href="#Terminated" class="headerlink" title="Terminated"></a>Terminated</h3><p>Init容器在完成任务后将进入Terminated状态。根据任务执行结果，它可能是成功完成或失败。</p><h2 id="Init容器的示例"><a href="#Init容器的示例" class="headerlink" title="Init容器的示例"></a>Init容器的示例</h2><p>为了更好地理解Init容器的使用，以下是一个包含Init容器的Pod定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: main-container</span><br><span class="line">    image: my-app:latest</span><br><span class="line">    # 主容器的配置</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: init-container</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;echo Initializing... &amp;&amp; sleep 5&#x27;]</span><br><span class="line">    # Init容器的配置</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为mypod的Pod，包含了一个名为main-container的主容器和一个名为init-container的Init容器。Init容器使用busybox镜像，执行一个简单的初始化任务，即打印初始化消息并等待5秒钟。一旦Init容器完成，主容器将启动。</p><h2 id="Init容器的高级用法"><a href="#Init容器的高级用法" class="headerlink" title="Init容器的高级用法"></a>Init容器的高级用法</h2><p>Init容器还支持一些高级用法，比如多个Init容器的串行执行和在Init容器之间共享数据卷。以下是一个包含两个串行执行的Init容器的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: main-container</span><br><span class="line">    image: my-app:latest</span><br><span class="line">    # 主容器的配置</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: init-container-1</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;echo Initializing Step 1... &amp;&amp; sleep 5&#x27;]</span><br><span class="line">    # 第一个Init容器的配置</span><br><span class="line">  - name: init-container-2</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;echo Initializing Step 2... &amp;&amp; sleep 5&#x27;]</span><br><span class="line">    # 第二个Init容器的配置</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了两个Init容器，init-container-1和init-container-2，它们将按照顺序执行。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRD的简单介绍</title>
      <link href="/posts/4a17b005.html"/>
      <url>/posts/4a17b005.html</url>
      
        <content type="html"><![CDATA[<h1 id="CRD的简单介绍"><a href="#CRD的简单介绍" class="headerlink" title="CRD的简单介绍"></a>CRD的简单介绍</h1><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><code>Custom Resource Define</code> 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。</p><p>CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个对应的控制器去监听 CRD 的各种事件来添加自定义的业务逻辑。</p><h1 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h1><p>如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。</p><p>比如我们可以定义一个如下所示的 CRD 资源清单文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: apiextensions.<span class="property">k8s</span>.<span class="property">io</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  # name 必须匹配下面的spec字段：&lt;plural&gt;.&lt;group&gt;  </span><br><span class="line">  <span class="attr">name</span>: foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # <span class="keyword">for</span> more information on the below annotation, please see</span><br><span class="line">  # <span class="attr">https</span>:<span class="comment">//github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/2337-k8s.io-group-protection/README.md</span></span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    <span class="string">&quot;api-approved.kubernetes.io&quot;</span>: <span class="string">&quot;unapproved, experimental-only; please get an approval from Kubernetes API reviewers if you&#x27;re trying to develop a CRD in the *.k8s.io or *.kubernetes.io groups&quot;</span></span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  # group 名用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义： /apis/&lt;group&gt;/&lt;version&gt;</span><br><span class="line">  <span class="attr">group</span>: crd.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">  # 列出自定义资源的所有 <span class="variable constant_">API</span> 版本</span><br><span class="line">  <span class="attr">versions</span>:</span><br><span class="line">    - <span class="attr">name</span>: v1  # 版本名称，比如v1，v1beta1</span><br><span class="line">      <span class="attr">served</span>: <span class="literal">true</span>  # 是否开启通过 <span class="variable constant_">REST</span> <span class="title class_">APIs</span>访问 <span class="string">`/apis/&lt;group&gt;/&lt;version&gt;/...`</span></span><br><span class="line">      <span class="attr">storage</span>: <span class="literal">true</span> # 必须将一个且只有一个版本标记为存储版本</span><br><span class="line">      <span class="attr">schema</span>: # 定义自定义对象的声明规范</span><br><span class="line">        # schema used <span class="keyword">for</span> validation</span><br><span class="line">        <span class="attr">openAPIV3Schema</span>:</span><br><span class="line">          <span class="attr">type</span>: object</span><br><span class="line">          <span class="attr">properties</span>:</span><br><span class="line">            <span class="attr">spec</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">deploymentName</span>:</span><br><span class="line">                  <span class="attr">type</span>: string</span><br><span class="line">                <span class="attr">replicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">                  <span class="attr">minimum</span>: <span class="number">1</span></span><br><span class="line">                  <span class="attr">maximum</span>: <span class="number">10</span></span><br><span class="line">            <span class="attr">status</span>:</span><br><span class="line">              <span class="attr">type</span>: object</span><br><span class="line">              <span class="attr">properties</span>:</span><br><span class="line">                <span class="attr">availableReplicas</span>:</span><br><span class="line">                  <span class="attr">type</span>: integer</span><br><span class="line">  <span class="attr">names</span>:</span><br><span class="line">    # kind 是 sigular 的一个驼峰形式的定义，在资源清单中会使用</span><br><span class="line">    <span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line">    # plural 名字用于 <span class="variable constant_">REST</span> <span class="variable constant_">API</span> 中的定义：/apis/&lt;group&gt;<span class="regexp">/&lt;version&gt;/</span>&lt;plural&gt;    </span><br><span class="line">    <span class="attr">plural</span>: foos</span><br><span class="line">    # singular 名称用于 <span class="variable constant_">CLI</span> 操作或显示的一个别名    </span><br><span class="line">    <span class="attr">singular</span>: foo</span><br><span class="line">    # shortNames 相当于缩写形式    </span><br><span class="line">    <span class="attr">shortNames</span>:</span><br><span class="line">    - fo</span><br><span class="line">  <span class="attr">scope</span>: <span class="title class_">Namespaced</span></span><br></pre></td></tr></table></figure><p>这个地方的定义和我们定义普通的资源对象比较类似，我们可以随意定义一个自定义的资源对象，但是在创建资源的时候，肯定不是任由我们随意去编写 YAML 文件的，当我们把上面的 CRD 文件提交给 Kubernetes 之后，Kubernetes 会对我们提交的声明文件进行校验，从定义可以看出 CRD 是基于 <a href="https://link.juejin.cn/?target=https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md%23schemaObject">OpenAPI v3 schem</a> 进行规范的。</p><p>当然这种校验只是对于字段的类型进行校验，比较初级，如果想要更加复杂的校验，这个时候就需要通过 Kubernetes 的 admission webhook 来实现了。关于校验的更多用法，可以前往<a href="https://link.juejin.cn/?target=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/%23validation">官方文档</a>查看。</p><p>现在我们可以直接使用kubectl来创建这个CRD资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl apply -f crd.<span class="property">example</span>.<span class="property">com_foos</span>.<span class="property">yaml</span> </span><br><span class="line">customresourcedefinition.<span class="property">apiextensions</span>.<span class="property">k8s</span>.<span class="property">io</span>/foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span> created</span><br></pre></td></tr></table></figure><p>这个时候我们可以查看到集群中已经有我们定义的这个CRD资源对象了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get crd | grep example</span><br><span class="line">foos.<span class="property">crd</span>.<span class="property">example</span>.<span class="property">com</span>                                  <span class="number">2022</span>-<span class="number">05</span>-11<span class="attr">T05</span>:<span class="number">28</span>:51Z</span><br></pre></td></tr></table></figure><p>这个时候一个新的 namespace 级别的 RESTful API 就会被创建：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/apis/crd/example.<span class="property">com</span>/v1/namespaces<span class="comment">/*/foos/...</span></span><br></pre></td></tr></table></figure><p>接着我们就可以使用这个 API 端点来创建和管理自定义的对象，这些对象的类型就是上面创建的 CRD 对象规范中的 <code>foo</code>。</p><p>现在在 Kubernetes 集群中我们就多了一种新的资源叫做<code>foos.crd.example.com</code>    ，我们就可以使用它来定义一个 <code>Foo</code> 资源对象了，这个自定义资源对象里面可以包含的字段我们在定义的时候通过 <code>schema</code> 进行了规范，比如现在我们来创建一个如下所示的资源清单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>创建完成后我们就可以用kubectl来管理我们这里创建的Foo对象了，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo</span><br><span class="line"><span class="variable constant_">NAME</span>          <span class="variable constant_">AGE</span></span><br><span class="line">example-foo   20m</span><br></pre></td></tr></table></figure><p>在使用 kubectl 的时候，资源名称是不区分大小写的，我们可以使用 CRD 中定义的单数或者复数形式以及任何简写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get foo example-foo -o yaml</span><br><span class="line"><span class="attr">apiVersion</span>: crd.<span class="property">example</span>.<span class="property">com</span>/v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Foo</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">annotations</span>:</span><br><span class="line">    kubectl.<span class="property">kubernetes</span>.<span class="property">io</span>/last-applied-<span class="attr">configuration</span>: |</span><br><span class="line">      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;crd.example.com/v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Foo&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;default&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;deploymentName&quot;</span>:<span class="string">&quot;example-foo&quot;</span>,<span class="string">&quot;replicas&quot;</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">  <span class="attr">creationTimestamp</span>: <span class="string">&quot;2022-05-11T05:40:38Z&quot;</span></span><br><span class="line">  <span class="attr">generation</span>: <span class="number">1</span></span><br><span class="line">  <span class="attr">name</span>: example-foo</span><br><span class="line">  <span class="attr">namespace</span>: <span class="keyword">default</span></span><br><span class="line">  <span class="attr">resourceVersion</span>: <span class="string">&quot;37605212&quot;</span></span><br><span class="line">  <span class="attr">uid</span>: 56d5b1d3-f6f9-<span class="number">4106</span>-90c4-a0e3c7d130c0</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">deploymentName</span>: example-foo</span><br><span class="line">  <span class="attr">replicas</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就如上面我们说的，现在我们自定义的资源创建完成了，但是也只是单纯的把资源清单数据存入到了 etcd 中而已，并没有什么其他用处，因为我们没有定义一个对应的控制器来处理相关的业务逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象pod</title>
      <link href="/posts/4a17b506.html"/>
      <url>/posts/4a17b506.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Kubernetes（简称K8s）作为容器编排领域的领军者，为应用容器提供了高效的部署、扩展和管理机制。在Kubernetes中，Pod是最基本的调度单位，本文将深入探讨Pod的概念、特性、生命周期以及实际应用中的示例。</p><h2 id="什么是Pod？"><a href="#什么是Pod？" class="headerlink" title="什么是Pod？"></a>什么是Pod？</h2><p>Pod是Kubernetes中最小的可部署单元，它是一个或多个容器的组合，共享相同的网络命名空间和存储卷。Pod可以包含一个或多个应用容器，这些容器共享相同的上下文，可以轻松地相互通信。Pod的设计理念是将紧密关联的应用组合在一起，使它们能够共享资源并协同工作。</p><h2 id="Pod的特性"><a href="#Pod的特性" class="headerlink" title="Pod的特性"></a>Pod的特性</h2><h3 id="多容器协同工作"><a href="#多容器协同工作" class="headerlink" title="多容器协同工作"></a>多容器协同工作</h3><p>一个Pod中的多个容器可以协同工作，共享相同的网络和存储。这使得将紧密相关的组件打包在一起变得更加容易，从而促进了微服务架构的实现。</p><h3 id="共享网络命名空间"><a href="#共享网络命名空间" class="headerlink" title="共享网络命名空间"></a>共享网络命名空间</h3><p>Pod内的所有容器共享相同的网络命名空间，它们可以使用localhost相互通信，无需通过网络进行通信。这简化了容器之间的通信。</p><h3 id="共享存储卷"><a href="#共享存储卷" class="headerlink" title="共享存储卷"></a>共享存储卷</h3><p>Pod内的容器可以共享同一存储卷，实现数据共享。这对于需要共享状态或数据的应用程序非常有用。</p><h3 id="生命周期共享"><a href="#生命周期共享" class="headerlink" title="生命周期共享"></a>生命周期共享</h3><p>Pod中的容器生命周期是共享的。它们同时启动、停止，从而确保它们在同一上下文环境中运行。</p><h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><p>Pod的生命周期可以分为以下几个阶段：</p><h3 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h3><p>Pod被创建后，处于Pending状态表示Kubernetes正在尝试将Pod调度到节点上，并创建Pod中的容器。</p><h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><p>一旦Pod中的所有容器成功启动，Pod将进入Running状态。此时，容器正在正常运行。</p><h3 id="Succeeded"><a href="#Succeeded" class="headerlink" title="Succeeded"></a>Succeeded</h3><p>当Pod中的所有容器成功完成它们的任务时，Pod将进入Succeeded状态。这表示Pod中的所有容器都已成功执行完毕。</p><h3 id="Failed"><a href="#Failed" class="headerlink" title="Failed"></a>Failed</h3><p>如果Pod中的任何容器失败，Pod将进入Failed状态。这可能是由于容器崩溃或执行失败。</p><h3 id="Unknown"><a href="#Unknown" class="headerlink" title="Unknown"></a>Unknown</h3><p>如果无法获取Pod的状态信息，Pod将被标记为Unknown状态。</p><h2 id="Pod示例"><a href="#Pod示例" class="headerlink" title="Pod示例"></a>Pod示例</h2><p>为了更好地理解Pod的使用，以下是一个简单的Pod定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mycontainer</span><br><span class="line">    image: nginx:latest</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为mypod的Pod，它包含一个名为mycontainer的容器，该容器使用了Nginx的最新版本镜像。此Pod没有声明共享存储卷或多个容器，仅作为一个简单的入门示例。</p><h2 id="Pod中的多容器示例"><a href="#Pod中的多容器示例" class="headerlink" title="Pod中的多容器示例"></a>Pod中的多容器示例</h2><p>考虑一个需要协同工作的多容器示例，比如一个Web应用和一个Sidecar容器用于日志收集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: webapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: webapp-container</span><br><span class="line">    image: my-webapp:latest</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">  - name: sidecar-container</span><br><span class="line">    image: log-collector:latest</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为webapp-pod的Pod，其中包含了两个容器，分别是webapp-container和sidecar-container。webapp-container运行Web应用，而sidecar-container用于收集日志。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心概念Annotation</title>
      <link href="/posts/4a17b506.html"/>
      <url>/posts/4a17b506.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（常简称为K8s）是一个强大的容器编排平台，已经成为现代应用开发和部署的基石。尽管在Kubernetes中不太为人熟知，但注解（Annotations）也是一个同样重要的特性。本文将深入探讨Kubernetes注解，探讨它们的定义、重要性，并提供详细示例展示其实际用途。</p><h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><p>在Kubernetes中，注解是以键值对形式附加到对象上的元数据。与标签（Labels）不同，标签用于识别和选择对象，而注解则用于存储非标识性信息。这些额外的信息可以被工具、自动化流程和管理员利用，以增强和简化Kubernetes资源的各个方面的管理。</p><h2 id="为什么使用注解？"><a href="#为什么使用注解？" class="headerlink" title="为什么使用注解？"></a>为什么使用注解？</h2><p>注解提供了一种灵活且可扩展的方式，用于向Kubernetes对象添加上下文信息。这种额外的上下文可用于多种目的，包括：</p><ul><li>文档化： 注解可以作为文档的一种形式，提供关于特定资源的目的、使用方法或历史的见解。</li><li>工具集成： Kubernetes生态系统中的各种工具和控制器可能使用注解来定制其行为。注解充当这些工具的提示或指令。</li><li>配置参数： 注解可以用于定义应用程序的配置参数，例如数据库连接字符串、环境变量等。</li></ul><h2 id="注解示例"><a href="#注解示例" class="headerlink" title="注解示例"></a>注解示例</h2><p>为了更好地理解注解的实际用途，我们将通过一些具体的示例来演示其在Kubernetes中的应用。</p><h3 id="文档化Pod的用途"><a href="#文档化Pod的用途" class="headerlink" title="文档化Pod的用途"></a>文档化Pod的用途</h3><p>假设我们有一个Pod，它运行一个复杂的数据处理任务。我们可以使用注解来提供更详细的描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: data-processing-pod</span><br><span class="line">  annotations:</span><br><span class="line">    purpose: &quot;This pod is responsible for processing large datasets and generating reports.&quot;</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: data-processor</span><br><span class="line">      image: data-processor-image</span><br><span class="line">      # 省略其他配置</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了purpose注解，它提供了有关Pod用途的详细说明。</p><h3 id="集成监控工具"><a href="#集成监控工具" class="headerlink" title="集成监控工具"></a>集成监控工具</h3><p>假设我们希望将Prometheus监控工具集成到我们的Pod中，我们可以使用注解指定监控配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: monitored-pod</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">    prometheus.io/port: &quot;8080&quot;</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: web-app</span><br><span class="line">      image: web-app-image</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">      # 省略其他配置</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了与Prometheus相关的注解，以便Prometheus能够正确地监控Pod。</p><h3 id="定义应用程序配置"><a href="#定义应用程序配置" class="headerlink" title="定义应用程序配置"></a>定义应用程序配置</h3><p>有时，我们希望通过注解来定义应用程序的配置参数，以便在部署时轻松修改它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: app-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: my-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: my-app</span><br><span class="line">      annotations:</span><br><span class="line">        app-config/database-url: &quot;jdbc:mysql://db-server:3306/mydatabase&quot;</span><br><span class="line">        app-config/max-connections: &quot;100&quot;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: my-app-container</span><br><span class="line">          image: my-app-image</span><br><span class="line">          # 省略其他配置</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了app-config前缀的注解，用于指定应用程序的数据库连接URL和最大连接数。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心概念label和label-selector</title>
      <link href="/posts/4a17b505.html"/>
      <url>/posts/4a17b505.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes是一个强大的容器编排平台，而Label和Label Selector是其中两个核心概念。它们为用户提供了一种在集群中对资源进行分类、组织和选择的机制。本文将深入探讨Kubernetes中Label和Label Selector的作用、用法以及通过详细的示例演示它们的强大功能。</p><h2 id="Label是什么？"><a href="#Label是什么？" class="headerlink" title="Label是什么？"></a>Label是什么？</h2><p>在Kubernetes中，Label是一种用于标识Kubernetes对象的键值对。它是一个附加到资源对象（如Pod、Node、Service等）的元数据，用于标记和分类这些对象。Label通常用于表示对象的属性、用途、环境等信息，以便更好地组织和管理这些资源。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个Pod定义的例子，其中包含了两个Label：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">    environment: production</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>在这个例子中，Pod被标记为app: web和environment: production，这两个Label可以用于标识和过滤Pod。</p><h2 id="Label-Selector是什么？"><a href="#Label-Selector是什么？" class="headerlink" title="Label Selector是什么？"></a>Label Selector是什么？</h2><p>Label Selector是一种用于选择具有特定Label的资源对象的机制。它允许用户根据Label的键值对对资源进行过滤和选择，从而实现更灵活的资源管理。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用Label Selector选择所有具有app: web标签的Pod的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">    environment: production</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myservice</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">    tier: backend</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: web</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个Pod和一个Service，它们都有相同的app: web标签。接下来，我们可以使用Label Selector来选择这些具有相同Label的资源。</p><h2 id="Label的使用场景"><a href="#Label的使用场景" class="headerlink" title="Label的使用场景"></a>Label的使用场景</h2><p>Label在Kubernetes中有许多使用场景，以下是一些常见的应用：</p><ul><li>应用分类： 将相同应用的不同组件使用相同的Label，便于组织和管理这些组件。</li><li>环境区分： 在不同的环境（如开发、测试、生产）中使用不同的Label，以便在资源选择时进行区分。</li><li>版本控制： 使用Label来标识应用程序或服务的版本，方便进行版本控制和回滚。</li><li>目标定位： 在Service中使用Label Selector来定位具有特定标签的Pod，实现服务的目标定位。</li></ul><h2 id="Label-Selector的类型"><a href="#Label-Selector的类型" class="headerlink" title="Label Selector的类型"></a>Label Selector的类型</h2><p>Kubernetes支持多种Label Selector的类型，以满足不同的选择需求。以下是一些常见的Label Selector类型：</p><ul><li><p>Equality-Based Selector： 使用等式来匹配Label的值，例如选择所有app: web的Pod。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx</span><br></pre></td></tr></table></figure></li><li><p>Set-Based Selector： 使用集合操作（如in、notIn、exists、doesNotExist等）来匹配Label的值，例如选择所有environment为production或development的Pod。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l &#x27;environment in (production,development)&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">    environment: production</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure></li></ul><h2 id="Label和Label-Selector的高级应用"><a href="#Label和Label-Selector的高级应用" class="headerlink" title="Label和Label Selector的高级应用"></a>Label和Label Selector的高级应用</h2><h3 id="使用Label-Selector选择Service的后端Pod"><a href="#使用Label-Selector选择Service的后端Pod" class="headerlink" title="使用Label Selector选择Service的后端Pod"></a>使用Label Selector选择Service的后端Pod</h3><p>在Kubernetes中，Service是一种抽象，用于公开一组Pod作为网络服务。通过使用Label和Label Selector，我们可以轻松选择Service的后端Pod。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myservice</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: web</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br></pre></td></tr></table></figure><p>在这个例子中，Service通过Label Selector选择所有具有app: web标签的Pod作为其后端。</p><h3 id="使用Label-Selector进行滚动更新"><a href="#使用Label-Selector进行滚动更新" class="headerlink" title="使用Label Selector进行滚动更新"></a>使用Label Selector进行滚动更新</h3><p>Kubernetes允许用户使用Label Selector进行滚动更新，确保在更新过程中不影响服务的可用性。以下是一个Deployment的例子，使用Label Selector控制滚动更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=2 deployment --selector=app=web</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx:1.16</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为myapp的Deployment，使用app: web标签选择Pod。当需要进行滚动更新时，可以修改Deployment的Pod模板，例如将nginx:1.16改为nginx:1.17，然后应用这个更新。Kubernetes将逐步更新具有app: web标签的Pod，确保在更新的过程中服务保持可用。<br>总结</p><p>Kubernetes中的Label和Label Selector是非常强大的工具，它们为用户提供了一种灵活而强大的资源管理和选择机制。通过合理使用Label，可以更好地组织和管理Kubernetes集群中的资源。Label Selector则提供了一种灵活的方式，允许用户根据Label的键值对对资源进行过滤和选择。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s核心对象namespace</title>
      <link href="/posts/4a17b504.html"/>
      <url>/posts/4a17b504.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kubernetes（简称K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。在Kubernetes中，Namespace是一个重要的概念，它允许用户在集群中创建虚拟的集群划分，以便更好地组织和管理应用程序、服务以及资源。本文将深入探讨Kubernetes Namespace的作用、使用方法和示例。</p><h2 id="什么是Namespace？"><a href="#什么是Namespace？" class="headerlink" title="什么是Namespace？"></a>什么是Namespace？</h2><p>Namespace是Kubernetes中用于将集群划分为多个虚拟集群的一种机制。它提供了一种将资源隔离开的方式，使得在同一个集群中可以运行多个相互独立的应用程序或服务。Namespace主要用于以下几个方面：</p><ul><li>隔离资源： 通过Namespace，可以将集群中的资源（如Pod、Service、Volume等）进行逻辑上的隔离，避免命名冲突和资源干扰。</li><li>权限控制： Namespace也是一种权限控制的手段，允许不同的团队或用户在同一个集群中使用独立的Namespace，从而实现资源的独立管理和权限控制。</li><li>环境隔离： 在开发、测试和生产环境中，可以使用不同的Namespace，确保各个环境之间的资源不会互相影响。</li></ul><h2 id="Namespace的类型"><a href="#Namespace的类型" class="headerlink" title="Namespace的类型"></a>Namespace的类型</h2><p>Kubernetes提供了一些默认的Namespace，同时也支持用户创建自定义的Namespace。以下是一些常见的Namespace类型：</p><ul><li>Default Namespace： 集群创建时，默认存在一个名为”default”的Namespace。如果用户没有指定Namespace，Pod和Service等资源将被放置在”default” Namespace中。</li><li>System Namespace： 这类Namespace主要用于存放Kubernetes系统组件，例如kube-system，它包含了集群中的核心组件如kube-controller-manager、kube-scheduler等。</li><li>用户自定义Namespace： 用户可以根据需要创建自己的Namespace，将应用程序或服务隔离在独立的命名空间中。</li></ul><h2 id="创建Namespace"><a href="#创建Namespace" class="headerlink" title="创建Namespace"></a>创建Namespace</h2><h3 id="使用kubectl创建Namespace"><a href="#使用kubectl创建Namespace" class="headerlink" title="使用kubectl创建Namespace"></a>使用kubectl创建Namespace</h3><p>在Kubernetes中，可以使用kubectl命令行工具来创建Namespace。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace my-namespace</span><br></pre></td></tr></table></figure><p>通过上述命令，将创建一个名为my-namespace的Namespace。用户可以根据实际需要创建多个Namespace，并通过kubectl命令行工具轻松管理。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个多团队共享的Kubernetes集群，每个团队负责自己的应用程序。我们可以为每个团队创建独立的Namespace，以确保资源的隔离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace team-a</span><br><span class="line">kubectl create namespace team-b</span><br><span class="line">kubectl create namespace team-c</span><br></pre></td></tr></table></figure><p>上述命令将分别创建名为team-a、team-b和team-c的Namespace。接下来，我们可以在每个Namespace中部署各自的应用程序。</p><h2 id="切换Namespace"><a href="#切换Namespace" class="headerlink" title="切换Namespace"></a>切换Namespace</h2><p>在kubectl中，可以使用–namespace或-n选项来切换当前的Namespace。以下是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切换到team-a Namespace</span><br><span class="line">kubectl config set-context --current --namespace=team-a</span><br></pre></td></tr></table></figure><p>通过上述命令，我们将当前的kubectl上下文切换到team-a Namespace，后续的kubectl命令将在该Namespace中执行。<br>查看Namespace</p><p>要查看集群中存在的Namespace，可以使用以下kubectl命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br></pre></td></tr></table></figure><p>这将列出所有的Namespace及其状态。示例输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintextNAME          STATUS   AGE</span><br><span class="line">default       Active   1d</span><br><span class="line">kube-system   Active   1d</span><br><span class="line">team-a        Active   1h</span><br><span class="line">team-b        Active   30m</span><br><span class="line">team-c        Active   10m</span><br></pre></td></tr></table></figure><h2 id="在Namespace中部署应用程序"><a href="#在Namespace中部署应用程序" class="headerlink" title="在Namespace中部署应用程序"></a>在Namespace中部署应用程序</h2><p>在Namespace中部署应用程序与在默认Namespace中的部署类似，只需在kubectl命令中加入–namespace或-n选项即可。以下是一个简单的部署示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在team-a Namespace中部署一个示例应用</span><br><span class="line">kubectl create deployment sample-app --image=nginx --namespace=team-a</span><br></pre></td></tr></table></figure><p>通过上述命令，我们在team-a Namespace中部署了一个使用Nginx镜像的示例应用。</p><h2 id="使用Namespace进行资源隔离"><a href="#使用Namespace进行资源隔离" class="headerlink" title="使用Namespace进行资源隔离"></a>使用Namespace进行资源隔离</h2><p>在多Namespace的环境中，资源的隔离是非常重要的。在同一个集群中，不同Namespace中的资源可以具有相同的名称，但它们之间是相互隔离的。以下是一个具体的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在team-a Namespace中定义一个Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">  namespace: team-a</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>通过上述定义，在team-a Namespace中创建了一个名为mypod的Pod，而在其他Namespace中可以存在相同名称的Pod而互不干扰。</p><h2 id="Namespace的权限控制"><a href="#Namespace的权限控制" class="headerlink" title="Namespace的权限控制"></a>Namespace的权限控制</h2><p>Kubernetes提供了RBAC（Role-Based Access Control）机制，可以通过RBAC为不同的Namespace设置不同的权限。以下是一个简单的RBAC示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个角色(Role)和角色绑定(RoleBinding)，并将其绑定到team-a Namespace</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: team-a</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  namespace: team-a</span><br><span class="line">  name: read-pods</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: alice</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>上述RBAC定义创建了一个名为pod-reader的角色，允许用户Alice在team-a Namespace中获取和列举Pod资源。然后，通过角色绑定将这个角色绑定到用户Alice。</p><h2 id="删除Namespace"><a href="#删除Namespace" class="headerlink" title="删除Namespace"></a>删除Namespace</h2><p>要删除Namespace及其所有资源，可以使用以下kubectl命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete namespace team-a</span><br></pre></td></tr></table></figure><p>上述命令将删除名为team-a的Namespace，包括其中的所有资源。在执行删除操作时，请确保不再需要该Namespace中的任何资源。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minikube的使用</title>
      <link href="/posts/4a17b503.html"/>
      <url>/posts/4a17b503.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Minikube 是一个用于在本地开发环境中运行 Kubernetes 集群的工具。本文将深入介绍 Minikube 的各项功能和用法，以帮助开发人员更好地利用它进行容器化应用的开发、测试和学习。</p><h2 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h2><p>如果你尚未安装 Minikube，请参考前文的Minikube 安装指南进行安装。</p><h2 id="启动-Minikube-集群"><a href="#启动-Minikube-集群" class="headerlink" title="启动 Minikube 集群"></a>启动 Minikube 集群</h2><p>在安装完成 Minikube 后，我们可以通过以下命令启动 Minikube 集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure><p>该命令将启动一个单节点的 Kubernetes 集群，并使用默认的虚拟机驱动。你还可以通过 –driver 选项指定其他虚拟机驱动，比如 VirtualBox 或 KVM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --driver=virtualbox</span><br></pre></td></tr></table></figure><p>在启动过程中，Minikube 会下载所需的镜像和组件，并配置 Kubernetes 集群。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在开始深入使用 Minikube 之前，让我们回顾一下一些基本的 Kubernetes 概念。</p><ul><li>Pods（Pod）： 是 Kubernetes 最小的可部署单元，通常包含一个容器。Pods 是应用程序的实例，共享相同的网络命名空间和存储卷。</li><li>Deployments（部署）： 用于定义和管理 Pod 的副本数和更新策略。Deployments 使得应用程序的扩展和更新变得更加容易。</li><li>Services（服务）： 提供了一个稳定的网络端点，以便与 Pod 交互。Services 可以通过选择器与一组 Pod 关联，形成一个虚拟服务。</li><li>ConfigMaps 和 Secrets： 用于存储应用程序的配置信息和敏感数据。ConfigMaps 用于非敏感数据，而 Secrets 用于敏感数据，如密码和 API 密钥。</li></ul><h2 id="创建和管理资源"><a href="#创建和管理资源" class="headerlink" title="创建和管理资源"></a>创建和管理资源</h2><h3 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h3><p>通过定义一个 Pod 的 YAML 文件，我们可以轻松创建一个简单的 Pod。以下是一个示例 Pod YAML 文件，命名为 example-pod.yaml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx:latest</span><br></pre></td></tr></table></figure><p>然后，通过以下命令创建 Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f example-pod.yaml</span><br></pre></td></tr></table></figure><h3 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h3><p>创建 Deployment 以便更好地管理 Pod 的副本数和更新。以下是一个简单的 Deployment YAML 文件，命名为 example-deployment.yaml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: example-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-container</span><br><span class="line">        image: nginx:latest</span><br></pre></td></tr></table></figure><p>通过以下命令创建 Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f example-deployment.yaml</span><br></pre></td></tr></table></figure><pre><code>1</code></pre><h3 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h3><p>为了将应用程序公开给其他 Pod 或外部流量，我们可以创建一个 Service。以下是一个简单的 Service YAML 文件，命名为 example-service.yaml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: example-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">  type: ClusterIP</span><br></pre></td></tr></table></figure><p>通过以下命令创建 Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f example-service.yaml</span><br></pre></td></tr></table></figure><h2 id="监视和调试"><a href="#监视和调试" class="headerlink" title="监视和调试"></a>监视和调试</h2><p>Minikube 提供了一些方便的命令和工具，帮助你监视和调试 Kubernetes 集群。</p><h3 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h3><p>可以使用以下命令查看 Minikube 集群的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube status</span><br></pre></td></tr></table></figure><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><p>通过以下命令可以查看 Minikube 集群的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube info</span><br></pre></td></tr></table></figure><h3 id="访问-Kubernetes-Dashboard"><a href="#访问-Kubernetes-Dashboard" class="headerlink" title="访问 Kubernetes Dashboard"></a>访问 Kubernetes Dashboard</h3><p>Minikube 集群提供了 Kubernetes Dashboard，通过以下命令可以访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><p>然后，可以在浏览器中打开 <a href="http://127.0.0.1:8001/">http://127.0.0.1:8001/</a> 来查看 Dashboard。</p><h3 id="使用-kubectl-命令"><a href="#使用-kubectl-命令" class="headerlink" title="使用 kubectl 命令"></a>使用 kubectl 命令</h3><p>可以使用 kubectl 命令与 Minikube 集群交互。例如，通过以下命令获取所有 Pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>或者查看 Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><h2 id="清理资源"><a href="#清理资源" class="headerlink" title="清理资源"></a>清理资源</h2><p>在完成开发和测试后，为了释放资源，我们可以清理 Minikube 集群中的资源。</p><h3 id="删除-Pod"><a href="#删除-Pod" class="headerlink" title="删除 Pod"></a>删除 Pod</h3><p>通过以下命令删除 Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod example-pod</span><br></pre></td></tr></table></figure><h3 id="删除-Deployment"><a href="#删除-Deployment" class="headerlink" title="删除 Deployment"></a>删除 Deployment</h3><p>通过以下命令删除 Deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment example-deployment</span><br></pre></td></tr></table></figure><h3 id="删除-Service"><a href="#删除-Service" class="headerlink" title="删除 Service"></a>删除 Service</h3><p>通过以下命令删除 Service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service example-service</span><br></pre></td></tr></table></figure><h3 id="停止-Minikube-集群"><a href="#停止-Minikube-集群" class="headerlink" title="停止 Minikube 集群"></a>停止 Minikube 集群</h3><p>最后，通过以下命令停止 Minikube 集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube stop</span><br></pre></td></tr></table></figure><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="使用本地-Docker-镜像"><a href="#使用本地-Docker-镜像" class="headerlink" title="使用本地 Docker 镜像"></a>使用本地 Docker 镜像</h3><p>如果你已经在本地构建了 Docker 镜像，并想在 Minikube 中使用它，可以通过以下步骤实现：</p><pre><code>设置 Minikube 使用本地 Docker 镜像：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure><pre><code>使用 docker build 构建你的镜像，并在 Pod 或 Deployment 中引用该镜像。</code></pre><h3 id="使用-Helm-管理应用"><a href="#使用-Helm-管理应用" class="headerlink" title="使用 Helm 管理应用"></a>使用 Helm 管理应用</h3><p>Helm 是 Kubernetes 的包管理工具，可以简化应用的部署和管理。以下是使用 Helm 部署一个 Nginx 应用的步骤：</p><pre><code>安装 Helm：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash</span><br></pre></td></tr></table></figure><pre><code>添加 Helm 仓库：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm repo add stable https://charts.helm.sh/stable</span><br></pre></td></tr></table></figure><pre><code>安装 Nginx Chart：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install nginx-demo stable/nginx-ingress</span><br></pre></td></tr></table></figure><h3 id="使用-Persistent-Volumes"><a href="#使用-Persistent-Volumes" class="headerlink" title="使用 Persistent Volumes"></a>使用 Persistent Volumes</h3><p>在 Minikube 中，你可以使用 Persistent Volumes（PV）和 Persistent Volume Claims（PVC）来实现数据的持久化存储。以下是一个简单的 PVC 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mypvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minikube的安装</title>
      <link href="/posts/4a17b502.html"/>
      <url>/posts/4a17b502.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Minikube 是一个用于在本地开发环境中运行 Kubernetes 集群的工具。它允许开发人员在单个节点上体验 Kubernetes，无需配置复杂的生产环境。本指南将详细介绍在 Windows、CentOS 和 Ubuntu 系统上安装 Minikube 的步骤。</p><h2 id="Windows-系统安装"><a href="#Windows-系统安装" class="headerlink" title="Windows 系统安装"></a>Windows 系统安装</h2><h3 id="步骤-1：安装-Hypervisor"><a href="#步骤-1：安装-Hypervisor" class="headerlink" title="步骤 1：安装 Hypervisor"></a>步骤 1：安装 Hypervisor</h3><p>Minikube 需要使用 Hypervisor 来创建虚拟机。推荐使用 Hyper-V 或 VirtualBox。以下是安装 Hyper-V 的步骤：</p><p>打开 PowerShell 作为管理员，并运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-All</span><br></pre></td></tr></table></figure><p>重启计算机以应用更改。</p><h3 id="步骤-2：安装-kubectl"><a href="#步骤-2：安装-kubectl" class="headerlink" title="步骤 2：安装 kubectl"></a>步骤 2：安装 kubectl</h3><p>在 PowerShell 中运行以下命令安装 kubectl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco install kubernetes-cli</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-3：安装-Minikube"><a href="#步骤-3：安装-Minikube" class="headerlink" title="步骤 3：安装 Minikube"></a>步骤 3：安装 Minikube</h3><p>安装 Chocolatey（如果尚未安装），在管理员权限的 PowerShell 中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco install minikube</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br></pre></td></tr></table></figure><h3 id="步骤-4：启动-Minikube"><a href="#步骤-4：启动-Minikube" class="headerlink" title="步骤 4：启动 Minikube"></a>步骤 4：启动 Minikube</h3><p>运行以下命令启动 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --driver=hyperv</span><br></pre></td></tr></table></figure><p>现在，Minikube 将在 Hyper-V 中创建一个虚拟机，并启动 Kubernetes 集群。</p><h2 id="CentOS-系统安装"><a href="#CentOS-系统安装" class="headerlink" title="CentOS 系统安装"></a>CentOS 系统安装</h2><h3 id="步骤-1：安装-Hypervisor-1"><a href="#步骤-1：安装-Hypervisor-1" class="headerlink" title="步骤 1：安装 Hypervisor"></a>步骤 1：安装 Hypervisor</h3><p>Minikube 可以使用 VirtualBox 或 KVM 作为 Hypervisor。以下是安装 KVM 的步骤：</p><p>安装 KVM 和相关组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y qemu-kvm libvirt virt-install bridge-utils</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动 libvirtd 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start libvirtd</span><br><span class="line">sudo systemctl enable libvirtd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将当前用户添加到 libvirt 和 kvm 用户组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG libvirt $(whoami)</span><br><span class="line">sudo usermod -aG kvm $(whoami)</span><br></pre></td></tr></table></figure><p>重新登录以应用更改。</p><h3 id="步骤-2：安装-kubectl-1"><a href="#步骤-2：安装-kubectl-1" class="headerlink" title="步骤 2：安装 kubectl"></a>步骤 2：安装 kubectl</h3><p>安装 kubectl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y kubectl</span><br></pre></td></tr></table></figure><h3 id="步骤-3：安装-Minikube-1"><a href="#步骤-3：安装-Minikube-1" class="headerlink" title="步骤 3：安装 Minikube"></a>步骤 3：安装 Minikube</h3><p>下载并安装 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm</span><br><span class="line">sudo dnf install -y minikube-latest.x86_64.rpm</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br></pre></td></tr></table></figure><h3 id="步骤-4：启动-Minikube-1"><a href="#步骤-4：启动-Minikube-1" class="headerlink" title="步骤 4：启动 Minikube"></a>步骤 4：启动 Minikube</h3><p>运行以下命令启动 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --driver=kvm2</span><br></pre></td></tr></table></figure><p>现在，Minikube 将在 KVM 中创建一个虚拟机，并启动 Kubernetes 集群。</p><h2 id="Ubuntu-系统安装"><a href="#Ubuntu-系统安装" class="headerlink" title="Ubuntu 系统安装"></a>Ubuntu 系统安装</h2><h3 id="步骤-1：安装-Hypervisor-2"><a href="#步骤-1：安装-Hypervisor-2" class="headerlink" title="步骤 1：安装 Hypervisor"></a>步骤 1：安装 Hypervisor</h3><p>Minikube 可以使用 VirtualBox 或 KVM 作为 Hypervisor。以下是安装 VirtualBox 的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y virtualbox</span><br></pre></td></tr></table></figure><h3 id="步骤-2：安装-kubectl-2"><a href="#步骤-2：安装-kubectl-2" class="headerlink" title="步骤 2：安装 kubectl"></a>步骤 2：安装 kubectl</h3><p>安装 kubectl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install kubectl --classic</span><br></pre></td></tr></table></figure><h3 id="步骤-3：安装-Minikube-2"><a href="#步骤-3：安装-Minikube-2" class="headerlink" title="步骤 3：安装 Minikube"></a>步骤 3：安装 Minikube</h3><p>下载并安装 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line">sudo install minikube-linux-amd64 /usr/local/bin/minikube</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br></pre></td></tr></table></figure><h3 id="步骤-4：启动-Minikube-2"><a href="#步骤-4：启动-Minikube-2" class="headerlink" title="步骤 4：启动 Minikube"></a>步骤 4：启动 Minikube</h3><p>运行以下命令启动 Minikube：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --driver=virtualbox</span><br></pre></td></tr></table></figure><p>现在，Minikube 将在 VirtualBox 中创建一个虚拟机，并启动 Kubernetes 集群。<br>验证 Minikube 安装</p><p>无论在哪个系统上，都可以使用以下命令验证 Minikube 的安装和运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p>如果一切顺利，你应该看到一个节点处于 “Ready” 状态，表示 Minikube 集群已成功安装并运行。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（五）- 路由&amp;&amp;中间件</title>
      <link href="/posts/773215c7.html"/>
      <url>/posts/773215c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gin框架学习（五）-路由-中间件"><a href="#Gin框架学习（五）-路由-中间件" class="headerlink" title="Gin框架学习（五）- 路由&amp;&amp;中间件"></a>Gin框架学习（五）- 路由&amp;&amp;中间件</h1><h1 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h1><h2 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title class_">Any</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title class_">NoRoute</span>(<span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusNotFound</span>, <span class="string">&quot;views/404.html&quot;</span>, nil)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h2><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>&#123;&#125;</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>&#123;&#125;</code>包裹功能上没什么区别。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">userGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">userGroup.<span class="title function_">GET</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">userGroup.<span class="title function_">POST</span>(<span class="string">&quot;/login&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/cart&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">POST</span>(<span class="string">&quot;/checkout&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由组也是支持嵌套的，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/cart&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">shopGroup.<span class="title function_">POST</span>(<span class="string">&quot;/checkout&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line"><span class="comment">// 嵌套路由组</span></span><br><span class="line">xx := shopGroup.<span class="title class_">Group</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">xx.<span class="title function_">GET</span>(<span class="string">&quot;/oo&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>Gin框架中的路由使用的是<code>httprouter</code>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h1 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h1><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><h2 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h2><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。</p><h3 id="记录接口耗时的中间件"><a href="#记录接口耗时的中间件" class="headerlink" title="记录接口耗时的中间件"></a>记录接口耗时的中间件</h3><p>例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计耗时请求耗时的中间件</span></span><br><span class="line">func <span class="title class_">StatCost</span>() gin.<span class="property">HandlerFunc</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">start := time.<span class="title class_">Now</span>()</span><br><span class="line">c.<span class="title class_">Set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">c.<span class="title class_">Next</span>()</span><br><span class="line"><span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line"><span class="comment">// 计算耗时</span></span><br><span class="line">cost := time.<span class="title class_">Since</span>(start)</span><br><span class="line">log.<span class="title class_">Println</span>(cost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录响应体的中间件"><a href="#记录响应体的中间件" class="headerlink" title="记录响应体的中间件"></a>记录响应体的中间件</h3><p>我们有时候可能会想要记录下某些情况下返回给客户端的响应数据，这个时候就可以编写一个中间件来搞定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type bodyLogWriter struct &#123;</span><br><span class="line">gin.<span class="property">ResponseWriter</span>               <span class="comment">// 嵌入gin框架ResponseWriter</span></span><br><span class="line">body               *bytes.<span class="property">Buffer</span> <span class="comment">// 我们记录用的response</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 写入响应体数据</span></span><br><span class="line">func (w bodyLogWriter) <span class="title class_">Write</span>(b []byte) (int, error) &#123;</span><br><span class="line">w.<span class="property">body</span>.<span class="title class_">Write</span>(b)                  <span class="comment">// 我们记录一份</span></span><br><span class="line"><span class="keyword">return</span> w.<span class="property">ResponseWriter</span>.<span class="title class_">Write</span>(b) <span class="comment">// 真正写入响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件</span></span><br><span class="line"><span class="comment">// https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin</span></span><br><span class="line">func <span class="title function_">ginBodyLogMiddleware</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">blw := &amp;bodyLogWriter&#123;<span class="attr">body</span>: bytes.<span class="title class_">NewBuffer</span>([]byte&#123;&#125;), <span class="title class_">ResponseWriter</span>: c.<span class="property">Writer</span>&#125;</span><br><span class="line">c.<span class="property">Writer</span> = blw <span class="comment">// 使用我们自定义的类型替换默认的</span></span><br><span class="line"></span><br><span class="line">c.<span class="title class_">Next</span>() <span class="comment">// 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;Response body: &quot;</span> + blw.<span class="property">body</span>.<span class="title class_">String</span>()) <span class="comment">// 事后按需记录返回的响应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域中间件cors"><a href="#跨域中间件cors" class="headerlink" title="跨域中间件cors"></a>跨域中间件cors</h3><p>推荐使用社区的<a href="https://github.com/gin-contrib/cors"><code>https://github.com/gin-contrib/cors</code></a> 库，一行代码解决前后端分离架构下的跨域问题。 该中间件需要注册在业务处理函数前面。</p><p>这个库支持各种常用的配置项，具体使用方法如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router := gin.<span class="title class_">Default</span>()</span><br><span class="line">  <span class="comment">// CORS for https://foo.com and https://github.com origins, allowing:</span></span><br><span class="line">  <span class="comment">// - PUT and PATCH methods</span></span><br><span class="line">  <span class="comment">// - Origin header</span></span><br><span class="line">  <span class="comment">// - Credentials share</span></span><br><span class="line">  <span class="comment">// - Preflight requests cached for 12 hours</span></span><br><span class="line">  router.<span class="title class_">Use</span>(cors.<span class="title class_">New</span>(cors.<span class="property">Config</span>&#123;</span><br><span class="line">    <span class="title class_">AllowOrigins</span>:     []string&#123;<span class="string">&quot;https://foo.com&quot;</span>&#125;,  <span class="comment">// 允许跨域发来请求的网站</span></span><br><span class="line">    <span class="title class_">AllowMethods</span>:     []string&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>,  <span class="string">&quot;OPTIONS&quot;</span>&#125;,  <span class="comment">// 允许的请求方法</span></span><br><span class="line">    <span class="title class_">AllowHeaders</span>:     []string&#123;<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>&#125;,</span><br><span class="line">    <span class="title class_">ExposeHeaders</span>:    []string&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,</span><br><span class="line">    <span class="title class_">AllowCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title class_">AllowOriginFunc</span>: <span class="title function_">func</span>(origin string) bool &#123;  <span class="comment">// 自定义过滤源站的方法</span></span><br><span class="line">      <span class="keyword">return</span> origin == <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title class_">MaxAge</span>: <span class="number">12</span> * time.<span class="property">Hour</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">  router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router := gin.<span class="title class_">Default</span>()</span><br><span class="line">  <span class="comment">// same as</span></span><br><span class="line">  <span class="comment">// config := cors.DefaultConfig()</span></span><br><span class="line">  <span class="comment">// config.AllowAllOrigins = true</span></span><br><span class="line">  <span class="comment">// router.Use(cors.New(config))</span></span><br><span class="line">  router.<span class="title class_">Use</span>(cors.<span class="title class_">Default</span>())</span><br><span class="line">  router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><h3 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.<span class="title class_">New</span>()</span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.<span class="title class_">Use</span>(<span class="title class_">StatCost</span>())</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">name := c.<span class="title class_">MustGet</span>(<span class="string">&quot;name&quot;</span>).(string) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.<span class="title class_">Println</span>(name)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test2&quot;</span>, <span class="title class_">StatCost</span>(), <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">name := c.<span class="title class_">MustGet</span>(<span class="string">&quot;name&quot;</span>).(string) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.<span class="title class_">Println</span>(name)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="位路由组注册中间件"><a href="#位路由组注册中间件" class="headerlink" title="位路由组注册中间件"></a>位路由组注册中间件</h3><p>为路由组注册中间件有以下两种写法。</p><p>写法1：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>, <span class="title class_">StatCost</span>())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.<span class="title class_">Group</span>(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.<span class="title class_">Use</span>(<span class="title class_">StatCost</span>())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h2><h3 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h3><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h3 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h3><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（四）- 文件上传&amp;&amp;重定向</title>
      <link href="/posts/773215c7.html"/>
      <url>/posts/773215c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h2><p>文件上传前端页面代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;上传文件示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>后端gin框架部分代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/upload&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 单个文件</span></span><br><span class="line">file, err := c.<span class="title class_">FormFile</span>(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusInternalServerError</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: err.<span class="title class_">Error</span>(),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.<span class="title class_">Println</span>(file.<span class="property">Filename</span>)</span><br><span class="line">dst := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;C:/tmp/%s&quot;</span>, file.<span class="property">Filename</span>)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.<span class="title class_">SaveUploadedFile</span>(file, dst)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.<span class="property">Filename</span>),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/upload&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.<span class="title class_">MultipartForm</span>()</span><br><span class="line">files := form.<span class="property">File</span>[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, file := range files &#123;</span><br><span class="line">log.<span class="title class_">Println</span>(file.<span class="property">Filename</span>)</span><br><span class="line">dst := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;C:/tmp/%s_%d&quot;</span>, file.<span class="property">Filename</span>, index)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.<span class="title class_">SaveUploadedFile</span>(file, dst)</span><br><span class="line">&#125;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="title function_">len</span>(files)),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h2><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title class_">Redirect</span>(http.<span class="property">StatusMovedPermanently</span>, <span class="string">&quot;http://www.sogo.com/&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>路由重定向，使用<code>HandleContext</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">    <span class="comment">// 指定重定向的URL</span></span><br><span class="line">    c.<span class="property">Request</span>.<span class="property">URL</span>.<span class="property">Path</span> = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.<span class="title class_">HandleContext</span>(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/test2&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">    c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（三）- 获取参数</title>
      <link href="/posts/773215c7.html"/>
      <url>/posts/773215c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取querystring参数"><a href="#获取querystring参数" class="headerlink" title="获取querystring参数"></a><strong>获取querystring参数</strong></h2><p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。获取请求的querystring参数的方法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/user/search&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">username := c.<span class="title class_">DefaultQuery</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line"><span class="comment">//username := c.Query(&quot;username&quot;)</span></span><br><span class="line">address := c.<span class="title class_">Query</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取form参数"><a href="#获取form参数" class="headerlink" title="获取form参数"></a>获取form参数</h2><p>当前端请求的数据通过form表单提交时，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/user/search&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line"><span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)</span></span><br><span class="line">username := c.<span class="title class_">PostForm</span>(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.<span class="title class_">PostForm</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取JSON参数"><a href="#获取JSON参数" class="headerlink" title="获取JSON参数"></a>获取JSON参数</h2><p>当前端请求的数据通过JSON提交时，例如向<code>/json</code>发送一个JSON格式的POST请求，则获取请求参数的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="title function_">POST</span>(<span class="string">&quot;/json&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 注意：下面为了举例子方便，暂时忽略了错误处理</span></span><br><span class="line">b, _ := c.<span class="title class_">GetRawData</span>()  <span class="comment">// 从c.Request.Body读取请求数据</span></span><br><span class="line"><span class="comment">// 定义map或结构体</span></span><br><span class="line"><span class="keyword">var</span> m map[string]interface&#123;&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">_ = json.<span class="title class_">Unmarshal</span>(b, &amp;m)</span><br><span class="line"></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, m)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取path参数"><a href="#获取path参数" class="headerlink" title="获取path参数"></a>获取path参数</h2><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。获取请求URL路径中的参数的方式如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">username := c.<span class="title class_">Param</span>(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.<span class="title class_">Param</span>(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line">type <span class="title class_">Login</span> struct &#123;</span><br><span class="line"><span class="title class_">User</span>     string <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line"><span class="title class_">Password</span> string <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定JSON的示例 (&#123;&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;&#125;)</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/loginJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;login info:%#v\n&quot;</span>, login)</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">router.<span class="title function_">POST</span>(<span class="string">&quot;/loginForm&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/loginForm&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> login <span class="title class_">Login</span></span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="title class_">ShouldBind</span>(&amp;login); err == nil &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.<span class="property">User</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.<span class="property">Password</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusBadRequest</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;error&quot;</span>: err.<span class="title class_">Error</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">router.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p><ol><li>如果是 <code>GET</code> 请求，只使用 <code>Form</code> 绑定引擎（<code>query</code>）。</li><li>如果是 <code>POST</code> 请求，首先检查 <code>content-type</code> 是否为 <code>JSON</code> 或 <code>XML</code>，然后再使用 <code>Form</code>（<code>form-data</code>）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架学习（二）- Gin渲染</title>
      <link href="/posts/ba02eb07.html"/>
      <url>/posts/ba02eb07.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTML渲染"><a href="#HTML渲染" class="headerlink" title="HTML渲染"></a>HTML渲染</h2><p>我们首先定义一个存放模板文件的<code>templates</code>文件夹，然后在其内部按照业务分别定义一个<code>posts</code>文件夹和一个<code>users</code>文件夹。<code>posts/index.html</code>文件的内容如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define <span class="string">&quot;posts/index.html&quot;</span>&#125;&#125;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>users/index.html</code>文件的内容如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define <span class="string">&quot;users/index.html&quot;</span>&#125;&#125;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title class_">LoadHTMLGlob</span>(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"><span class="comment">//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/posts/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;posts/index.html&quot;</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;posts/index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;users/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;users/index.html&quot;</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;users/index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义模板函数"><a href="#自定义模板函数" class="headerlink" title="自定义模板函数"></a><strong>自定义模板函数</strong></h2><p>定义一个不转义相应内容的<code>safe</code>模板函数如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">router := gin.<span class="title class_">Default</span>()</span><br><span class="line">router.<span class="title class_">SetFuncMap</span>(template.<span class="property">FuncMap</span>&#123;</span><br><span class="line"><span class="string">&quot;safe&quot;</span>: <span class="title function_">func</span>(str string) template.<span class="property">HTML</span>&#123;</span><br><span class="line"><span class="keyword">return</span> template.<span class="title function_">HTML</span>(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title class_">LoadHTMLFiles</span>(<span class="string">&quot;./index.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;index.tmpl&quot;</span>, <span class="string">&quot;&lt;a href=&#x27;https://liwenzhou.com&#x27;&gt;李文周的博客&lt;/a&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>index.tmpl</code>中使用定义好的<code>safe</code>模板函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>修改模板引擎的标识符<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; . | safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h2><p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用<code>gin.Static</code>方法即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="title class_">Static</span>(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line">r.<span class="title class_">LoadHTMLGlob</span>(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用模版继承"><a href="#使用模版继承" class="headerlink" title="使用模版继承"></a>使用模版继承</h2><p>Gin框架默认都是使用单模板，如果需要使用<code>block template</code>功能，可以通过<code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p><p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中<code>home.tmpl</code>和<code>index.tmpl</code>继承了<code>base.tmpl</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">templates</span><br><span class="line">├── includes</span><br><span class="line">│   ├── home.<span class="property">tmpl</span></span><br><span class="line">│   └── index.<span class="property">tmpl</span></span><br><span class="line">├── layouts</span><br><span class="line">│   └── base.<span class="property">tmpl</span></span><br><span class="line">└── scripts.<span class="property">tmpl</span></span><br></pre></td></tr></table></figure><p>然后我们定义一个<code>loadTemplates</code>函数如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">loadTemplates</span>(templatesDir string) multitemplate.<span class="property">Renderer</span> &#123;</span><br><span class="line">r := multitemplate.<span class="title class_">NewRenderer</span>()</span><br><span class="line">layouts, err := filepath.<span class="title class_">Glob</span>(templatesDir + <span class="string">&quot;/layouts/*.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="title function_">panic</span>(err.<span class="title class_">Error</span>())</span><br><span class="line">&#125;</span><br><span class="line">includes, err := filepath.<span class="title class_">Glob</span>(templatesDir + <span class="string">&quot;/includes/*.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="title function_">panic</span>(err.<span class="title class_">Error</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为layouts/和includes/目录生成 templates map</span></span><br><span class="line"><span class="keyword">for</span> _, include := range includes &#123;</span><br><span class="line">layoutCopy := <span class="title function_">make</span>([]string, <span class="title function_">len</span>(layouts))</span><br><span class="line"><span class="title function_">copy</span>(layoutCopy, layouts)</span><br><span class="line">files := <span class="title function_">append</span>(layoutCopy, include)</span><br><span class="line">r.<span class="title class_">AddFromFiles</span>(filepath.<span class="title class_">Base</span>(include), files...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>函数中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">indexFunc</span>(<span class="params">c *gin.Context</span>)&#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;index.tmpl&quot;</span>, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">homeFunc</span>(<span class="params">c *gin.Context</span>)&#123;</span><br><span class="line">c.<span class="title function_">HTML</span>(http.<span class="property">StatusOK</span>, <span class="string">&quot;home.tmpl&quot;</span>, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line">r.<span class="property">HTMLRender</span> = <span class="title function_">loadTemplates</span>(<span class="string">&quot;./templates&quot;</span>)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/index&quot;</span>, indexFunc)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/home&quot;</span>, homeFunc)</span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充文件路径处理"><a href="#补充文件路径处理" class="headerlink" title="补充文件路径处理"></a><strong>补充文件路径处理</strong></h2><p>关于模板文件和静态文件的路径，我们需要根据公司&#x2F;项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">getCurrentPath</span>() string &#123;</span><br><span class="line"><span class="keyword">if</span> ex, err := os.<span class="title class_">Executable</span>(); err == nil &#123;</span><br><span class="line"><span class="keyword">return</span> filepath.<span class="title class_">Dir</span>(ex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON渲染"><a href="#JSON渲染" class="headerlink" title="JSON渲染"></a>JSON渲染</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/someJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/moreJSON&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg struct &#123;</span><br><span class="line"><span class="title class_">Name</span>    string <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line"><span class="title class_">Message</span> string</span><br><span class="line"><span class="title class_">Age</span>     int</span><br><span class="line">&#125;</span><br><span class="line">msg.<span class="property">Name</span> = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.<span class="property">Message</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.<span class="property">Age</span> = <span class="number">18</span></span><br><span class="line">c.<span class="title class_">JSON</span>(http.<span class="property">StatusOK</span>, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML渲染"><a href="#XML渲染" class="headerlink" title="XML渲染"></a>XML渲染</h2><p>注意需要使用具名的结构体类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/someXML&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.<span class="title function_">XML</span>(http.<span class="property">StatusOK</span>, gin.<span class="property">H</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/moreXML&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line">type <span class="title class_">MessageRecord</span> struct &#123;</span><br><span class="line"><span class="title class_">Name</span>    string</span><br><span class="line"><span class="title class_">Message</span> string</span><br><span class="line"><span class="title class_">Age</span>     int</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg <span class="title class_">MessageRecord</span></span><br><span class="line">msg.<span class="property">Name</span> = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.<span class="property">Message</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.<span class="property">Age</span> = <span class="number">18</span></span><br><span class="line">c.<span class="title function_">XML</span>(http.<span class="property">StatusOK</span>, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.<span class="title class_">Run</span>(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架（一）- Gin入门</title>
      <link href="/posts/fb160171.html"/>
      <url>/posts/fb160171.html</url>
      
        <content type="html"><![CDATA[<h2 id="Gin框架介绍"><a href="#Gin框架介绍" class="headerlink" title="Gin框架介绍"></a>Gin框架介绍</h2><p>Go世界里最流行的Web框架，Github上有<code>32K+</code>star。基于httprouter开发的Web框架。<br>中文文档齐全，简单易用的轻量级框架。</p><h2 id="Gin框架的安装与使用"><a href="#Gin框架的安装与使用" class="headerlink" title="Gin框架的安装与使用"></a>Gin框架的安装与使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载并安装<code>Gin</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.<span class="property">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="第一个Gin示例"><a href="#第一个Gin示例" class="headerlink" title="第一个Gin示例"></a>第一个Gin示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">r := gin.<span class="title class_">Default</span>()</span><br><span class="line"><span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line"><span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">r.<span class="title function_">GET</span>(<span class="string">&quot;/hello&quot;</span>, <span class="title function_">func</span>(<span class="params">c *gin.Context</span>) &#123;</span><br><span class="line"><span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">c.<span class="title class_">JSON</span>(<span class="number">200</span>, gin.<span class="property">H</span>&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">r.<span class="title class_">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之并发(三)</title>
      <link href="/posts/4a17b0021.html"/>
      <url>/posts/4a17b0021.html</url>
      
        <content type="html"><![CDATA[<h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 goroutine 将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for&#123;</span><br><span class="line">    // 尝试从ch1接收值</span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    // 尝试从ch2接收值</span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了select关键字，使用它可以同时响应多个通道的操作。</p><p>Select 的使用方式类似于之前学到的 switch 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。select 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。具体格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case &lt;-ch1:</span><br><span class="line">//...</span><br><span class="line">case data := &lt;-ch2:</span><br><span class="line">//...</span><br><span class="line">case ch3 &lt;- 10:</span><br><span class="line">//...</span><br><span class="line">default:</span><br><span class="line">//默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Select 语句具有以下特点。</p><ul><li>可处理一个或多个 channel 的发送&#x2F;接收操作。</li><li>如果多个 case 同时满足，select 会随机选择一个执行。</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出。</li></ul><p>下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 1)</span><br><span class="line">for i := 1; i &lt;= 10; i++ &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line">case ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，进入 for 循环后：</p><ul><li>第一次循环时 i &#x3D; 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以x :&#x3D; &lt;-ch 这个 case 分支不满足，而ch &lt;- i这个分支可以执行，会把1发送到通道中，结束本次 for 循环；</li><li>第二次 for 循环时，i &#x3D; 2，由于通道缓冲区已满，所以ch &lt;- i这个分支不满足，而x :&#x3D; &lt;-ch这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1；</li><li>后续的 for 循环以此类推会依次打印出3、5、7、9。</li></ul><h2 id="通道误用示例"><a href="#通道误用示例" class="headerlink" title="通道误用示例"></a>通道误用示例</h2><p>接下来，我们将展示两个因误用通道导致程序出现 bug 的代码片段，希望能够加深读者对通道操作的印象。<br>示例1</p><p>各位读者可以查看以下示例代码，尝试找出其中存在的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// demo1 通道误用导致的bug</span><br><span class="line">func demo1() &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">ch := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(ch)</span><br><span class="line"></span><br><span class="line">wg.Add(3)</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">task := &lt;-ch</span><br><span class="line">// 这里假设对接收的数据执行某些操作</span><br><span class="line">fmt.Println(task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为task :&#x3D; &lt;- ch的接收操作在通道被关闭后会一直接收到零值，而不会退出。此处的接收操作应该使用task, ok :&#x3D; &lt;- ch ，通过判断布尔值ok为假时退出；或者使用select 来处理通道。<br>示例2</p><p>各位读者阅读下方代码片段，尝试找出其中存在的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// demo2 通道误用导致的bug</span><br><span class="line">func demo2() &#123;</span><br><span class="line">ch := make(chan string)</span><br><span class="line">go func() &#123;</span><br><span class="line">// 这里假设执行一些耗时的操作</span><br><span class="line">time.Sleep(3 * time.Second)</span><br><span class="line">ch &lt;- &quot;job result&quot;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case result := &lt;-ch:</span><br><span class="line">fmt.Println(result)</span><br><span class="line">case &lt;-time.After(time.Second): // 较小的超时时间</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段可能导致 goroutine 泄露（goroutine 并未按预期退出并销毁）。由于 select 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 goroutine 中的ch &lt;- “job result”操作会一直阻塞，最终导致 goroutine 泄露。</p><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。</p><p>我们用下面的代码演示一个数据竞争的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">x int64</span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup // 等待组</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// add 对全局变量x执行5000次加1操作</span><br><span class="line">func add() &#123;</span><br><span class="line">for i := 0; i &lt; 5000; i++ &#123;</span><br><span class="line">x = x + 1</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2)</span><br><span class="line"></span><br><span class="line">go add()</span><br><span class="line">go add()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？</p><p>在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的x变量时就会存在数据竞争，某个 goroutine 中对全局变量x的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用sync包中提供的Mutex类型来实现互斥锁。</p><p>sync.Mutex提供了两个方法供我们使用。<br>方法名 功能<br>func (m *Mutex) Lock() 获取互斥锁<br>func (m *Mutex) Unlock() 释放互斥锁</p><p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量x，从而修复上面代码中的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// sync.Mutex</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">x int64</span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup // 等待组</span><br><span class="line"></span><br><span class="line">m sync.Mutex // 互斥锁</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// add 对全局变量x执行5000次加1操作</span><br><span class="line">func add() &#123;</span><br><span class="line">for i := 0; i &lt; 5000; i++ &#123;</span><br><span class="line">m.Lock() // 修改x前加锁</span><br><span class="line">x = x + 1</span><br><span class="line">m.Unlock() // 改完解锁</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2)</span><br><span class="line"></span><br><span class="line">go add()</span><br><span class="line">go add()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。</p><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p><h2 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h2><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用sync包中的RWMutex类型。</p><p>sync.RWMutex提供了以下5个方法。<br>方法名 功能<br>func (rw *RWMutex) Lock() 获取写锁<br>func (rw *RWMutex) Unlock() 释放写锁<br>func (rw *RWMutex) RLock() 获取读锁<br>func (rw *RWMutex) RUnlock() 释放读锁<br>func (rw *RWMutex) RLocker() Locker 返回一个实现Locker接口的读写锁</p><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><p>下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">x       int64</span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">mutex   sync.Mutex</span><br><span class="line">rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// writeWithLock 使用互斥锁的写操作</span><br><span class="line">func writeWithLock() &#123;</span><br><span class="line">mutex.Lock() // 加互斥锁</span><br><span class="line">x = x + 1</span><br><span class="line">time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒</span><br><span class="line">mutex.Unlock()                    // 解互斥锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// readWithLock 使用互斥锁的读操作</span><br><span class="line">func readWithLock() &#123;</span><br><span class="line">mutex.Lock()                 // 加互斥锁</span><br><span class="line">time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒</span><br><span class="line">mutex.Unlock()               // 释放互斥锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// writeWithLock 使用读写互斥锁的写操作</span><br><span class="line">func writeWithRWLock() &#123;</span><br><span class="line">rwMutex.Lock() // 加写锁</span><br><span class="line">x = x + 1</span><br><span class="line">time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒</span><br><span class="line">rwMutex.Unlock()                  // 释放写锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// readWithRWLock 使用读写互斥锁的读操作</span><br><span class="line">func readWithRWLock() &#123;</span><br><span class="line">rwMutex.RLock()              // 加读锁</span><br><span class="line">time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒</span><br><span class="line">rwMutex.RUnlock()            // 释放读锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func do(wf, rf func(), wc, rc int) &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">// wc个并发写操作</span><br><span class="line">for i := 0; i &lt; wc; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go wf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  rc个并发读操作</span><br><span class="line">for i := 0; i &lt; rc; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go rf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">cost := time.Since(start)</span><br><span class="line">fmt.Printf(&quot;x:%v cost:%v\n&quot;, x, cost)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用互斥锁，10并发写，1000并发读</span><br><span class="line">do(writeWithLock, readWithLock, 10, 1000) // x:10 cost:1.466500951s</span><br><span class="line"></span><br><span class="line">// 使用读写互斥锁，10并发写，1000并发读</span><br><span class="line">do(writeWithRWLock, readWithRWLock, 10, 1000) // x:10 cost:117.207592ms</span><br></pre></td></tr></table></figure><p>从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。</p><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：<br>方法名 功能<br>func (wg * WaitGroup) Add(delta int) 计数器+delta<br>(wg *WaitGroup) Done() 计数器-1<br>(wg *WaitGroup) Wait() 阻塞直到计数器变为0</p><p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。</p><p>我们利用sync.WaitGroup将上面的代码优化一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;Hello Goroutine!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go hello() // 启动另外一个goroutine去执行hello函数</span><br><span class="line">fmt.Println(&quot;main goroutine done!&quot;)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意sync.WaitGroup是一个结构体，进行参数传递的时候要传递指针。</p><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案——sync.Once，sync.Once只有一个Do方法，其签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (o *Once) Do(f func())</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果要执行的函数f需要传递参数就需要搭配闭包来使用。<br>加载配置文件示例</p><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var icons map[string]image.Image</span><br><span class="line"></span><br><span class="line">func loadIcons() &#123;</span><br><span class="line">icons = map[string]image.Image&#123;</span><br><span class="line">&quot;left&quot;:  loadIcon(&quot;left.png&quot;),</span><br><span class="line">&quot;up&quot;:    loadIcon(&quot;up.png&quot;),</span><br><span class="line">&quot;right&quot;: loadIcon(&quot;right.png&quot;),</span><br><span class="line">&quot;down&quot;:  loadIcon(&quot;down.png&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Icon 被多个goroutine调用时不是并发安全的</span><br><span class="line">func Icon(name string) image.Image &#123;</span><br><span class="line">if icons == nil &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line">return icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><p>func loadIcons() {<br>    icons &#x3D; make(map[string]image.Image)<br>    icons[“left”] &#x3D; loadIcon(“left.png”)<br>    icons[“up”] &#x3D; loadIcon(“up.png”)<br>    icons[“right”] &#x3D; loadIcon(“right.png”)<br>    icons[“down”] &#x3D; loadIcon(“down.png”)<br>}</p><p>在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。</p><p>使用sync.Once改造的示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var icons map[string]image.Image</span><br><span class="line"></span><br><span class="line">var loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line">func loadIcons() &#123;</span><br><span class="line">icons = map[string]image.Image&#123;</span><br><span class="line">&quot;left&quot;:  loadIcon(&quot;left.png&quot;),</span><br><span class="line">&quot;up&quot;:    loadIcon(&quot;up.png&quot;),</span><br><span class="line">&quot;right&quot;: loadIcon(&quot;right.png&quot;),</span><br><span class="line">&quot;down&quot;:  loadIcon(&quot;down.png&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Icon 是并发安全的</span><br><span class="line">func Icon(name string) image.Image &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line">return icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发安全的单例模式</p><p>下面是借助sync.Once实现的并发安全的单例模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package singleton</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type singleton struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">var instance *singleton</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *singleton &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var m = make(map[string]int)</span><br><span class="line"></span><br><span class="line">func get(key string) int &#123;</span><br><span class="line">return m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func set(key string, value int) &#123;</span><br><span class="line">m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">set(key, n)</span><br><span class="line">fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, get(key))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后执行，会报出fatal error: concurrent map writes错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。</p><p>像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版 map——sync.Map。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。<br>方法名 功能<br>func (m *Map) Store(key, value interface{}) 存储key-value数据<br>func (m *Map) Load(key interface{}) (value interface{}, ok bool) 查询key对应的value<br>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) 查询或存储key对应的value<br>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) 查询并删除key<br>func (m *Map) Delete(key interface{}) 删除key<br>func (m *Map) Range(f func(key, value interface{}) bool) 对map中的每个key-value依次调用f</p><p>下面的代码示例演示了并发读写sync.Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 并发安全的map</span><br><span class="line">var m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">// 对m执行20个并发的读写操作</span><br><span class="line">for i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)         // 存储key-value</span><br><span class="line">value, _ := m.Load(key) // 根据key取值</span><br><span class="line">fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库sync&#x2F;atomic提供。<br>atomic包<br>方法 解释<br>func LoadInt32(addr *int32) (val int32)func LoadInt64(addr *int64) (val int64)func LoadUint32(addr *uint32) (val uint32)func LoadUint64(addr *uint64) (val uint64)func LoadUintptr(addr *uintptr) (val uintptr)func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) 读取操作<br>func StoreInt32(addr *int32, val int32)func StoreInt64(addr *int64, val int64)func StoreUint32(addr *uint32, val uint32)func StoreUint64(addr *uint64, val uint64)func StoreUintptr(addr *uintptr, val uintptr)func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) 写入操作<br>func AddInt32(addr *int32, delta int32) (new int32)func AddInt64(addr *int64, delta int64) (new int64)func AddUint32(addr *uint32, delta uint32) (new uint32)func AddUint64(addr *uint64, delta uint64) (new uint64)func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) 修改操作<br>func SwapInt32(addr *int32, new int32) (old int32)func SwapInt64(addr *int64, new int64) (old int64)func SwapUint32(addr *uint32, new uint32) (old uint32)func SwapUint64(addr *uint64, new uint64) (old uint64)func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) 交换操作<br>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) 比较并交换操作<br>示例</p><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;sync/atomic&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Counter interface &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 普通版</span><br><span class="line">type CommonCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c CommonCounter) Inc() &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c CommonCounter) Load() int64 &#123;</span><br><span class="line">return c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 互斥锁版</span><br><span class="line">type MutexCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *MutexCounter) Inc() &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line">defer m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *MutexCounter) Load() int64 &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line">defer m.lock.Unlock()</span><br><span class="line">return m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子操作版</span><br><span class="line">type AtomicCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AtomicCounter) Inc() &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AtomicCounter) Load() int64 &#123;</span><br><span class="line">return atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(c Counter) &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line">for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; // 非并发安全</span><br><span class="line">test(c1)</span><br><span class="line">c2 := MutexCounter&#123;&#125; // 使用互斥锁实现并发安全</span><br><span class="line">test(&amp;c2)</span><br><span class="line">c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高</span><br><span class="line">test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数&#x2F;类型实现同步更好。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之并发(三)</title>
      <link href="/posts/4a17b003.html"/>
      <url>/posts/4a17b003.html</url>
      
        <content type="html"><![CDATA[<hr><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言采用的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说 goroutine 是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h2 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h2><p>channel是 Go 语言中一种特有的类型。声明通道类型变量的格式如下：</p><pre><code>var 变量名称 chan 元素类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中：</span><br><span class="line">- chan：是关键字</span><br><span class="line">- 元素类型：是指通道中传递元素的类型</span><br><span class="line"></span><br><span class="line">举几个例子：</span><br></pre></td></tr></table></figure>var ch1 chan int   // 声明一个传递整型的通道var ch2 chan bool  // 声明一个传递布尔型的通道var ch3 chan []int // 声明一个传递int切片的通道<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## channel零值</span><br><span class="line">未初始化的通道类型变量其默认零值是nil。</span><br></pre></td></tr></table></figure>var ch chan intfmt.Println(ch) // &lt;nil&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 初始化channel</span><br><span class="line">声明的通道类型变量需要使用内置的make函数初始化之后才能使用。具体格式如下：</span><br></pre></td></tr></table></figure>make(chan 元素类型, [缓冲大小])<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其中：</span><br><span class="line">- channel的缓冲大小是可选的。</span><br><span class="line"></span><br><span class="line">举几个例子：</span><br></pre></td></tr></table></figure>ch4 := make(chan int)ch5 := make(chan bool, 1)  // 声明一个缓冲区大小为1的通道<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## channel操作</span><br><span class="line"></span><br><span class="line">通道共有发送（send）、接收(receive）和关闭（close）三种操作。而发送和接收操作都使用&lt;-符号。</span><br><span class="line"></span><br><span class="line">现在我们先使用以下语句定义一个通道：</span><br><span class="line"></span><br></pre></td></tr></table></figure>ch := make(chan int)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送：将一个值发送到通道中。</span><br></pre></td></tr></table></figure>ch &lt;- 10 // 把10发送到ch中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收：从一个通道中接收值。</span><br></pre></td></tr></table></figure>x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch       // 从ch中接收值，忽略结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭：我们通过调用内置的close函数来关闭通道。</span><br></pre></td></tr></table></figure>close(ch)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**注意：**一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</span><br><span class="line"></span><br><span class="line">关闭后的通道有以下特点：</span><br><span class="line"></span><br><span class="line">- 对一个关闭的通道再发送值就会导致 panic。</span><br><span class="line">- 对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class="line">- 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class="line">- 关闭一个已经关闭的通道会导致 panic。</span><br><span class="line"></span><br><span class="line">## 无缓冲的通道</span><br><span class="line"></span><br><span class="line">无缓冲的通道又称为阻塞的通道。我们来看一下如下代码片段。</span><br></pre></td></tr></table></figure>func main() &#123;    ch := make(chan int)    ch &lt;- 10    fmt.Println(&quot;发送成功&quot;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面这段代码能够通过编译，但是执行的时候会出现以下错误：</span><br></pre></td></tr></table></figure>fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main()        .../main.go:8 +0x54<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deadlock表示我们程序中的 goroutine 都被挂起导致程序死锁了。为什么会出现deadlock错误呢？</span><br><span class="line"></span><br><span class="line">因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。就像田径比赛中的4x100接力赛，想要完成交棒必须有一个能够接棒的运动员，否则只能等待。简单来说就是无缓冲的通道必须有至少一个接收方才能发送成功。</span><br><span class="line"></span><br><span class="line">上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？</span><br><span class="line"></span><br><span class="line">其中一种可行的方法是创建一个 goroutine 去接收值，例如：</span><br></pre></td></tr></table></figure>func recv(c chan int) &#123;    ret := &lt;-c    fmt.Println(&quot;接收成功&quot;, ret)&#125;func main() &#123;    ch := make(chan int)    go recv(ch) // 创建一个 goroutine 从通道接收值    ch &lt;- 10    fmt.Println(&quot;发送成功&quot;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先无缓冲通道ch上的发送操作会阻塞，直到另一个 goroutine 在该通道上执行接收操作，这时数字10才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方所在的 goroutine 将阻塞，直到 main goroutine 中向该通道发送数字10。</span><br><span class="line"></span><br><span class="line">使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为同步通道。</span><br><span class="line"></span><br><span class="line">## 有缓冲的通道</span><br><span class="line"></span><br><span class="line">还有另外一种解决上面死锁问题的方法，那就是使用有缓冲区的通道。我们可以在使用 make 函数初始化通道时，可以为其指定通道的容量，例如：</span><br></pre></td></tr></table></figure>func main() &#123;    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道    ch &lt;- 10    fmt.Println(&quot;发送成功&quot;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</span><br><span class="line"></span><br><span class="line">我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</span><br><span class="line">## 多返回值模式</span><br><span class="line"></span><br><span class="line">当向通道中发送完数据时，我们可以通过close函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？</span><br><span class="line"></span><br><span class="line">对一个通道执行接收操作时支持使用如下多返回值模式。</span><br></pre></td></tr></table></figure>value, ok := &lt;- ch<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中：</span><br><span class="line">- value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。</span><br><span class="line">- ok：通道ch关闭时返回 false，否则返回 true。</span><br><span class="line"></span><br><span class="line">下面代码片段中的f2函数会循环从通道ch中接收所有值，直到通道被关闭后退出。</span><br></pre></td></tr></table></figure>func f2(ch chan int) &#123;    for &#123;        v, ok := &lt;-ch        if !ok &#123;            fmt.Println(&quot;通道已关闭&quot;)            break        &#125;        fmt.Printf(&quot;v:%#v ok:%#v\n&quot;, v, ok)    &#125;&#125;func main() &#123;    ch := make(chan int, 2)    ch &lt;- 1    ch &lt;- 2    close(ch)    f2(ch)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## for range接收值</span><br><span class="line"></span><br><span class="line">通常我们会选择使用for range循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用for range改写后会很简洁。</span><br></pre></td></tr></table></figure>func f3(ch chan int) &#123;    for v := range ch &#123;        fmt.Println(v)    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**注意：**目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过len(ch)操作来判断通道是否被关闭。</span><br><span class="line">## 单向通道</span><br><span class="line"></span><br><span class="line">在某些场景下我们可能会将通道作为参数在多个任务函数间进行传递，通常我们会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。想象一下，我们现在有Producer和Consumer两个函数，其中Producer函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而Consumer函数的任务是从通道中接收值进行计算，这两个函数之间通过Processer函数返回的通道进行通信。完整的示例代码如下。</span><br></pre></td></tr></table></figure>package mainimport (    &quot;fmt&quot;)// Producer 返回一个通道// 并持续将符合条件的数据发送至返回的通道中// 数据发送完成后会将返回的通道关闭func Producer() chan int &#123;    ch := make(chan int, 2)    // 创建一个新的goroutine执行发送数据的任务    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            if i%2 == 1 &#123;                ch &lt;- i            &#125;        &#125;        close(ch) // 任务完成后关闭通道    &#125;()    return ch&#125;// Consumer 从通道中接收数据进行计算func Consumer(ch chan int) int &#123;    sum := 0    for v := range ch &#123;        sum += v    &#125;    return sum&#125;func main() &#123;    ch := Producer()    res := Consumer(ch)    fmt.Println(res) // 25&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从上面的示例代码中可以看出正常情况下Consumer函数中只会对通道进行接收操作，但是这不代表不可以在Consumer函数中对通道进行发送操作。作为Producer函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在Consumer函数中对通道进行发送操作。</span><br><span class="line"></span><br><span class="line">Go语言中提供了单向通道来处理这种需要限制通道只能进行某种操作的情况。</span><br></pre></td></tr></table></figure>&lt;- chan int // 只接收通道，只能接收不能发送chan &lt;- int // 只发送通道，只能发送不能接收<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其中，箭头&lt;-和关键字chan的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</span><br><span class="line"></span><br><span class="line">我们使用单向通道将上面的示例代码进行如下改造。</span><br></pre></td></tr></table></figure>// Producer2 返回一个接收通道func Producer2() &lt;-chan int &#123;    ch := make(chan int, 2)    // 创建一个新的goroutine执行发送数据的任务    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            if i%2 == 1 &#123;                ch &lt;- i            &#125;        &#125;        close(ch) // 任务完成后关闭通道    &#125;()    return ch&#125;// Consumer2 参数为接收通道func Consumer2(ch &lt;-chan int) int &#123;    sum := 0    for v := range ch &#123;        sum += v    &#125;    return sum&#125;func main() &#123;    ch2 := Producer2()      res2 := Consumer2(ch2)    fmt.Println(res2) // 25&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这一次，Producer函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。很多读者看到这个示例可能会觉着这样的限制是多余的，但是试想一下如果Producer函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</span><br><span class="line"></span><br><span class="line">在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</span><br></pre></td></tr></table></figure>var ch3 = make(chan int, 1)ch3 &lt;- 10close(ch3)Consumer2(ch3) // 函数传参时将ch3转为单向通道var ch4 = make(chan int, 1)ch4 &lt;- 10var ch5 &lt;-chan int // 声明一个只接收通道ch5ch5 = ch4          // 变量赋值时将ch4转为单向通道&lt;-ch5```## 总结下面的表格中总结了对不同状态下的通道执行相应操作的结果。c:\Users\reyyy\AppData\Local\Temp\channel.png**注意：**对已经关闭的通道再执行 close 也会引发 panic。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之并发(一)</title>
      <link href="/posts/4a17b002.html"/>
      <url>/posts/4a17b002.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="串行、并发与并行"><a href="#串行、并发与并行" class="headerlink" title="串行、并发与并行"></a>串行、并发与并行</h3><p>串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。</p><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p><p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。</p><p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。</p><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：</p><ul><li>线程&amp;锁模型</li><li>Actor模型</li><li>CSP模型</li><li>Fork&amp;Join模型</li></ul><p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。</p><p>Goroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="go关键字"><a href="#go关键字" class="headerlink" title="go关键字"></a>go关键字</h3><p>Go语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上go关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f()  // 创建一个新的 goroutine 运行函数f</span><br></pre></td></tr></table></figure><p>匿名函数也支持使用go关键字创建 goroutine 去执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go func()&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>一个 goroutine 必定对应一个函数&#x2F;方法，可以创建多个 goroutine 去执行相同的函数&#x2F;方法。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个go关键字。</p><p>我们先来看一个在 main 函数中执行普通函数调用的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">hello()</span><br><span class="line">fmt.Println(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后执行，得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><p>代码中 hello 函数和其后面的打印语句是串行的。<br><img src="/goroutine01.png" alt="alt text"></p><p>接下来我们在调用 hello 函数前面加上关键字go，也就是启动一个 goroutine 去执行 hello 这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">go hello() // 启动另外一个goroutine去执行hello函数</span><br><span class="line">fmt.Println(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码重新编译后执行，得到输出结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一次的执行结果只在终端打印了”你好”，并没有打印 hello。这是为什么呢？</p><p>其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine 。在上面的代码中我们在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出“hello”。</p><p>main goroutine 就像是《权利的游戏》中的夜王，其他的 goroutine 都是夜王转化出的异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让 main 函数“等一等”将在另一个 goroutine 中运行的 hello 函数。其中最简单粗暴的方式就是在 main 函数中“time.Sleep”1秒钟了（这里的1秒钟是我们根据经验而设置的一个值，在这个示例中1秒钟足够创建新的goroutine执行完hello函数了）。</p><p>按如下方式修改我们的示例代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">go hello()</span><br><span class="line">fmt.Println(&quot;你好&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将我们的程序重新编译后再次执行，程序会在终端输出如下结果，并且会短暂停顿一会儿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>为什么会先打印你好呢？</p><p>这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。<br><img src="/goroutine02.png" alt="alt text"></p><p>在上面的程序中使用time.Sleep让 main goroutine 等待 hello goroutine执行结束是不优雅的，当然也是不准确的。</p><p>Go 语言中通过sync包为我们提供了一些常用的并发原语，我们会在后面的小节单独介绍sync包中的内容。在这一小节，我们会先介绍一下 sync 包中的WaitGroup。当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法。</p><p>下面的示例代码中我们在 main goroutine 中使用sync.WaitGroup来等待 hello goroutine 完成后再退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明全局等待组变量</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">fmt.Println(&quot;hello&quot;)</span><br><span class="line">wg.Done() // 告知当前goroutine完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(1) // 登记1个goroutine</span><br><span class="line">go hello()</span><br><span class="line">fmt.Println(&quot;你好&quot;)</span><br><span class="line">wg.Wait() // 阻塞等待登记的goroutine完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码编译后再执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了sync.WaitGroup来实现 goroutine 的同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func hello(i int) &#123;</span><br><span class="line">defer wg.Done() // goroutine结束就登记-1</span><br><span class="line">fmt.Println(&quot;hello&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">wg.Add(1) // 启动一个goroutine就登记+1</span><br><span class="line">go hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() // 等待所有登记的goroutine都结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。</p><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 GPM 调度模型。<br><img src="/gpm.png" alt="alt text"><br>其中：</p><ul><li><p>G：表示 goroutine，每执行一次go f()就创建一个 G，包含要执行的函数和上下文信息。</p></li><li><p>全局队列（Global Queue）：存放等待运行的 G。</p></li><li><p>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</p></li><li><p>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</p></li><li><p>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</p></li><li><p>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</p></li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过runtime.GOMAXPROCS函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之反射</title>
      <link href="/posts/4a17b004.html"/>
      <url>/posts/4a17b004.html</url>
      
        <content type="html"><![CDATA[<hr><p>本文介绍了Go语言反射的意义和基本使用。</p><h1 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期间使用reflect包访问程序的反射信息。</p><h1 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h1><p>在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。</p><h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><p>在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(&quot;type:%v\n&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">reflectType(a) // type:float32</span><br><span class="line">var b int64 = 100</span><br><span class="line">reflectType(b) // type:int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h2><p>在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myInt int64</span><br><span class="line"></span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(&quot;type:%v kind:%v\n&quot;, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a *float32 // 指针</span><br><span class="line">var b myInt    // 自定义类型</span><br><span class="line">var c rune     // 类型别名</span><br><span class="line">reflectType(a) // type: kind:ptr</span><br><span class="line">reflectType(b) // type:myInt kind:int64</span><br><span class="line">reflectType(c) // type:int32 kind:int32</span><br><span class="line"></span><br><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int</span><br><span class="line">&#125;</span><br><span class="line">type book struct&#123; title string &#125;</span><br><span class="line">var d = person&#123;</span><br><span class="line">name: &quot;沙河小王子&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">var e = book&#123;title: &quot;《跟小王子学Go语言》&quot;&#125;</span><br><span class="line">reflectType(d) // type:person kind:struct</span><br><span class="line">reflectType(e) // type:book kind:struct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</p><p>在reflect包中定义的Kind类型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p><p>reflect.Value类型提供的获取原始值的方法如下：</p><p>方法 说明<br>Interface() interface {} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型<br>Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回<br>Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回<br>Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回<br>Bool() bool 将值以 bool 类型返回<br>Bytes() []bytes 将值以字节数组 []bytes 类型返回<br>String() string 将值以字符串类型返回</p><h3 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func reflectValue(x interface&#123;&#125;) &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line">switch k &#123;</span><br><span class="line">case reflect.Int64:</span><br><span class="line">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is int64, value is %d\n&quot;, int64(v.Int()))</span><br><span class="line">case reflect.Float32:</span><br><span class="line">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is float32, value is %f\n&quot;, float32(v.Float()))</span><br><span class="line">case reflect.Float64:</span><br><span class="line">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is float64, value is %f\n&quot;, float64(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">var b int64 = 100</span><br><span class="line">reflectValue(a) // type is float32, value is 3.140000</span><br><span class="line">reflectValue(b) // type is int64, value is 100</span><br><span class="line">// 将int类型的原始值转换为reflect.Value类型</span><br><span class="line">c := reflect.ValueOf(10)</span><br><span class="line">fmt.Printf(&quot;type c :%T\n&quot;, c) // type c :reflect.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func reflectSetValue1(x interface&#123;&#125;) &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">if v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(200) //修改的是副本，reflect包会引发panic</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func reflectSetValue2(x interface&#123;&#125;) &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">// 反射中使用 Elem()方法获取指针对应的值</span><br><span class="line">if v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(200)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a int64 = 100</span><br><span class="line">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h3><p>IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsNil() bool</span><br></pre></td></tr></table></figure><p>IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsValid() bool</span><br></pre></td></tr></table></figure><h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><h3 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h3><p>任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。</p><p>reflect.Type中与获取结构体成员相关的的方法如下表所示。</p><p>方法 说明<br>Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。<br>NumField() int 返回结构体成员字段数量。<br>FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。<br>FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。<br>FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。<br>NumMethod() int 返回该类型的方法集中方法的数目<br>Method(int) Method 返回该类型方法集中的第i个方法<br>MethodByName(string)(Method, bool) 根据方法名返回该类型方法集中的方法</p><h3 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h3><p>StructField类型用来描述结构体中的一个字段的信息。</p><p>StructField的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type StructField struct &#123;</span><br><span class="line">    // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br><span class="line">    // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br><span class="line">    Name    string</span><br><span class="line">    PkgPath string</span><br><span class="line">    Type      Type      // 字段的类型</span><br><span class="line">    Tag       StructTag // 字段的标签</span><br><span class="line">    Offset    uintptr   // 字段在结构体中的字节偏移量</span><br><span class="line">    Index     []int     // 用于Type.FieldByIndex时的索引切片</span><br><span class="line">    Anonymous bool      // 是否匿名字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h3><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">Name  string `json:&quot;name&quot;`</span><br><span class="line">Score int    `json:&quot;score&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  &quot;小王子&quot;,</span><br><span class="line">Score: 90,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) // student struct</span><br><span class="line">// 通过for循环遍历结构体的所有字段信息</span><br><span class="line">for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过字段名获取指定结构体字段信息</span><br><span class="line">if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok &#123;</span><br><span class="line">fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之接口</title>
      <link href="/posts/4a17b008.html"/>
      <url>/posts/4a17b008.html</url>
      
        <content type="html"><![CDATA[<hr><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。</p><p>相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>每个接口类型由任意个方法签名组成，接口的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有关闭操作的接口叫closer等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><p>举个例子，定义一个包含Write方法的Writer接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface&#123;</span><br><span class="line">    Write([]byte) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你看到一个Writer接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的Write方法来做一些事情。</p><h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>接口就是规定了一个需要实现的方法列表，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p><p>我们定义的Singer接口类型，它包含一个Sing方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Singer 接口</span><br><span class="line">type Singer interface &#123;</span><br><span class="line">Sing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个Bird 结构体类型如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Bird struct &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为Singer接口只包含一个Sing方法，所以只需要给Bird结构体添加一个Sing方法就可以满足Singer接口的要求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Sing Bird类型的Sing方法</span><br><span class="line">func (b Bird) Sing() &#123;</span><br><span class="line">fmt.Println(&quot;汪汪汪&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就称为Bird实现了Singer接口。</p><h3 id="为什么要使用接口？"><a href="#为什么要使用接口？" class="headerlink" title="为什么要使用接口？"></a>为什么要使用接口？</h3><p>现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c Cat) Say() &#123;</span><br><span class="line">fmt.Println(&quot;喵喵喵~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (d Dog) Say() &#123;</span><br><span class="line">fmt.Println(&quot;汪汪汪~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := Cat&#123;&#125;</span><br><span class="line">c.Say()</span><br><span class="line">d := Dog&#123;&#125;</span><br><span class="line">d.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候又跑来了一只羊，羊饿了也会发出叫声。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Sheep struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s Sheep) Say() &#123;</span><br><span class="line">fmt.Println(&quot;咩咩咩~&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来定义一个饿肚子的场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MakeCatHungry 猫饿了会喵喵喵~</span><br><span class="line">func MakeCatHungry(c Cat) &#123;</span><br><span class="line">c.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeSheepHungry 羊饿了会咩咩咩~</span><br><span class="line">func MakeSheepHungry(s Sheep) &#123;</span><br><span class="line">s.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？</p><p>在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。 我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的Say()方法，这就足够了。</p><p>我们可以约定一个Sayer类型，它必须实现一个Say()方法，只要饿肚子了，我们就调用Say()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Sayer interface &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义一个通用的MakeHungry函数，接收Sayer类型的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MakeHungry 饿肚子了...</span><br><span class="line">func MakeHungry(s Sayer) &#123;</span><br><span class="line">s.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过使用接口类型，把所有会叫的动物当成Sayer类型来处理，只要实现了Say()方法都能当成Sayer类型的变量来处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c cat</span><br><span class="line">MakeHungry(c)</span><br><span class="line">var d dog</span><br><span class="line">MakeHungry(d)</span><br></pre></td></tr></table></figure><p>在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的Pay方法让调用方调用就可以了。</p><p>再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个Write方法让我们把内容写入就可以了。</p><p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。</p><h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p><p>Go语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type ZhiFuBao struct &#123;</span><br><span class="line">// 支付宝</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Pay 支付宝的支付方法</span><br><span class="line">func (z *ZhiFuBao) Pay(amount int64) &#123;</span><br><span class="line">  fmt.Printf(&quot;使用支付宝付款：%.2f元。\n&quot;, float64(amount/100))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Checkout 结账</span><br><span class="line">func Checkout(obj *ZhiFuBao) &#123;</span><br><span class="line">// 支付100元</span><br><span class="line">obj.Pay(100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Checkout(&amp;ZhiFuBao&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着业务的发展，根据用户需求添加支持微信支付。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type WeChat struct &#123;</span><br><span class="line">// 微信</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Pay 微信的支付方法</span><br><span class="line">func (w *WeChat) Pay(amount int64) &#123;</span><br><span class="line">fmt.Printf(&quot;使用微信付款：%.2f元。\n&quot;, float64(amount/100))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Checkout 支付宝结账</span><br><span class="line">func CheckoutWithZFB(obj *ZhiFuBao) &#123;</span><br><span class="line">// 支付100元</span><br><span class="line">obj.Pay(100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Checkout 微信支付结账</span><br><span class="line">func CheckoutWithWX(obj *WeChat) &#123;</span><br><span class="line">// 支付100元</span><br><span class="line">obj.Pay(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。</p><p>在这种场景下我们可以将具体的支付方式抽象为一个名为Payer的接口类型，即任何实现了Pay方法的都可以称为Payer类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Payer 包含支付方法的接口类型</span><br><span class="line">type Payer interface &#123;</span><br><span class="line">Pay(int64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只需要修改下原始的Checkout函数，它接收一个Payer类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Checkout 结账</span><br><span class="line">func Checkout(obj Payer) &#123;</span><br><span class="line">// 支付100元</span><br><span class="line">obj.Pay(100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Checkout(&amp;ZhiFuBao&#123;&#125;) // 之前调用支付宝支付</span><br><span class="line"></span><br><span class="line">Checkout(&amp;WeChat&#123;&#125;) // 现在支持使用微信支付</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像类似的例子在我们编程过程中会经常遇到：</p><ul><li><p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p></li><li><p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p></li><li><p>比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？</p></li></ul><p>接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。</p><h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量。</p><p>例如在上面的示例中，Dog和Cat类型均实现了Sayer接口，此时一个Sayer类型的变量就能够接收Cat和Dog类型的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x Sayer // 声明一个Sayer类型的变量x</span><br><span class="line">a := Cat&#123;&#125;  // 声明一个Cat类型变量a</span><br><span class="line">b := Dog&#123;&#125;  // 声明一个Dog类型变量b</span><br><span class="line">x = a       // 可以把Cat类型变量直接赋值给x</span><br><span class="line">x.Say()     // 喵喵喵</span><br><span class="line">x = b       // 可以把Dog类型变量直接赋值给x</span><br><span class="line">x.Say()     // 汪汪汪</span><br></pre></td></tr></table></figure><h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>在结构体那一章节中，我们介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们定义一个Mover接口，它包含一个Move方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Mover 定义一个接口类型</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><p>我们定义一个Dog结构体类型，并使用值接收者为其定义一个Move方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Dog 狗结构体类型</span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Move 使用值接收者定义Move方法实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现Mover接口的是Dog类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x Mover    // 声明一个Mover类型的变量x</span><br><span class="line"></span><br><span class="line">var d1 = Dog&#123;&#125; // d1是Dog类型</span><br><span class="line">x = d1         // 可以将d1赋值给变量x</span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line">var d2 = &amp;Dog&#123;&#125; // d2是Dog指针类型</span><br><span class="line">x = d2          // 也可以将d2赋值给变量x</span><br><span class="line">x.Move()</span><br></pre></td></tr></table></figure><h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><p>我们再来测试一下使用指针接收者实现接口有什么区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Cat 猫结构体类型</span><br><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Move 使用指针接收者定义Move方法实现Mover接口</span><br><span class="line">func (c *Cat) Move() &#123;</span><br><span class="line">fmt.Println(&quot;猫会动&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现Mover接口的是<em>Cat类型，我们可以将</em>Cat类型的变量直接赋值给Mover接口类型的变量x。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c1 = &amp;Cat&#123;&#125; // c1是*Cat类型</span><br><span class="line">x = c1          // 可以将c1当成Mover类型</span><br><span class="line">x.Move()</span><br></pre></td></tr></table></figure><p>但是不能给将Cat类型的变量赋值给Mover接口类型的变量x。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码无法通过编译</span><br><span class="line">var c2 = Cat&#123;&#125; // c2是Cat类型</span><br><span class="line">x = c2         // 不能将c2当成Mover类型</span><br></pre></td></tr></table></figure><p>由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。</p><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义Sayer接口和Mover接口，具体代码示例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Sayer 接口</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Mover 接口</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog既可以实现Sayer接口，也可以实现Mover接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Dog struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现Sayer接口</span><br><span class="line">func (d Dog) Say() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会叫汪汪汪\n&quot;, d.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会动\n&quot;, d.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个类型实现不同的接口互相不影响使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var d = Dog&#123;Name: &quot;旺财&quot;&#125;</span><br><span class="line"></span><br><span class="line">var s Sayer = d</span><br><span class="line">var m Mover = d</span><br><span class="line"></span><br><span class="line">s.Say()  // 对Sayer类型调用Say方法</span><br><span class="line">m.Move() // 对Mover类型调用Move方法</span><br></pre></td></tr></table></figure><h3 id="多种类型实现同一接口"><a href="#多种类型实现同一接口" class="headerlink" title="多种类型实现同一接口"></a>多种类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。我们可以使用如下代码体现这个关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会动\n&quot;, d.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Car 汽车结构体类型</span><br><span class="line">type Car struct &#123;</span><br><span class="line">Brand string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Move Car类型实现Mover接口</span><br><span class="line">func (c Car) Move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s速度70迈\n&quot;, c.Brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的Move方法就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj Mover</span><br><span class="line"></span><br><span class="line">obj = Dog&#123;Name: &quot;旺财&quot;&#125;</span><br><span class="line">obj.Move()</span><br><span class="line"></span><br><span class="line">obj = Car&#123;Brand: &quot;宝马&quot;&#125;</span><br><span class="line">obj.Move()</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">宝马速度70迈</span><br></pre></td></tr></table></figure><p>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// WashingMachine 洗衣机</span><br><span class="line">type WashingMachine interface &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 甩干器</span><br><span class="line">type dryer struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 实现WashingMachine接口的dry()方法</span><br><span class="line">func (d dryer) dry() &#123;</span><br><span class="line">fmt.Println(&quot;甩一甩&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 海尔洗衣机</span><br><span class="line">type haier struct &#123;</span><br><span class="line">dryer //嵌入甩干器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现WashingMachine接口的wash()方法</span><br><span class="line">func (h haier) wash() &#123;</span><br><span class="line">fmt.Println(&quot;洗刷刷&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h2><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库io源码中就有很多接口之间互相组合的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// src/io/io.go</span><br><span class="line"></span><br><span class="line">type Reader interface &#123;</span><br><span class="line">Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Closer interface &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，我们来看一段Go标准库sort源码中的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/sort/sort.go</span><br><span class="line"></span><br><span class="line">// Interface 定义通过索引对元素排序的接口类型</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">    Len() int</span><br><span class="line">    Less(i, j int) bool</span><br><span class="line">    Swap(i, j int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// reverse 结构体中嵌入了Interface接口</span><br><span class="line">type reverse struct &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span><br><span class="line">func (r reverse) Less(i, j int) bool &#123;</span><br><span class="line">return r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interface类型原本的Less方法签名为 Less(i, j int) bool，此处重写为r.Interface.Less(j, i)，即通过将索引参数交换位置实现反转。</p><p>在这个示例中还有一个需要注意的地方是reverse结构体本身是不可导出的（结构体类型名称首字母小写），sort.go中通过定义一个可导出的Reverse函数来让使用者创建reverse结构体实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Reverse(data Interface) Interface &#123;</span><br><span class="line">return &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h3><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 空接口</span><br><span class="line"></span><br><span class="line">// Any 不包含任何方法的空接口类型</span><br><span class="line">type Any interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Dog 狗结构体</span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var x Any</span><br><span class="line"></span><br><span class="line">x = &quot;你好&quot; // 字符串型</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">x = 100 // int型</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">x = true // 布尔型</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">x = Dog&#123;&#125; // 结构体类型</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们在使用空接口类型时不必使用type关键字声明，可以像下面的代码一样直接使用interface{}。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x interface&#123;&#125;  // 声明一个空接口类型变量x</span><br></pre></td></tr></table></figure><h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><p>1、空接口作为函数的参数</p><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 空接口作为函数参数</span><br><span class="line">func show(a interface&#123;&#125;) &#123;</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、空接口作为map的值</p><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 空接口作为map值</span><br><span class="line">var studentInfo = make(map[string]interface&#123;&#125;)</span><br><span class="line">studentInfo[&quot;name&quot;] = &quot;沙河娜扎&quot;</span><br><span class="line">studentInfo[&quot;age&quot;] = 18</span><br><span class="line">studentInfo[&quot;married&quot;] = false</span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体值之外，还需要记录这个值属于的类型。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的动态类型和动态值。</p><p><img src="/interface01.png" alt="alt text"></p><p>我们接下来通过一个示例来加深对接口值的理解。</p><p>下面的示例代码中，定义了一个Mover接口类型和两个实现了该接口的Dog和Car结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Mover interface &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) Move() &#123;</span><br><span class="line">fmt.Println(&quot;狗在跑~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Car struct &#123;</span><br><span class="line">Brand string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Car) Move() &#123;</span><br><span class="line">fmt.Println(&quot;汽车在跑~&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个Mover接口类型的变量m。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var m Mover</span><br></pre></td></tr></table></figure><p>此时，接口变量m是接口类型的零值，也就是它的类型和值部分都是nil，就如下图所示。<br><img src="/interface02.png" alt="alt text"></p><p>我们可以使用m &#x3D;&#x3D; nil来判断此时的接口值是否为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == nil)  // true</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>我们不能对一个空接口值调用任何方法，否则会产生panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.Move() // panic: runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><p>接下来，我们将一个*Dog结构体指针赋值给变量m。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: &quot;旺财&quot;&#125;</span><br></pre></td></tr></table></figure><p>此时，接口值m的动态类型会被设置为*Dog，动态值为结构体变量的拷贝。</p><p><img src="/interface03.png" alt="alt text"></p><p>然后，我们给接口变量m赋值为一个*Car类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c *Car</span><br><span class="line">m = c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一次，接口值m的动态类型为*Car，动态值为nil。</p><p><img src="/interface04.png" alt="alt text"></p><p><strong>注意：</strong>此时接口变量m与nil并不相等，因为它只是动态值的部分为nil，而动态类型部分保存着对应值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == nil) // false</span><br></pre></td></tr></table></figure><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">x Mover = new(Dog)</span><br><span class="line">y Mover = new(Car)</span><br><span class="line">)</span><br><span class="line">fmt.Println(x == y) // false</span><br></pre></td></tr></table></figure><p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var z interface&#123;&#125; = []int&#123;1, 2, 3&#125;</span><br><span class="line">fmt.Println(z == z) // panic: runtime error: comparing uncomparable type []int</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？</p><p>我们可以借助标准库fmt包的格式化打印获取到接口值的动态类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m Mover</span><br><span class="line"></span><br><span class="line">m = &amp;Dog&#123;Name: &quot;旺财&quot;&#125;</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, m) // *main.Dog</span><br><span class="line"></span><br><span class="line">m = new(Car)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, m) // *main.Car</span><br></pre></td></tr></table></figure><p>而fmt包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。</p><p>而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示接口类型的变量</li><li>T：表示断言x可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var n Mover = &amp;Dog&#123;Name: &quot;旺财&quot;&#125;</span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(&quot;类型断言成功&quot;)</span><br><span class="line">v.Name = &quot;富贵&quot; // 变量v是*Dog类型</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;类型断言失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对一个接口值有多个实际类型需要判断，推荐使用switch语句来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// justifyType 对传入的空接口类型变量x进行类型断言</span><br><span class="line">func justifyType(x interface&#123;&#125;) &#123;</span><br><span class="line">switch v := x.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">fmt.Printf(&quot;x is a string，value is %v\n&quot;, v)</span><br><span class="line">case int:</span><br><span class="line">fmt.Printf(&quot;x is a int is %v\n&quot;, v)</span><br><span class="line">case bool:</span><br><span class="line">fmt.Printf(&quot;x is a bool is %v\n&quot;, v)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unsupport type！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p><p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。</p><p>相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。</p><p>小技巧： 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 摘自gin框架routergroup.go</span><br><span class="line">type IRouter interface&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">type RouterGroup struct &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">var _ IRouter = &amp;RouterGroup&#123;&#125;  // 确保RouterGroup实现了接口IRouter</span><br></pre></td></tr></table></figure><p>上面的代码中也可以使用var _ IRouter &#x3D; (*RouterGroup)(nil)进行验证。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之包</title>
      <link href="/posts/4a17b897.html"/>
      <url>/posts/4a17b897.html</url>
      
        <content type="html"><![CDATA[<h2 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h2><p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何引入其他包。同时也将介绍如何在项目中使用go module管理依赖。</p><h3 id="包介绍"><a href="#包介绍" class="headerlink" title="包介绍"></a>包介绍</h3><p>Go语言中支持模块化的开发理念，在Go语言中使用包（package）来支持代码模块化和代码复用。一个包是由一个或多个Go源码文件（.go结尾的文件）组成，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等。</p><p>例如，在之前的章节中我们频繁使用了fmt这个内置包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">  fmt.Println(&quot;Hello world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h3><p>我们可以根据自己的需要创建自定义包。一个包可以简单理解为一个存放.go文件的文件夹。该文件夹下面的所有.go文件都要在非注释的第一行添加如下声明，声明该文件归属的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package packagename</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>package：声明包的关键字</li><li>packagename：包名，可以不与文件夹的名称一致，不能包含 - 符号，最好与其实现的功能相对应。</li></ul><p>另外需要注意一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。包名为main的包是应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。</p><h3 id="标识符可见性"><a href="#标识符可见性" class="headerlink" title="标识符可见性"></a>标识符可见性</h3><p>在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如fmt.Println(“Hello world!”)，就是指调用fmt包中的Println函数。</p><p>如果想让一个包中的标识符（如变量、常量、类型、函数等）能被外部的包使用，那么标识符必须是对外可见的（public）。在Go语言中是通过标识符的首字母大&#x2F;小写来控制标识符的对外可见（public）&#x2F;不可见（private）的。在一个包内部只有首字母大写的标识符才是对外可见的。</p><p>例如我们定义一个名为demo的包，在其中定义了若干标识符。在另外一个包中并不是所有的标识符都能通过demo.前缀访问到，因为只有那些首字母是大写的标识符才是对外可见的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 包级别标识符的可见性</span><br><span class="line"></span><br><span class="line">// num 定义一个全局整型变量</span><br><span class="line">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="line">var num = 100</span><br><span class="line"></span><br><span class="line">// Mode 定义一个常量</span><br><span class="line">// 首字母大写，对外可见(可在其它包中使用)</span><br><span class="line">const Mode = 1</span><br><span class="line"></span><br><span class="line">// person 定义一个代表人的结构体</span><br><span class="line">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add 返回两个整数和的函数</span><br><span class="line">// 首字母大写，对外可见(可在其它包中使用)</span><br><span class="line">func Add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sayHi 打招呼的函数</span><br><span class="line">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="line">func sayHi() &#123;</span><br><span class="line">var myName = &quot;七米&quot; // 函数局部变量，只能在当前函数内使用</span><br><span class="line">fmt.Println(myName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的规则也适用于结构体，结构体中可导出字段的字段名称必须首字母大写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Student struct &#123;</span><br><span class="line">Name  string // 可在包外访问的方法</span><br><span class="line">class string // 仅限包内访问的字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>要在当前包中使用另外一个包的内容就需要使用import关键字引入这个包，并且import语句通常放在文件的开头，package声明语句的下方。完整的引入声明语句格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import importname &quot;path/to/package&quot;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>importname：引入的包名，通常都省略。默认值为引入包的包名。</li><li>path&#x2F;to&#x2F;package：引入包的路径名称，必须使用双引号包裹起来。</li><li>Go语言中禁止循环导入包。</li></ul><p>一个Go源码文件中可以同时引入多个包，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;net/http&quot;</span><br><span class="line">import &quot;os&quot;</span><br></pre></td></tr></table></figure><p>当然可以使用批量引入的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">  &quot;net/http&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过importname指定一个在当前文件中使用的新包名。例如，在引入fmt包时为其指定一个新包名f。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import f &quot;fmt&quot;</span><br></pre></td></tr></table></figure><p>这样在当前这个文件中就可以通过使用f来调用fmt包中的函数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Println(&quot;Hello world!&quot;)</span><br></pre></td></tr></table></figure><p>如果引入一个包的时候为其设置了一个特殊_作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的init函数将被执行并且仅执行一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;github.com/go-sql-driver/mysql&quot;</span><br></pre></td></tr></table></figure><p>匿名引入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><p>需要注意的是，Go语言中不允许引入包却不在代码中使用这个包的内容，如果引入了未使用的包则会触发编译错误。</p><h3 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h3><p>在每一个Go源文件中，都可以定义任意个如下格式的特殊函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init()&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。</p><p>一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的init函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的init函数再执行当前包中声明的init函数。确保在程序的main函数开始执行时所有的依赖包都已初始化完成。<br><img src="/package01.png" alt="alt text"></p><p>每一个包的初始化是先从初始化包级别变量开始的。例如从下面的示例中我们就可以看出包级别变量的初始化会先于init初始化函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var x int8 = 10</span><br><span class="line"></span><br><span class="line">const pi = 3.14</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">  fmt.Println(&quot;x:&quot;, x)</span><br><span class="line">  fmt.Println(&quot;pi:&quot;, pi)</span><br><span class="line">  sayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHi() &#123;</span><br><span class="line">fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;你好，世界！&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: 10</span><br><span class="line">pi: 3.14</span><br><span class="line">Hello World!</span><br><span class="line">你好，世界！</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们了解了Go语言中包的定义及包的初始化过程，这让我们能够在开发时按照自己的需要定义包。同时我们还学到了如何在我们的代码中引入其它的包，不过在本小节的所有示例中我们都是引入Go内置的包。现代编程语言大多都允许开发者对外发布包&#x2F;库，也支持开发者在自己的代码中引入第三方库。这样的设计能够让广大开发者一起参与到语言的生态环境建设当中，把生态建设的更加完善。</p><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p>在Go语言的早期版本中，我们编写Go项目代码时所依赖的所有第三方包都需要保存在GOPATH这个目录下面。这样的依赖管理方式存在一个致命的缺陷，那就是不支持版本管理，同一个依赖包只能存在一个版本的代码。可是我们本地的多个项目完全可能分别依赖同一个第三方包的不同版本。</p><h3 id="go-module介绍"><a href="#go-module介绍" class="headerlink" title="go module介绍"></a>go module介绍</h3><p>Go module 是 Go1.11 版本发布的依赖管理方案，从 Go1.14 版本开始推荐在生产环境使用，于Go1.16版本默认开启。Go module 提供了以下命令供我们使用：</p><p>go module相关命令</p><p>命令 介绍<br>go mod init 初始化项目依赖，生成go.mod文件<br>go mod download 根据go.mod文件下载依赖<br>go mod tidy 比对项目文件中引入的依赖与go.mod进行比对<br>go mod graph 输出依赖关系图<br>go mod edit 编辑go.mod文件<br>go mod vendor 将项目的所有依赖导出至vendor目录<br>go mod verify 检验一个依赖包是否被篡改过<br>go mod why 解释为什么需要某个依赖</p><p>Go语言在 go module 的过渡阶段提供了 GO111MODULE 这个环境变量来作为是否启用 go module 功能的开关，考虑到 Go1.16 之后 go module 已经默认开启，所以本书不再介绍该配置，对于刚接触Go语言的读者而言完全没有必要了解这个历史包袱。</p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p><p>GOPROXY 的默认值是：<a href="https://proxy.golang.org,direct,由于某些原因国内无法正常访问该地址,所以我们通常需要配置一个可访问的地址.目前社区使用比较多的有两个https//goproxy.cn%E5%92%8Chttps://goproxy.io%EF%BC%8C%E5%BD%93%E7%84%B6%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%85%AC%E5%8F%B8%E6%9C%89%E6%8F%90%E4%BE%9BGOPROXY%E5%9C%B0%E5%9D%80%E9%82%A3%E4%B9%88%E5%B0%B1%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E3%80%82%E8%AE%BE%E7%BD%AEGOPAROXY%E7%9A%84%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%9A">https://proxy.golang.org,direct，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前社区使用比较多的有两个https://goproxy.cn和https://goproxy.io，当然如果你的公司有提供GOPROXY地址那么就直接使用。设置GOPAROXY的命令如下：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。</p><h3 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a>GOPRIVATE</h3><p>设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。</p><p>GOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go env -w GOPRIVATE=&quot;git.mycompany.com&quot;</span><br></pre></td></tr></table></figure><p>这样在拉取以git.mycompany.com为路径前缀的依赖包时就能正常拉取了。</p><p>此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY&#x3D;none，允许通内部代理拉取私有仓库的包。</p><h3 id="使用go-module引入包"><a href="#使用go-module引入包" class="headerlink" title="使用go module引入包"></a>使用go module引入包</h3><p>接下来我们将通过一个示例来演示如何在开发项目时使用 go module 拉取和管理项目依赖。</p><p>初始化项目 我们在本地新建一个名为holiday项目，按如下方式创建一个名为holiday的文件夹并切换到该目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir holiday</span><br><span class="line">$ cd holiday</span><br></pre></td></tr></table></figure><p>目前我们位于holiday文件夹下，接下来执行下面的命令初始化项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init holiday</span><br><span class="line">go: creating new go.mod: module holiday</span><br></pre></td></tr></table></figure><p>该命令会自动在项目目录下创建一个go.mod文件，其内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>module holiday：定义当前项目的导入路径</li><li>go 1.16：标识当前项目使用的 Go 版本</li></ul><p>go.mod文件会记录项目使用的第三方依赖包信息，包括包名和版本，由于我们的holiday项目目前还没有使用到第三方依赖包，所以go.mod文件暂时还没有记录任何依赖包信息，只有当前项目的一些信息。</p><p>接下来，我们在项目目录下新建一个main.go文件，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// holiday/main.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;现在是假期时间...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们的holiday项目现在需要引入一个第三方包github.com&#x2F;q1mi&#x2F;hello来实现一些必要的功能。类似这样的场景在我们的日常开发中是很常见的。我们需要先将依赖包下载到本地同时在go.mod中记录依赖信息，然后才能在我们的代码中引入并使用这个包。下载依赖包主要有两种方法。</p><p>第一种方法是在项目目录下执行go get命令手动下载依赖的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">holiday $ go get -u github.com/q1mi/hello</span><br><span class="line">go get: added github.com/q1mi/hello v0.1.1</span><br></pre></td></tr></table></figure><p>这样默认会下载最新的发布版本，你也可以指定想要下载指定的版本号的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">holiday $ go get -u github.com/q1mi/hello@v0.1.0</span><br><span class="line">go: downloading github.com/q1mi/hello v0.1.0</span><br><span class="line">go get: downgraded github.com/q1mi/hello v0.1.1 =&gt; v0.1.0</span><br></pre></td></tr></table></figure><p>如果依赖包没有发布任何版本则会拉取最新的提交，最终go.mod中的依赖信息会变成类似下面这种由默认v0.0.0的版本号和最新一次commit的时间和hash组成的版本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com/q1mi/hello v0.0.0-20210218074646-139b0bcd549d</span><br></pre></td></tr></table></figure><p>如果想指定下载某个commit对应的代码，可以直接指定commit hash，不过没有必要写出完整的commit hash，一般前7位即可。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">holiday $ go get github.com/q1mi/hello@2ccfadd</span><br><span class="line">go: downloading github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3</span><br><span class="line">go get: added github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3</span><br></pre></td></tr></table></figure><p>此时，我们打开go.mod文件就可以看到下载的依赖包及版本信息都已经被记录下来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello v0.1.0 // indirect</span><br></pre></td></tr></table></figure><p>行尾的indirect表示该依赖包为间接依赖，说明在当前程序中的所有 import 语句中没有发现引入这个包。</p><p>另外在执行go get命令下载一个新的依赖包时一般会额外添加-u参数，强制更新现有依赖。</p><p>第二种方式是我们直接编辑go.mod文件，将依赖包和版本信息写入该文件。例如我们修改holiday&#x2F;go.mod文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello latest</span><br></pre></td></tr></table></figure><p>表示当前项目需要使用github.com&#x2F;q1mi&#x2F;hello库的最新版本，然后在项目目录下执行go mod download下载依赖包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">holiday $ go mod download</span><br></pre></td></tr></table></figure><p>如果不输出其它提示信息就说明依赖已经下载成功，此时go.mod文件已经变成如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello v0.1.1</span><br></pre></td></tr></table></figure><p>从中我们可以知道最新的版本号是v0.1.1。如果事先知道依赖包的具体版本号，可以直接在go.mod中指定需要的版本然后再执行go mod download下载。</p><p>这种方法同样支持指定想要下载的commit进行下载，例如直接在go.mod文件中按如下方式指定commit hash，这里只写出来了commit hash的前7位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com/q1mi/hello 2ccfadda</span><br></pre></td></tr></table></figure><p>执行go mod download下载完依赖后，go.mod文件中对应的版本信息会自动更新为类似下面的格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3</span><br></pre></td></tr></table></figure><p>下载好要使用的依赖包之后，我们现在就可以在holiday&#x2F;main.go文件中使用这个包了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/q1mi/hello&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;现在是假期时间...&quot;)</span><br><span class="line"></span><br><span class="line">hello.SayHi() // 调用hello包的SayHi函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码编译执行，就能看到执行结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday $ go build</span><br><span class="line">holiday $ ./holiday</span><br><span class="line">现在是假期时间...</span><br><span class="line">你好，我是七米。很高兴认识你。</span><br></pre></td></tr></table></figure><h3 id="go-mod文件"><a href="#go-mod文件" class="headerlink" title="go.mod文件"></a>go.mod文件</h3><p>go.mod文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require module/path v1.2.3</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>require：声明依赖的关键字</li><li>module&#x2F;path：依赖包的引入路径</li><li>v1.2.3：依赖包的版本号。支持以下几种格式：<ul><li>latest：最新版本</li><li>v1.0.0：详细版本号</li><li>commit hash：指定某次commit hash</li></ul></li></ul><p>引入某些没有发布过tag版本标识的依赖包时，go.mod中记录的依赖版本信息就会出现类似v0.0.0-20210218074646-139b0bcd549d的格式，由版本号、commit时间和commit的hash值组成。</p><p><img src="/module_version_info.png" alt="alt text"></p><h3 id="go-sum文件"><a href="#go-sum文件" class="headerlink" title="go.sum文件"></a>go.sum文件</h3><p>使用go module下载了依赖后，项目目录下还会生成一个go.sum文件，这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。go.sum文件内容通常是以类似下面的格式出现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; &lt;version&gt; &lt;hash&gt;</span><br><span class="line">&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;</span><br></pre></td></tr></table></figure><p>不同于其他语言提供的基于中心的包管理机制，例如 npm 和 pypi等，Go并没有提供一个中央仓库来管理所有依赖包，而是采用分布式的方式来管理包。为了防止依赖包被非法篡改，Go module 引入了go.sum机制来对依赖包进行校验。</p><h3 id="依赖保存位置"><a href="#依赖保存位置" class="headerlink" title="依赖保存位置"></a>依赖保存位置</h3><p>Go module 会把下载到本地的依赖包会以类似下面的形式保存在 $GOPATH&#x2F;pkg&#x2F;mod目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mod</span><br><span class="line">├── cache</span><br><span class="line">├── cloud.google.com</span><br><span class="line">├── github.com</span><br><span class="line">    └──q1mi</span><br><span class="line">          ├── hello@v0.0.0-20210218074646-139b0bcd549d</span><br><span class="line">          ├── hello@v0.1.1</span><br><span class="line">          └── hello@v0.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果想清除所有本地已缓存的依赖包数据，可以执行 go clean -modcache 命令。</p><h2 id="使用go-module发布包"><a href="#使用go-module发布包" class="headerlink" title="使用go module发布包"></a>使用go module发布包</h2><p>在上面的小节中我们学习了如何在项目中引入别人提供的依赖包，那么当我们想要在社区发布一个自己编写的代码包或者在公司内部编写一个供内部使用的公用组件时，我们该怎么做呢？接下来，我们就一起编写一个代码包并将它发布到github.com仓库，让它能够被全球的Go语言开发者使用。</p><p>我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为hello的项目为例进行演示。这个hello包将对外提供一个名为SayHi的函数，它的作用非常简单就是向调用者发去问候。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/q1mi/hello</span><br><span class="line">$ cd hello</span><br></pre></td></tr></table></figure><p>我们当前位于hello项目目录下，执行下面的命令初始化项目，创建go.mod文件。需要注意的是这里定义项目的引入路径为github.com&#x2F;q1mi&#x2F;hello，读者在自行测试时需要将这部分替换为自己的仓库路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello $ go mod init github.com/q1mi/hello</span><br><span class="line">go: creating new go.mod: module github.com/q1mi/hello</span><br></pre></td></tr></table></figure><p>接下来我们在该项目根目录下创建 hello.go 文件，添加下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package hello</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func SayHi() &#123;</span><br><span class="line">fmt.Println(&quot;你好，我是七米。很高兴认识你。&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该项目的代码 push 到仓库的远端分支，这样就对外发布了一个Go包。其他的开发者可以通过github.com&#x2F;q1mi&#x2F;hello这个引入路径下载并使用这个包了。</p><p>一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello $ git tag -a v0.1.0 -m &quot;release version v0.1.0&quot;</span><br><span class="line">hello $ git push origin v0.1.0</span><br></pre></td></tr></table></figure><p>经过上面的操作我们就发布了一个版本号为v0.1.0的版本。</p><p>Go modules中建议使用语义化版本控制，其建议的版本号格式如下：</p><p><img src="/version_number.png" alt="alt text"></p><p>其中：</p><ul><li>主版本号：发布了不兼容的版本迭代时递增（breaking changes）。</li><li>次版本号：发布了功能性更新时递增。</li><li>修订号：发布了bug修复类更新时递增</li></ul><h3 id="发布新的主版本"><a href="#发布新的主版本" class="headerlink" title="发布新的主版本"></a>发布新的主版本</h3><p>现在我们的hello项目要进行与之前版本不兼容的更新，我们计划让SayHi函数支持向指定人发出问候。更新后的SayHi函数内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package hello</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// SayHi 向指定人打招呼的函数</span><br><span class="line">func SayHi(name string) &#123;</span><br><span class="line">fmt.Printf(&quot;你好%s，我是七米。很高兴认识你。\n&quot;, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的v2版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// hello/go.mod</span><br><span class="line"></span><br><span class="line">module github.com/q1mi/hello/v2</span><br><span class="line"></span><br><span class="line">go 1.16</span><br></pre></td></tr></table></figure><p>把修改后的代码提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello $ git add .</span><br><span class="line">hello $ git commit -m &quot;feat: SayHi现在支持给指定人打招呼啦&quot;</span><br><span class="line">hello $ git push</span><br></pre></td></tr></table></figure><p>打好 tag 推送到远程仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello $ git tag -a v2.0.0 -m &quot;release version v2.0.0&quot;</span><br><span class="line">hello $ git push origin v2.0.0</span><br></pre></td></tr></table></figure><p>这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用v2版本的代码包的用户只需按修改后的引入路径下载即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/q1mi/hello/v2@v2.0.0</span><br></pre></td></tr></table></figure><p>在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/q1mi/hello/v2&quot; // 引入v2版本</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;现在是假期时间...&quot;)</span><br><span class="line"></span><br><span class="line">hello.SayHi(&quot;张三&quot;) // v2版本的SayHi函数需要传入字符串参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="废弃已发布版本"><a href="#废弃已发布版本" class="headerlink" title="废弃已发布版本"></a>废弃已发布版本</h3><p>如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用retract声明废弃的版本。例如我们在hello&#x2F;go.mod文件中按如下方式声明即可对外废弃v0.1.2版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/hello</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">retract v0.1.2</span><br></pre></td></tr></table></figure><p>用户使用go get下载v0.1.2版本时就会收到提示，催促其升级到其他版本。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之结构体(二)</title>
      <link href="/posts/4a17b009.html"/>
      <url>/posts/4a17b009.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><p>方法的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Person 结构体</span><br><span class="line">type Person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//NewPerson 构造函数</span><br><span class="line">func NewPerson(name string, age int8) *Person &#123;</span><br><span class="line">return &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Dream Person做梦的方法</span><br><span class="line">func (p Person) Dream() &#123;</span><br><span class="line">fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 := NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SetAge 设置p的年龄</span><br><span class="line">// 使用指针接收者</span><br><span class="line">func (p *Person) SetAge(newAge int8) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">p1 := NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">fmt.Println(p1.age) // 25</span><br><span class="line">p1.SetAge(30)</span><br><span class="line">fmt.Println(p1.age) // 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SetAge2 设置p的年龄</span><br><span class="line">// 使用值接收者</span><br><span class="line">func (p Person) SetAge2(newAge int8) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 := NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) // 25</span><br><span class="line">p1.SetAge2(30) // (*p1).SetAge2(30)</span><br><span class="line">fmt.Println(p1.age) // 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ul><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ul><h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//MyInt 将int定义为自定义MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">//SayHello 为MyInt添加一个SayHello的方法</span><br><span class="line">func (m MyInt) SayHello() &#123;</span><br><span class="line">fmt.Println(&quot;Hello, 我是一个int。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var m1 MyInt</span><br><span class="line">m1.SayHello() //Hello, 我是一个int。</span><br><span class="line">m1 = 100</span><br><span class="line">fmt.Printf(&quot;%#v  %T\n&quot;, m1, m1) //100  main.MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Person 结构体Person类型</span><br><span class="line">type Person struct &#123;</span><br><span class="line">string</span><br><span class="line">int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line">&quot;小王子&quot;,</span><br><span class="line">18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, p1)        //main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span><br><span class="line">fmt.Println(p1.string, p1.int) //北京 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province string</span><br><span class="line">City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Gender  string</span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   &quot;小王子&quot;,</span><br><span class="line">Gender: &quot;男&quot;,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: &quot;山东&quot;,</span><br><span class="line">City:     &quot;威海&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;user1=%#v\n&quot;, user1)//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h3><p>上面user结构体中嵌套的Address结构体也可以采用匿名字段的方式，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province string</span><br><span class="line">City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Gender  string</span><br><span class="line">Address //匿名字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var user2 User</span><br><span class="line">user2.Name = &quot;小王子&quot;</span><br><span class="line">user2.Gender = &quot;男&quot;</span><br><span class="line">user2.Address.Province = &quot;山东&quot;    // 匿名字段默认使用类型名作为字段名</span><br><span class="line">user2.City = &quot;威海&quot;                // 匿名字段可以省略</span><br><span class="line">fmt.Printf(&quot;user2=%#v\n&quot;, user2) //user2=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province   string</span><br><span class="line">City       string</span><br><span class="line">CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Email 邮箱结构体</span><br><span class="line">type Email struct &#123;</span><br><span class="line">Account    string</span><br><span class="line">CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name   string</span><br><span class="line">Gender string</span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var user3 User</span><br><span class="line">user3.Name = &quot;沙河娜扎&quot;</span><br><span class="line">user3.Gender = &quot;男&quot;</span><br><span class="line">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span><br><span class="line">user3.Address.CreateTime = &quot;2000&quot; //指定Address结构体中的CreateTime</span><br><span class="line">user3.Email.CreateTime = &quot;2000&quot;   //指定Email结构体中的CreateTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Animal 动物</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Animal) move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会动！\n&quot;, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Dog 狗</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">Feet    int8</span><br><span class="line">*Animal //通过嵌套匿名结构体实现继承</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) wang() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: 4,</span><br><span class="line">Animal: &amp;Animal&#123; //注意嵌套的是结构体指针</span><br><span class="line">name: &quot;乐乐&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() //乐乐会汪汪汪~</span><br><span class="line">d1.move() //乐乐会动！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之结构体(一)</title>
      <link href="/posts/4a17b009.html"/>
      <url>/posts/4a17b009.html</url>
      
        <content type="html"><![CDATA[<hr><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为int类型</span><br><span class="line">type MyInt int</span><br></pre></td></tr></table></figure><p>通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></table></figure><h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//类型定义</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">type MyInt = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a NewInt</span><br><span class="line">var b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:main.NewInt</span><br><span class="line">fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p><p>Go语言中通过struct来实现面向对象。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个Person（人）结构体，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person1 struct &#123;</span><br><span class="line">name, city string</span><br><span class="line">age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p1 person</span><br><span class="line">p1.name = &quot;沙河娜扎&quot;</span><br><span class="line">p1.city = &quot;北京&quot;</span><br><span class="line">p1.age = 18</span><br><span class="line">fmt.Printf(&quot;p1=%v\n&quot;, p1)  //p1=&#123;沙河娜扎 北京 18&#125;</span><br><span class="line">fmt.Printf(&quot;p1=%#v\n&quot;, p1) //p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">     </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line">func main() &#123;</span><br><span class="line">    var user struct&#123;Name string; Age int&#125;</span><br><span class="line">    user.Name = &quot;小王子&quot;</span><br><span class="line">    user.Age = 18</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出p2是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">p2.name = &quot;小王子&quot;</span><br><span class="line">p2.age = 28</span><br><span class="line">p2.city = &quot;上海&quot;</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p3)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">p3.name = &quot;七米&quot;</span><br><span class="line">p3.age = 30</span><br><span class="line">p3.city = &quot;成都&quot;</span><br><span class="line">fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p4 person</span><br><span class="line">fmt.Printf(&quot;p4=%#v\n&quot;, p4) //p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: &quot;小王子&quot;,</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p5=%#v\n&quot;, p5) //p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">name: &quot;小王子&quot;,</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p6=%#v\n&quot;, p6) //p6=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p7=%#v\n&quot;, p7) //p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">&quot;沙河娜扎&quot;,</span><br><span class="line">&quot;北京&quot;,</span><br><span class="line">28,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p8=%#v\n&quot;, p8) //p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ul><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ul><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">a int8</span><br><span class="line">b int8</span><br><span class="line">c int8</span><br><span class="line">d int8</span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">1, 2, 3, 4,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)</span><br><span class="line">fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)</span><br><span class="line">fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)</span><br><span class="line">fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>空结构体是不占用空间的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v struct&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  // 0</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func newPerson(name, city string, age int8) *person &#123;</span><br><span class="line">return &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(&quot;张三&quot;, &quot;沙河&quot;, 90)</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, p9) //&amp;main.person&#123;name:&quot;张三&quot;, city:&quot;沙河&quot;, age:90&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之文件操作</title>
      <link href="/posts/4a17b011.html"/>
      <url>/posts/4a17b011.html</url>
      
        <content type="html"><![CDATA[<hr><p>本文主要介绍了Go语言中文件读写的相关操作。</p><p>文件是什么？</p><p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p>os.Open()函数能够打开一个文件，返回一个*File和一个err。对得到的文件实例调用close()方法能够关闭文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 只读方式打开当前目录下的main.go文件</span><br><span class="line">file, err := os.Open(&quot;./main.go&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed!, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (f *File) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF。 举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">// 只读方式打开当前目录下的main.go文件</span><br><span class="line">file, err := os.Open(&quot;./main.go&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed!, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">// 使用Read方法读取数据</span><br><span class="line">var tmp = make([]byte, 128)</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line">if err == io.EOF &#123;</span><br><span class="line">fmt.Println(&quot;文件读完了&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;读取了%d字节数据\n&quot;, n)</span><br><span class="line">fmt.Println(string(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">// 只读方式打开当前目录下的main.go文件</span><br><span class="line">file, err := os.Open(&quot;./main.go&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed!, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">// 循环读取文件</span><br><span class="line">var content []byte</span><br><span class="line">var tmp = make([]byte, 128)</span><br><span class="line">for &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line">if err == io.EOF &#123;</span><br><span class="line">fmt.Println(&quot;文件读完了&quot;)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">content = append(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(string(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio 是在 file 的基础上封装了一层API，支持更多的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">file, err := os.Open(&quot;./xx.txt&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">scanner := bufio.NewScanner(file) // MaxScanTokenSize = 64 * 1024</span><br><span class="line">for scanner.Scan() &#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">if err := scanner.Err(); err != nil &#123;</span><br><span class="line">fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h2><p>os（Go1.16之前io&#x2F;ioutil）包的ReadFile函数能够读取完整的文件，只需要将文件名作为参数传入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// os.ReadFile 读取整个文件</span><br><span class="line">func main() &#123;</span><br><span class="line">content, err := os.ReadFile(&quot;./main.go&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(string(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p>os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func OpenFile(name string, flag int, perm FileMode) (*File, error) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p>name：要打开的文件名 flag：打开文件的模式。 模式有以下几种：<br>模式 含义<br>os.O_WRONLY 只写<br>os.O_CREATE 创建文件<br>os.O_RDONLY 只读<br>os.O_RDWR 读写<br>os.O_TRUNC 清空<br>os.O_APPEND 追加</p><p>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">str := &quot;hello 沙河&quot;</span><br><span class="line">file.Write([]byte(str))       //写入字节切片数据</span><br><span class="line">file.WriteString(&quot;hello 小王子&quot;) //直接写入字符串数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="os-WriteFile"><a href="#os-WriteFile" class="headerlink" title="os.WriteFile"></a>os.WriteFile</h2><p>os（Go1.16之前io&#x2F;ioutil）包的os.WriteFile函数可直接向文件写入指定内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func writeFile() &#123;</span><br><span class="line">str := &quot;hello 沙河&quot;</span><br><span class="line">err := os.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;write file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;open file failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">writer.WriteString(&quot;hello沙河\n&quot;) //将数据先写入缓存</span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() //将缓存中的内容写入文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之函数(二)</title>
      <link href="/posts/4a17b007.html"/>
      <url>/posts/4a17b007.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//定义全局变量num</span><br><span class="line">var num int64 = 10</span><br><span class="line"></span><br><span class="line">func testGlobalVar() &#123;</span><br><span class="line">fmt.Printf(&quot;num=%d\n&quot;, num) //函数中可以访问全局变量num</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">testGlobalVar() //num=10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar() &#123;</span><br><span class="line">//定义一个函数局部变量x,仅在该函数内生效</span><br><span class="line">var x int64 = 100</span><br><span class="line">fmt.Printf(&quot;x=%d\n&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) // 此时无法使用变量x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//定义全局变量num</span><br><span class="line">var num int64 = 10</span><br><span class="line"></span><br><span class="line">func testNum() &#123;</span><br><span class="line">num := 100</span><br><span class="line">fmt.Printf(&quot;num=%d\n&quot;, num) // 函数中优先使用局部变量</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">testNum() // num=100</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar2(x, y int) &#123;</span><br><span class="line">fmt.Println(x, y) //函数的参数也是只在本函数中生效</span><br><span class="line">if x &gt; 0 &#123;</span><br><span class="line">z := 100 //变量z只在if语句块生效</span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line">//fmt.Println(z)//此处无法使用变量z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar3() &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(i) //变量i只在当前for语句块中生效</span><br><span class="line">&#125;</span><br><span class="line">//fmt.Println(i) //此处无法使用变量i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>我们可以使用type关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type calculation func(int, int) int</span><br></pre></td></tr></table></figure><p>上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sub(x, y int) int &#123;</span><br><span class="line">return x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var c calculation               // 声明一个calculation类型的变量c</span><br><span class="line">c = add                         // 把add赋值给c</span><br><span class="line">fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation</span><br><span class="line">fmt.Println(c(1, 2))            // 像调用add一样调用c</span><br><span class="line"></span><br><span class="line">f := add                        // 将函数add赋值给变量f</span><br><span class="line">fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int</span><br><span class="line">fmt.Println(f(10, 20))          // 像调用add一样调用f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>函数可以作为参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line">func calc(x, y int, op func(int, int) int) int &#123;</span><br><span class="line">return op(x, y)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">ret2 := calc(10, 20, add)</span><br><span class="line">fmt.Println(ret2) //30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数也可以作为返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func do(s string) (func(int, int) int, error) &#123;</span><br><span class="line">switch s &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return add, nil</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">return sub, nil</span><br><span class="line">default:</span><br><span class="line">err := errors.New(&quot;无法识别的操作符&quot;)</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">// 将匿名函数保存到变量</span><br><span class="line">add := func(x, y int) &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(10, 20) // 通过变量调用匿名函数</span><br><span class="line"></span><br><span class="line">//自执行函数：匿名函数定义完加()直接执行</span><br><span class="line">func(x, y int) &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(10, 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包&#x3D;函数+引用环境。 首先我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func adder() func(int) int &#123;</span><br><span class="line">var x int</span><br><span class="line">return func(y int) int &#123;</span><br><span class="line">x += y</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var f = adder()</span><br><span class="line">fmt.Println(f(10)) //10</span><br><span class="line">fmt.Println(f(20)) //30</span><br><span class="line">fmt.Println(f(30)) //60</span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(40)) //40</span><br><span class="line">fmt.Println(f1(50)) //90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 闭包进阶示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func adder2(x int) func(int) int &#123;</span><br><span class="line">return func(y int) int &#123;</span><br><span class="line">x += y</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var f = adder2(10)</span><br><span class="line">fmt.Println(f(10)) //20</span><br><span class="line">fmt.Println(f(20)) //40</span><br><span class="line">fmt.Println(f(30)) //70</span><br><span class="line"></span><br><span class="line">f1 := adder2(20)</span><br><span class="line">fmt.Println(f1(40)) //60</span><br><span class="line">fmt.Println(f1(50)) //110</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func makeSuffixFunc(suffix string) func(string) string &#123;</span><br><span class="line">return func(name string) string &#123;</span><br><span class="line">if !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line">return name + suffix</span><br><span class="line">&#125;</span><br><span class="line">return name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)</span><br><span class="line">txtFunc := makeSuffixFunc(&quot;.txt&quot;)</span><br><span class="line">fmt.Println(jpgFunc(&quot;test&quot;)) //test.jpg</span><br><span class="line">fmt.Println(txtFunc(&quot;test&quot;)) //test.txt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func calc(base int) (func(int) int, func(int) int) &#123;</span><br><span class="line">add := func(i int) int &#123;</span><br><span class="line">base += i</span><br><span class="line">return base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := func(i int) int &#123;</span><br><span class="line">base -= i</span><br><span class="line">return base</span><br><span class="line">&#125;</span><br><span class="line">return add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f1, f2 := calc(10)</span><br><span class="line">fmt.Println(f1(1), f2(2)) //11 9</span><br><span class="line">fmt.Println(f1(3), f2(4)) //12 8</span><br><span class="line">fmt.Println(f1(5), f2(6)) //13 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记闭包&#x3D;函数+引用环境。</p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。<br>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;start&quot;)</span><br><span class="line">defer fmt.Println(1)</span><br><span class="line">defer fmt.Println(2)</span><br><span class="line">defer fmt.Println(3)</span><br><span class="line">fmt.Println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<br><img src="/defer.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之函数</title>
      <link href="/posts/4a17b005.html"/>
      <url>/posts/4a17b005.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go语言中定义函数使用func关键字，具体格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func 函数名(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func intSum(x int, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sayHello() &#123;</span><br><span class="line">fmt.Println(&quot;Hello 沙河&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret := intSum(10, 20)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func intSum(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加…来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func intSum2(x ...int) int &#123;</span><br><span class="line">fmt.Println(x) //x是一个切片</span><br><span class="line">sum := 0</span><br><span class="line">for _, v := range x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 := intSum2()</span><br><span class="line">ret2 := intSum2(10)</span><br><span class="line">ret3 := intSum2(10, 20)</span><br><span class="line">ret4 := intSum2(10, 20, 30)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60</span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func intSum3(x int, y ...int) int &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line">for _, v := range y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 := intSum3(100)</span><br><span class="line">ret6 := intSum3(100, 10)</span><br><span class="line">ret7 := intSum3(100, 10, 20)</span><br><span class="line">ret8 := intSum3(100, 10, 20, 30)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160</span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言中通过return关键字向外输出返回值。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func calc(x, y int) (int, int) &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line">return sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func calc(x, y int) (sum, sub int) &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值补充"><a href="#返回值补充" class="headerlink" title="返回值补充"></a>返回值补充</h3><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(x string) []int &#123;</span><br><span class="line">if x == &quot;&quot; &#123;</span><br><span class="line">return nil // 没必要返回[]int&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之map</title>
      <link href="/posts/4a17b010.html"/>
      <url>/posts/4a17b010.html</url>
      
        <content type="html"><![CDATA[<hr><p>Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。<br>Go语言中 map的定义语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make(map[KeyType]ValueType, [cap])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap := make(map[string]int, 8)</span><br><span class="line">scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[&quot;小明&quot;])</span><br><span class="line">fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line">type of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">userInfo := map[string]string&#123;</span><br><span class="line">&quot;username&quot;: &quot;沙河小王子&quot;,</span><br><span class="line">&quot;password&quot;: &quot;123456&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := map[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap := make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br><span class="line">v, ok := scoreMap[&quot;张三&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;查无此人&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用for range遍历map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap := make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">for k, v := range scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap := make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">for k := range scoreMap &#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p><h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">scoreMap := make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] = 90</span><br><span class="line">scoreMap[&quot;小明&quot;] = 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] = 60</span><br><span class="line">delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</span><br><span class="line">for k,v := range scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) //初始化随机数种子</span><br><span class="line"></span><br><span class="line">var scoreMap = make(map[string]int, 200)</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(&quot;stu%02d&quot;, i) //生成stu开头的字符串</span><br><span class="line">value := rand.Intn(100)          //生成0~99的随机整数</span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line">//取出map中的所有key存入切片keys</span><br><span class="line">var keys = make([]string, 0, 200)</span><br><span class="line">for key := range scoreMap &#123;</span><br><span class="line">keys = append(keys, key)</span><br><span class="line">&#125;</span><br><span class="line">//对切片进行排序</span><br><span class="line">sort.Strings(keys)</span><br><span class="line">//按照排序后的key遍历map</span><br><span class="line">for _, key := range keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var mapSlice = make([]map[string]string, 3)</span><br><span class="line">for index, value := range mapSlice &#123;</span><br><span class="line">fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;after init&quot;)</span><br><span class="line">// 对切片中的map元素进行初始化</span><br><span class="line">mapSlice[0] = make(map[string]string, 10)</span><br><span class="line">mapSlice[0][&quot;name&quot;] = &quot;小王子&quot;</span><br><span class="line">mapSlice[0][&quot;password&quot;] = &quot;123456&quot;</span><br><span class="line">mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;</span><br><span class="line">for index, value := range mapSlice &#123;</span><br><span class="line">fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之指针</title>
      <link href="/posts/4a17b005.html"/>
      <url>/posts/4a17b005.html</url>
      
        <content type="html"><![CDATA[<hr><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&amp;（取地址）和*（根据地址取值）。</p><h2 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h2><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<em>int、</em>int64、*string等。</p><p>取变量指针的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    // v的类型为T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为T</li><li>ptr:用于接收地址的变量，ptr的类型就为<em>T，称做T的指针类型。</em>代表指针。</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := 10</span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) // a:10 ptr:0xc00001a078</span><br><span class="line">fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int</span><br><span class="line">fmt.Println(&amp;b)                    // 0xc00000e018</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下b :&#x3D; &amp;a的图示： </p><p><img src="/images/ptr.png" alt="Untitled"></p><h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">//指针取值</span><br><span class="line">a := 10</span><br><span class="line">b := &amp;a // 取变量a的地址，将指针保存到b中</span><br><span class="line">fmt.Printf(&quot;type of b:%T\n&quot;, b)</span><br><span class="line">c := *b // 指针取值（根据指针去内存取值）</span><br><span class="line">fmt.Printf(&quot;type of c:%T\n&quot;, c)</span><br><span class="line">fmt.Printf(&quot;value of c:%v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type of b:*int</span><br><span class="line">type of c:int</span><br><span class="line">value of c:10</span><br></pre></td></tr></table></figure><p>总结： 取地址操作符&amp;和取值操作符<em>是一对互补操作符，&amp;取出地址，</em>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p>指针传值示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func modify1(x int) &#123;</span><br><span class="line">x = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modify2(x *int) &#123;</span><br><span class="line">*x = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := 10</span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) // 10</span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) // 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>我们先来看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">*a = 100</span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">var b map[string]int</span><br><span class="line">b[&quot;沙河娜扎&quot;] = 100</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := new(int)</span><br><span class="line">b := new(bool)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, a) // *int</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, b) // *bool</span><br><span class="line">fmt.Println(*a)       // 0</span><br><span class="line">fmt.Println(*b)       // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">a = new(int)</span><br><span class="line">*a = 10</span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var b map[string]int</span><br><span class="line">b = make(map[string]int, 10)</span><br><span class="line">b[&quot;沙河娜扎&quot;] = 100</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h3><ul><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之切片</title>
      <link href="/posts/4a17b0013.html"/>
      <url>/posts/4a17b0013.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">arraySum</span>(x [<span class="number">3</span>]int) int&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := range x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。再比如，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []string              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []int&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []bool&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []bool&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a == nil)       <span class="comment">//true</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b == nil)       <span class="comment">//false</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c == nil)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><p><strong>简单切片表达式</strong></p><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="title function_">len</span>(s), <span class="title function_">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(s):<span class="number">2</span> <span class="title function_">cap</span>(s):<span class="number">4</span></span><br></pre></td></tr></table></figure><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="title function_">len</span>(s), <span class="title function_">cap</span>(s))</span><br><span class="line">s2 := s[<span class="number">3</span>:<span class="number">4</span>]  <span class="comment">// 索引的上限是cap(s)而不是len(s)</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;</span>, s2, <span class="title function_">len</span>(s2), <span class="title function_">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(s):<span class="number">2</span> <span class="title function_">cap</span>(s):<span class="number">4</span></span><br><span class="line"><span class="attr">s2</span>:[<span class="number">5</span>] <span class="title function_">len</span>(s2):<span class="number">1</span> <span class="title function_">cap</span>(s2):<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>完整切片表达式</strong></p><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">5</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="title function_">len</span>(t), <span class="title function_">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">t</span>:[<span class="number">2</span> <span class="number">3</span>] <span class="title function_">len</span>(t):<span class="number">2</span> <span class="title function_">cap</span>(t):<span class="number">4</span></span><br></pre></td></tr></table></figure><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">make</span>([]T, size, cap)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := <span class="title function_">make</span>([]int, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">fmt.<span class="title class_">Println</span>(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。</p><p>(.&#x2F;images&#x2F;slice_01.png)</p><p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p><p>(.&#x2F;images&#x2F;slice_02.png)</p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。<br>切片唯一合法的比较操作是和<code>nil</code>比较。<br>一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []int         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []int&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="title function_">make</span>([]int, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">s1 := <span class="title function_">make</span>([]int, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := []int&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(s); i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := range s &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> s []int</span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []int&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="title function_">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []int</span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []int&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="title function_">make</span>([]int)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="title function_">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []int</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="title function_">append</span>(numSlice, i)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="title function_">len</span>(numSlice), <span class="title function_">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]  <span class="attr">len</span>:<span class="number">1</span>  <span class="attr">cap</span>:<span class="number">1</span>  <span class="attr">ptr</span>:<span class="number">0xc0000a8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span>]  <span class="attr">len</span>:<span class="number">2</span>  <span class="attr">cap</span>:<span class="number">2</span>  <span class="attr">ptr</span>:<span class="number">0xc0000a8040</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]  <span class="attr">len</span>:<span class="number">3</span>  <span class="attr">cap</span>:<span class="number">4</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]  <span class="attr">len</span>:<span class="number">4</span>  <span class="attr">cap</span>:<span class="number">4</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]  <span class="attr">len</span>:<span class="number">5</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]  <span class="attr">len</span>:<span class="number">6</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]  <span class="attr">len</span>:<span class="number">7</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]  <span class="attr">len</span>:<span class="number">8</span>  <span class="attr">cap</span>:<span class="number">8</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]  <span class="attr">len</span>:<span class="number">9</span>  <span class="attr">cap</span>:<span class="number">16</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]  <span class="attr">len</span>:<span class="number">10</span>  <span class="attr">cap</span>:<span class="number">16</span>  <span class="attr">ptr</span>:<span class="number">0xc0000b8000</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []string</span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []string&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;</span><br><span class="line">citySlice = <span class="title function_">append</span>(citySlice, a...)</span><br><span class="line">fmt.<span class="title class_">Println</span>(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="property">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> cap &gt; doublecap &#123;</span><br><span class="line">newcap = cap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="property">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = cap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a><strong>使用copy()函数复制切片</strong></h2><p>首先我们来看一个问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">copy</span>(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="title function_">make</span>([]int, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="title function_">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []int&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="title function_">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之数组</title>
      <link href="/posts/4a17b006.html"/>
      <url>/posts/4a17b006.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]int</span><br></pre></td></tr></table></figure><h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>，数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。<code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]int</span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]int</span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]int                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]int&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]int</span><br><span class="line"><span class="keyword">var</span> numArray = [...]int&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [...]int&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]string&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(a); i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := range a &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := range a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := range v1 &#123;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\t&quot;</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]string&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a><strong>数组是值类型</strong></h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">modifyArray</span>(<span class="params">x [<span class="number">3</span>]int</span>) &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">modifyArray2</span>(<span class="params">x [<span class="number">3</span>][<span class="number">2</span>]int</span>) &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">a := [<span class="number">3</span>]int&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="title function_">modifyArray</span>(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]int&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">modifyArray2</span>(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组支持 “&#x3D;&#x3D;”、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言fmt.printf使用指南</title>
      <link href="/posts/4a17b0017.html"/>
      <url>/posts/4a17b0017.html</url>
      
        <content type="html"><![CDATA[<p>fmt标准库是我们在学习Go语言过程中接触最早最频繁的一个了，本文介绍了fmt包的一些常用函数。</p><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>fmt包实现了类似C语言printf和scanf的格式化I&#x2F;O。主要分为向外输出内容和获取输入内容两大部分。</p><h3 id="向外输出"><a href="#向外输出" class="headerlink" title="向外输出"></a>向外输出</h3><p>标准库<code>fmt</code>提供了以下几种输出相关函数。</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p><code>Print</code>系列函数会将内容输出到系统的标准输出，区别在于<code>Print</code>函数直接输出内容，<code>Printf</code>函数支持格式化输出字符串，<code>Println</code>函数会在输出内容的结尾添加一个换行符。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Print</span>(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Printf</span>(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Println</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>举个简单的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">fmt.<span class="title class_">Print</span>(<span class="string">&quot;在终端打印该信息。&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;我是：%s\n&quot;</span>, name)</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;在终端打印单独一行显示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在终端打印该信息。我是：沙河小王子</span><br><span class="line">在终端打印单独一行显示</span><br></pre></td></tr></table></figure><h3 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h3><p><code>Fprint</code>系列函数会将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，我们通常用这个函数往文件中写入内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Fprint</span>(w io.<span class="property">Writer</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fprintf</span>(w io.<span class="property">Writer</span>, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fprintln</span>(w io.<span class="property">Writer</span>, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向标准输出写入内容</span></span><br><span class="line">fmt.<span class="title class_">Fprintln</span>(os.<span class="property">Stdout</span>, <span class="string">&quot;向标准输出写入内容&quot;</span>)</span><br><span class="line">fileObj, err := os.<span class="title class_">OpenFile</span>(<span class="string">&quot;./xx.txt&quot;</span>, os.<span class="property">O_CREATE</span>|os.<span class="property">O_WRONLY</span>|os.<span class="property">O_APPEND</span>, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line"><span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.<span class="title class_">Fprintf</span>(fileObj, <span class="string">&quot;往文件中写如信息：%s&quot;</span>, name)</span><br></pre></td></tr></table></figure><p>注意，只要满足<code>io.Writer</code>接口的类型都支持写入。</p><h3 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h3><p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Sprint</span>(a ...interface&#123;&#125;) string</span><br><span class="line">func <span class="title class_">Sprintf</span>(format string, a ...interface&#123;&#125;) string</span><br><span class="line">func <span class="title class_">Sprintln</span>(a ...interface&#123;&#125;) string</span><br></pre></td></tr></table></figure><p>简答的示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := fmt.<span class="title class_">Sprint</span>(<span class="string">&quot;沙河小王子&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;沙河小王子&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">s2 := fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;name:%s,age:%d&quot;</span>, name, age)</span><br><span class="line">s3 := fmt.<span class="title class_">Sprintln</span>(<span class="string">&quot;沙河小王子&quot;</span>)</span><br><span class="line">fmt.<span class="title class_">Println</span>(s1, s2, s3)</span><br></pre></td></tr></table></figure><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Errorf</span>(format string, a ...interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>通常使用这种方式来自定义错误类型，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.<span class="title class_">Errorf</span>(<span class="string">&quot;这是一个错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e := errors.<span class="title class_">New</span>(<span class="string">&quot;原始错误e&quot;</span>)</span><br><span class="line">w := fmt.<span class="title class_">Errorf</span>(<span class="string">&quot;Wrap了一个错误%w&quot;</span>, e)</span><br></pre></td></tr></table></figure><h2 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h2><p><code>*printf</code>系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。</p><h3 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%v</td><td>值的默认格式表示</td></tr><tr><td>%+v</td><td>类似%v，但输出结构体时会添加字段名</td></tr><tr><td>%#v</td><td>值的Go语法表示</td></tr><tr><td>%T</td><td>打印值的类型</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, <span class="number">100</span>)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">o := struct&#123; name string &#125;&#123;<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%T\n&quot;</span>, o)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;100%%\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;小王子&#125;</span><br><span class="line">struct &#123; name string &#125;&#123;<span class="attr">name</span>:<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">struct &#123; name string &#125;</span><br><span class="line"><span class="number">100</span>%</span><br></pre></td></tr></table></figure><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%t</td><td>true或false</td></tr></tbody></table><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>表示为二进制</td></tr><tr><td>%c</td><td>该值对应的unicode码值</td></tr><tr><td>%d</td><td>表示为十进制</td></tr><tr><td>%o</td><td>表示为八进制</td></tr><tr><td>%x</td><td>表示为十六进制，使用a-f</td></tr><tr><td>%X</td><td>表示为十六进制，使用A-F</td></tr><tr><td>%U</td><td>表示为Unicode格式：U+1234，等价于”U+%04X”</td></tr><tr><td>%q</td><td>该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">65</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%c\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%d\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%o\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000001</span></span><br><span class="line">A</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure><h3 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%b</td><td>无小数部分、二进制指数的科学计数法，如-123456p-78</td></tr><tr><td>%e</td><td>科学计数法，如-1234.456e+78</td></tr><tr><td>%E</td><td>科学计数法，如-1234.456E+78</td></tr><tr><td>%f</td><td>有小数部分但无指数部分，如123.456</td></tr><tr><td>%F</td><td>等价于%f</td></tr><tr><td>%g</td><td>根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td></tr><tr><td>%G</td><td>根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">12.34</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%E\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%g\n&quot;</span>, f)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%G\n&quot;</span>, f)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6946802425218990p-<span class="number">49</span></span><br><span class="line"><span class="number">1.234000e+01</span></span><br><span class="line"><span class="number">1.234000E+01</span></span><br><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="number">12.34</span></span><br></pre></td></tr></table></figure><h3 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%s</td><td>直接输出字符串或者[]byte</td></tr><tr><td>%q</td><td>该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td></tr><tr><td>%x</td><td>每个字节用两字符十六进制数表示（使用a-f</td></tr><tr><td>%X</td><td>每个字节用两字符十六进制数表示（使用A-F）</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%q\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小王子</span><br><span class="line"><span class="string">&quot;小王子&quot;</span></span><br><span class="line">e5b08fe78e8be5ad90</span><br><span class="line"><span class="variable constant_">E5B08FE78E8BE5AD90</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%p</td><td>表示为十六进制，并加上前导的0x</td></tr><tr><td>示例代码如下：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#p\n&quot;</span>, &amp;a)</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc000094000</span></span><br><span class="line">c000094000</span><br></pre></td></tr></table></figure><h3 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h3><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%f</td><td>默认宽度，默认精度</td></tr><tr><td>%9f</td><td>宽度9，默认精度</td></tr><tr><td>%.2f</td><td>默认宽度，精度2</td></tr><tr><td>%9.2f</td><td>宽度9，精度2</td></tr><tr><td>%9.f</td><td>宽度9，精度0</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">12.34</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9.2f\n&quot;</span>, n)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%9.f\n&quot;</span>, n)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.340000</span></span><br><span class="line"><span class="number">12.34</span></span><br><span class="line">    <span class="number">12.34</span></span><br><span class="line">       <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="其他flag"><a href="#其他flag" class="headerlink" title="其他flag"></a>其他flag</h3><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>‘+’</td><td>总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td></tr><tr><td>’ ‘</td><td>对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td></tr><tr><td>‘-’</td><td>在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td></tr><tr><td>‘#’</td><td>八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td></tr><tr><td>‘0’</td><td>使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td></tr></tbody></table><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;小王子&quot;</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%-5s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%-5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%5.2s\n&quot;</span>, s)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%05s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>输出如下结果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小王子</span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">   小王</span><br><span class="line"><span class="number">00</span>小王子</span><br></pre></td></tr></table></figure><h2 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h2><p>Go语言<code>fmt</code>包下有<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p><h3 id="fmt-Scan"><a href="#fmt-Scan" class="headerlink" title="fmt.Scan"></a>fmt.Scan</h3><p>函数定签名如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scan</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li></ul><p>具体代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scan</span>(&amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scan</code>从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p><h3 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h3><p>函数签名如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scanf</span>(format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scanf</span>(<span class="string">&quot;1:%s 2:%d 3:%t&quot;</span>, &amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入<code>小王子</code>、<code>28</code>和<code>false</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line"><span class="number">1</span>:小王子 <span class="number">2</span>:<span class="number">28</span> <span class="number">3</span>:<span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scanf</code>不同于<code>fmt.Scan</code>简单的以空格作为输入数据的分隔符，<code>fmt.Scanf</code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p><p>例如，我们还是按照上个示例中以空格分隔的方式输入，<code>fmt.Scanf</code>就不能正确扫描到输入的数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>: <span class="attr">age</span>:<span class="number">0</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h3><p>函数签名如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Scanln</span>(a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>具体代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.<span class="title class_">Scanln</span>(&amp;name, &amp;age, &amp;married)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;扫描结果 name:%s age:%d married:%t \n&quot;</span>, name, age, married)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./scan_demo </span><br><span class="line">小王子 <span class="number">28</span> <span class="literal">false</span></span><br><span class="line">扫描结果 <span class="attr">name</span>:小王子 <span class="attr">age</span>:<span class="number">28</span> <span class="attr">married</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scanln</code>遇到回车就结束扫描了，这个比较常用。</p><h3 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a><strong>bufio.NewReader</strong></h3><p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用<code>bufio</code>包来实现。示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">bufioDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line">reader := bufio.<span class="title class_">NewReader</span>(os.<span class="property">Stdin</span>) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">fmt.<span class="title class_">Print</span>(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line">text, _ := reader.<span class="title class_">ReadString</span>(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">text = strings.<span class="title class_">TrimSpace</span>(text)</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a><strong>Fscan系列</strong></h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Fscan</span>(r io.<span class="property">Reader</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fscanln</span>(r io.<span class="property">Reader</span>, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Fscanf</span>(r io.<span class="property">Reader</span>, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><h3 id="Scaan系列"><a href="#Scaan系列" class="headerlink" title="Scaan系列"></a>Scaan系列</h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title class_">Sscan</span>(str string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Sscanln</span>(str string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">func <span class="title class_">Sscanf</span>(str string, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决go get下载包失败问题</title>
      <link href="/posts/4a17b008.html"/>
      <url>/posts/4a17b008.html</url>
      
        <content type="html"><![CDATA[<p>由于某些不可抗力的原因，国内使用<code>go get</code>命令安装包时会经常会出现timeout的问题。本文介绍几个常用的解决办法。</p><h2 id="从github克隆"><a href="#从github克隆" class="headerlink" title="从github克隆"></a>从github克隆</h2><p>golang在github上建立了一个镜像库，如<code>https://github.com/golang/net</code>就对应是 <code>https://golang.org/x/net</code>的镜像库。要下载<code>golang.org/x/net</code>包，可以在本地创建包的目录后使用<code>git clone</code>来拉取相应包的源代码文件，具体操作如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/golang.<span class="property">org</span>/x</span><br><span class="line">cd $GOPATH/src/golang.<span class="property">org</span>/x</span><br><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/golang/net.git</span></span><br></pre></td></tr></table></figure><h2 id="使用gopm"><a href="#使用gopm" class="headerlink" title="使用gopm"></a>使用gopm</h2><p>使用gopm可以从golang.org的一些镜像网站上下载。</p><h3 id="安装gopm"><a href="#安装gopm" class="headerlink" title="安装gopm"></a>安装gopm</h3><aside>💡 go get -u [github.com/gpmgo/gopm](http://github.com/gpmgo/gopm)</aside><h3 id="使用gopm安装第三方包"><a href="#使用gopm安装第三方包" class="headerlink" title="使用gopm安装第三方包"></a><strong>使用gopm安装第三方包</strong></h3><p>不加<code>-g</code>参数，会把依赖包下载<code>.vendor</code>目录下面；加上<code>-g</code>参数，可以把依赖包下载到<code>GOPATH</code>目录中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopm get -g golang.<span class="property">org</span>/x/net</span><br></pre></td></tr></table></figure><h2 id="使用goproxy"><a href="#使用goproxy" class="headerlink" title="使用goproxy"></a>使用goproxy</h2><p>Go的1.11版本以后 可以设置<code>GOPROXY</code>这个变量，来设置代理。如果你自己有代理服务器就可以把这个环境变量设置成自己的代理。首先开启<code>go module</code>支持:</p><p>在Mac&#x2F;linux下执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="title class_">GO111MODULE</span>=on</span><br></pre></td></tr></table></figure><p>Windows平台执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span> <span class="title class_">GO111MODULE</span>=on</span><br></pre></td></tr></table></figure><p>我们这里以<code>https://goproxy.cn</code>为例：在Mac&#x2F;linux下可以执行以下命令来设置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="variable constant_">GOPROXY</span>=<span class="attr">https</span>:<span class="comment">//goproxy.cn</span></span><br></pre></td></tr></table></figure><p>Windows平台在<code>cmd</code>执行以下命令来设置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span> <span class="variable constant_">GOPROXY</span>=<span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure><p>或者在<code>PowerShell</code>中执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>:\&gt; <span class="attr">$env</span>:<span class="variable constant_">GOPROXY</span> = <span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之流程控制</title>
      <link href="/posts/4a17b0012.html"/>
      <url>/posts/4a17b0012.html</url>
      
        <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">ifDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a><strong>if条件判断特殊写法</strong></h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">ifDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">forDemo3</span>(<span class="params"></span>) &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.<span class="title class_">Println</span>(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。<br>通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;大拇指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;食指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;中指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;无名指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;小拇指&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;无效的输入！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">testSwitch3</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;奇数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;偶数&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo4</span>(<span class="params"></span>) &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好学习吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好工作吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;好好享受吧&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">switchDemo5</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">fallthrough</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。例如双层嵌套的for循环要退出时：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">gotoDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> breakFlag bool</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">gotoDemo2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">goto breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line"><span class="attr">breakTag</span>:</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;结束for循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bread-跳出循环"><a href="#bread-跳出循环" class="headerlink" title="bread(跳出循环)"></a>bread(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。<br>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">breakDemo1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">BREAKDEMO1</span>:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="title class_">BREAKDEMO1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a><strong>continue(继续下次循环)</strong></h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">continueDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="attr">forloop1</span>:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之运算符</title>
      <link href="/posts/4a17b004.html"/>
      <url>/posts/4a17b004.html</url>
      
        <content type="html"><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算术运算法"><a href="#算术运算法" class="headerlink" title="算术运算法"></a>算术运算法</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意：</strong><code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td></td><td></td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td></td><td></td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>«</td><td>左移n位就是乘以2的n次方。 “a«b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>»</td><td>右移n位就是除以2的n次方。 “a»b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>«&#x3D;</td><td>左移后赋值</td></tr><tr><td>»&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之基本数据类型</title>
      <link href="/posts/4a17b002.html"/>
      <url>/posts/4a17b002.html</url>
      
        <content type="html"><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是uint32，64位操作系统上就是uint64</td></tr><tr><td>int</td><td>32位操作系统上就是int32，64位操作系统上就是int64</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong><br>在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平</p><p>台上的差异。</p><p><strong>注意事项</strong><br>获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法"><a href="#数字字面量语法" class="headerlink" title="数字字面量语法"></a>数字字面量语法</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。<br><code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。<br><code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说：<code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a int = <span class="number">10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b int = <span class="number">077</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c int = <span class="number">0xff</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code> 标准：</p><p><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p><p><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">        fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%f\n&quot;</span>, math.<span class="property">Pi</span>)</span><br><span class="line">        fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, math.<span class="property">Pi</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 complex64</span><br><span class="line">c1 = <span class="number">1</span> + 2i</span><br><span class="line"><span class="keyword">var</span> c2 complex128</span><br><span class="line">c2 = <span class="number">2</span> + 3i</span><br><span class="line">fmt.<span class="title class_">Println</span>(c1)</span><br><span class="line">fmt.<span class="title class_">Println</span>(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>举个例子，我们要打印一个Windows平台下的一个文件路径：</td><td></td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    fmt.<span class="title class_">Println</span>(<span class="string">&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a><strong>byte和rune类型</strong></h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line">func <span class="title function_">traversalString</span>(<span class="params"></span>) &#123;</span><br><span class="line">s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="title function_">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line"><span class="keyword">for</span> _, r := range s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.<span class="title class_">Printf</span>(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="title class_">Println</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span>(h) <span class="number">101</span>(e) <span class="number">108</span>(l) <span class="number">108</span>(l) <span class="number">111</span>(o) <span class="number">230</span>(æ) <span class="number">178</span>(²) <span class="number">153</span>() <span class="number">230</span>(æ) <span class="number">178</span>(²) <span class="number">179</span>(³) </span><br><span class="line"><span class="number">104</span>(h) <span class="number">101</span>(e) <span class="number">108</span>(l) <span class="number">108</span>(l) <span class="number">111</span>(o) <span class="number">27801</span>(沙) <span class="number">27827</span>(河)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的字符串是由byte字节组成，所以字符串的长度是byte字节的长度。rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">changeString</span>(<span class="params"></span>) &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="title function_">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="title function_">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="title function_">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。强制类型转换的基本语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">T</span>(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">sqrtDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c int</span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="title function_">int</span>(math.<span class="title class_">Sqrt</span>(<span class="title function_">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.<span class="title class_">Println</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言基础之变量和常量</title>
      <link href="/posts/4a17b001.html"/>
      <url>/posts/4a17b001.html</url>
      
        <content type="html"><![CDATA[<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。Go语言中有25个关键字;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      func         interface    select</span><br><span class="line"><span class="keyword">case</span>         defer        go           map          struct</span><br><span class="line">chan         <span class="keyword">else</span>         goto         package      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        fallthrough  <span class="keyword">if</span>           range        type</span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Constants</span>:    <span class="literal">true</span>  <span class="literal">false</span>  iota  nil</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Types</span>:    int  int8  int16  int32  int64  </span><br><span class="line">              uint  uint8  uint16  uint32  uint64  uintptr</span><br><span class="line">              float32  float64  complex128  complex64</span><br><span class="line">              bool  byte  rune  string  error</span><br><span class="line"></span><br><span class="line"><span class="title class_">Functions</span>:   make  len  cap  <span class="keyword">new</span>  append  copy  close  <span class="keyword">delete</span></span><br><span class="line">             complex  real  imag</span><br><span class="line">             panic  recover</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string</span><br><span class="line"><span class="keyword">var</span> age int</span><br><span class="line"><span class="keyword">var</span> isOk bool</span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string</span><br><span class="line"><span class="keyword">var</span> age int</span><br><span class="line"><span class="keyword">var</span> isOk bool</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如：整型和浮点型变量的默认值为<code>0</code>。字符串变量的默认值为<code>空字符串</code>。布尔型变量默认为<code>false</code>。切片、函数、指针变量的默认为<code>nil</code>。当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name string = <span class="string">&quot;Macolm&quot;</span></span><br><span class="line"><span class="keyword">var</span> age int = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;Macolm&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Macolm&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.<span class="title class_">Println</span>(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">foo</span>() (int, string) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">x, _ := <span class="title function_">foo</span>()</span><br><span class="line">_, y := <span class="title function_">foo</span>()</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">fmt.<span class="title class_">Println</span>(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。(在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code>不能使用在函数外。</li><li><code>_</code>多用于占位，表示忽略值。</li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。多个常量也可以一起声明：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
